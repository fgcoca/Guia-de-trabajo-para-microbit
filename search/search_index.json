{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introducci\u00f3n","text":"<p>Se pretende crear una gu\u00eda para trabajar con la tarjeta micro:bit mediante:</p> <ul> <li>Programaci\u00f3n gr\u00e1fica con: Makecode, Microblocks, Scratch, ...</li> <li>Programaci\u00f3n con MicroPython</li> </ul> <p>Comienzo por mostrar las versiones de placas micro:bit de una forma breve indicando sus principales diferencias y tambi\u00e9n introduzco diferenes accesorios y shield interesantes.</p> <p>Hablar\u00e9 de la soluci\u00f3n cuando tenemos problemas de descarga de los programas por el puerto USB y tambi\u00e9n de como actualizar o reponer el firmware en la placa micro:bit</p>"},{"location":"#descripcion-grafica","title":"Descripci\u00f3n gr\u00e1fica","text":"<p>En la imagen siguiente vemos la descripci\u00f3n del hardware de la micro:bit 1.3.</p> <p> <p> Hardware micro:bit 1.3</p> <p></p> <p>En la siguiente imagen tenemos la descripci\u00f3n de hardware para la versi\u00f3n 2 que incluye importantes novedades ya que incorpora un pulsador t\u00e1ctil como sensor en el logo, un micr\u00f3fono con indicador LED, un altavoz, LED indicador de actividad USB y una LED indicador de alimentaci\u00f3n.</p> <p> <p> Hardware micro:bit 2</p> <p></p> <ul> <li>El conector microUSB nos servir\u00e1 para programar mediante la t\u00e9cnica de arrastrar y soltar, depurar mediante CMSIS-DAP y ello gracias a que integra webUSB para permitir que podamos conectar nuestra micro:bit a la web mediante el puerto USB</li> <li>Los pads con agujero permiten la conexi\u00f3n mediante pinzas de cocodrilo o conectores tipo banana.</li> <li>La antena de 2.4 GHz sirve para BLE (Bluetooth Low Energy) y transmisi\u00f3n de radio.</li> </ul>"},{"location":"#novedades-v2-y-diferencia-con-v1","title":"Novedades V2 y diferencia con V1","text":"<p>La novedad mas importante de la nueva tarjeta micro:bit V2 es que incorpora un procesador mas potente que su predecesora. Tambi\u00e9n incorpora indicador de bater\u00eda,  micr\u00f3fono, altavoz y un sensor t\u00e1ctil en el logotipo que aumentan sus posibilidades de utilizaci\u00f3n. En la imagen siguiente se se\u00f1alan los nuevos elementos.</p> <p> <p> Novedades micro:bit 2</p> <p></p> <p>Las principales diferencias con micro:bit V1 quedan descritas a continuaci\u00f3n:</p> <ul> <li> <p>El logo es un bot\u00f3n t\u00e1ctil. Se trata de un bot\u00f3n t\u00e1ctil capacitivo que nos da la posibilidad de pulsar de cuatro maneras diferentes, bot\u00f3n A, bot\u00f3n B, bot\u00f3n A y bot\u00f3n B a la vez y bot\u00f3n t\u00e1ctil.</p> </li> <li> <p>Micr\u00f3fono. Se trata de un micro digital MEMS al que se asocia un indicador LED con el icono de un micr\u00f3fono. El t\u00e9rmino MEMS, del ingl\u00e9s MicroElectroMechanical Systems, se refiere a la tecnolog\u00eda electromec\u00e1nica de dispositivos microsc\u00f3picos o sistemas microelectromec\u00e1nicos.</p> </li> <li> <p>Modo ahorro de energ\u00eda. Esta nueva funci\u00f3n de ahorro o modo de espera detendr\u00e1 el programa que se est\u00e9 ejecutando en la micro:bit hasta que se pulse el bot\u00f3n de reinicio.</p> </li> <li> <p>Altavoz. Permite incorporar sonidos a nuestros proyectos.</p> </li> </ul> <p>La microbit v2 tiene cuatro veces mas posibilidades de procesamiento y ocho veces mas memoria RAM que micro:bit V1, y esto gracias a la incorporaci\u00f3n de un procesador nRF52833 ARM Cortex de 64 MHz.</p> <p>Incorpora 512 KB de memoria Flash y 128 KB de memoria RAM.</p>"},{"location":"#hardware-microbit-v2","title":"Hardware micro:bit V2","text":"<p>En la imagen siguiente tenemos una descripci\u00f3n gr\u00e1fica de todos los elementos que integra la micro:bit v2 en sus vistas frontal y posterior.</p> <p> <p> Hardware micro:bit 2</p> <p></p>"},{"location":"#procesador-nrf52","title":"Procesador nRF52","text":"<p>Es donde se ejecutan los programas de usuario. El nRF52 proporciona todos los pines GPIO accesibles para el usuario. Hay integrado un perif\u00e9rico de radio de 2.4GHz que se utiliza para proporcionar capacidades de radio y de Bluetooth. En la tabla siguiente vemos sus principales caracter\u00edsticas.</p> <p> Item Detalles Modelo Nordic nRF52833 Variante del n\u00facleo Procesador Arm Cortex-M4 de 32 bit con FPU Memoria Flash ROM 512 KB Memoria RAM 128 KB Velocidad 64 MHz <p></p>"},{"location":"#comunicacion-inalambrica-bluetooth","title":"Comunicaci\u00f3n inal\u00e1mbrica Bluetooth","text":"<p>El dispositivo integrado de 2,4 GHz Nordic S113 admite comunicaciones Bluetooth a trav\u00e9s del dispositivo de bajo consumo (BLE), permitiendo comunicar la micro:bit con dispositivos Bluetooth como tel\u00e9fonos inteligentes y tabletas.</p> <p> Item Detalles Pila (stack) Bluetooth 5.1 con Bluetooth de bajo consumo (BLE) Banda 2.4GHz ISM (Industrial, Scientific and Medical) 2.4GHz..2.41GHz Canales 50 de 2MHz. Uitilizados del 0 al 39 Sensibilidad -93 dBm en modo BLE Potencia de transmisi\u00f3n -40 dBm a 4 dBm Perfiles BBC micro:bit profile Mas informaci\u00f3n Bluetooth <p></p>"},{"location":"#radiocomunicaciones-de-bajo-nivel","title":"Radiocomunicaciones de bajo nivel","text":"<p>El transceptor integrado de 2,4 GHz soporta una serie de est\u00e1ndares de comunicaciones por radio sobre los que est\u00e1 construido el protocolo de radio micro:bit. Este protocolo proporciona una interfaz de radio sencilla de transmisi\u00f3n de peque\u00f1os paquetes con otros dispositivos que lo admiten, como por ejemplo, otras micro:bit.</p> <p> Item Detalles Protocolo Radio micro:bit Banda de frecuencia 2.4GHz Velocidad de canal 1 Mbps o 2 Mbps Encriptaci\u00f3n Ninguna Canales 80 (0...80) C\u00f3digos de grupo 255 Potencia de transmisi\u00f3n Ocho valores configurables por el usuario, 0 (-30 dbm) a 7 (+4 dbm) Tama\u00f1o de carga 32 (est\u00e1ndar) o 255 (si se configura) Mas informaci\u00f3n Radio micro:bit <p></p>"},{"location":"#botones","title":"Botones","text":"<p>Los dos botones de la parte frontal y el bot\u00f3n de la parte posterior son botones pulsadores normales. El bot\u00f3n de la parte posterior est\u00e1 conectado al procesador de interfaz KL27 y al procesador NRF52 para reiniciar el sistema. De esta forma se garantiza que la aplicaci\u00f3n se reiniciar\u00e1 independientemente de si se alimenta desde USB o desde una bater\u00eda.</p> <p>Los botones frontales A y B se pueden programar en la aplicaci\u00f3n de usuario con cualquier prop\u00f3sito. Los rebotes de A y B se eliminan por software, y tambi\u00e9n incluyen pulsaci\u00f3n corta, pulsaci\u00f3n larga y detecci\u00f3n de pulsaci\u00f3n simultanea de A y B. Los botones funcionan en modo el\u00e9ctrico invertido t\u00edpico, donde una resistencia pull-up asegura un '1' l\u00f3gico cuando se suelta el bot\u00f3n y un '0' l\u00f3gico cuando se pulsa el bot\u00f3n. Ambos botones est\u00e1n conectados a pines GPIO que tambi\u00e9n son accesibles en el conector de borde.</p> <p> Item Detalles Tipo Dos pulsadores de usuario y un pulsador de sistema Rebotes Se eliminan por software con periodos de 54 ms Pullup Los botones A y B con resistencias externas de 4K7 y el de sistema con 10K <p></p>"},{"location":"#pantalla","title":"Pantalla","text":"<p>La pantalla es una matriz de LED de 5x5. El software en tiempo de ejecuci\u00f3n actualiza repetidamente esta matriz a alta velocidad, de modo que est\u00e1 dentro del rango de persistencia visual del usuario y no se detecta parpadeo. Esta matriz de LED tambi\u00e9n se utiliza para detectar luz ambiental.</p> <p> Item Detalles Tipo LED rojo miniatura de montaje Estructura f\u00edsica Matriz de 5x5 Estructura el\u00e9ctrica 5x5 Control de intensidad Control de hasta 255 pasos por software Sensibilidad Estimaci\u00f3n de luz ambiente por algoritmo de software Rango de sensibilidad 10 niveles, de apagado a luminosidad total Sensibilidad de color centro del rojo (700 nm) <p></p>"},{"location":"#sensor-de-movimiento","title":"Sensor de movimiento","text":"<p>La micro:bit dispone de un chip que combina aceler\u00f3metro y magnet\u00f3metro proporcionando as\u00ed detecci\u00f3n de movimiento en 3 ejes y de campo magn\u00e9tico. Incluye detecci\u00f3n de gestos en el hardware (como por ejemplo de ca\u00eddas) y detecci\u00f3n adicional de gestos (por ejemplo, logotipo arriba, logotipo abajo, agitaci\u00f3n) a trav\u00e9s de software. Un algoritmo de software en tiempo de ejecuci\u00f3n utiliza el aceler\u00f3metro integrado para convertir las lecturas en una br\u00fajula independiente de la orientaci\u00f3n de la placa. La br\u00fajula debe calibrarse antes de su uso, y el software en tiempo de ejecuci\u00f3n inicia autom\u00e1ticamente el proceso de calibraci\u00f3n. Este dispositivo est\u00e1 conectado al procesador a trav\u00e9s del bus I2C.</p> <p> Item Detalles Modelo LSM303AGR Caracter\u00edsticas 3 campos magn\u00e9ticos y aceleraci\u00f3n en e ejes. Rangos 2/4/8/16g Resoluci\u00f3n 8/10/12 bits Gestos \"on board\" Ca\u00edda libre Otros gestos Se implementan por software en tiempo de ejecuci\u00f3n <p></p>"},{"location":"#deteccion-de-temperatura","title":"Detecci\u00f3n de temperatura","text":"<p>El procesador NRF52 tiene un sensor de temperatura integrado. Este se expone por software en tiempo de ejecuci\u00f3n y proporciona una estimaci\u00f3n de la temperatura ambiente.</p> <p> Item Detalles Rango de sensibilidad -40 \u00baC ... 105 \u00baC Resoluci\u00f3n Pasos de 0.25 \u00baC Precisi\u00f3n \u00b1 5 \u00baC (sin calibrar) Mas informaci\u00f3n Term\u00f3metro DAL <p></p>"},{"location":"#altavoz","title":"Altavoz","text":"<p>Adem\u00e1s de poder emitir sonido v\u00eda PWM por los pines, la micro:bit v2 incorpora un altavoz ya montado en la placa donde se puede reproducir sonido.</p> <p> Item Detalles Tipo JIANGSU HUANENG MLT-8530 SPL (Sound Pressure Level) 80dB @ 5V, 10cm Frecuencia de resonancia propia 2700Hz Mas informaci\u00f3n Datasheet <p></p>"},{"location":"#microfono","title":"Micr\u00f3fono","text":"<p>Un micr\u00f3fono MEMS (Micro -o nano- Electrical-Mechanical System) incorporado proporciona una entrada de sonido a la micro:bit y un indicador LED integrado en la parte frontal de la placa muestra al usuario cuando est\u00e1 encendido.</p> <p> Item Detalles Tipo Knowles SPU0410LR5H-QB-7 MEMS Sensibilidad -38dB \u00b13dB @ 94dB SPL Relaci\u00f3n se\u00f1al ruido (SNR) 63dB M\u00e1xima ganancia digital (AOP) 118dB SPL Rango de frecuencia 100Hz ... 80kHz Patr\u00f3n polar Omnidireccional Mas informaci\u00f3n Datasheet <p></p>"},{"location":"#pines-gpio","title":"Pines GPIO","text":"<p>Son pines de prop\u00f3sito general de entrada/salida (General Purpose Input/Output). En el conector de borde est\u00e1n muchos de los circuitos GPIO del procesador. Algunos de estos circuitos se comparten con otras funciones de la micro:bit, pero muchos pueden reasignarse para uso de prop\u00f3sito general si se desactivan algunas funciones del software.</p> <p> Item Detalles Anillos 3 de entrada/salida y 2 de alimentaci\u00f3n compatibles con banana de 4mm y pinza de cocodrilo Funciones GPIO 19 pines asignables GPIO 2 para interfaz I2C externa 6 para la pantalla o detecci\u00f3n de luz 2 para detectar los botones de la placa 1 reservado para interfaz de accesibilidad Los 19 se pueden asignar como entrada o salida digital Los 19 pueden asignarse para hasta 3 canales PWM simult\u00e1neos Los 19 se pueden asignar para transmisi\u00f3n serie y un canal de recepci\u00f3n serie 6 pueden asignarse como entrada anal\u00f3gica 3 pueden asignarse para comunicaci\u00f3n SPI 3 se pueden asignar para hasta 3 entradas de detecci\u00f3n t\u00e1ctil Resoluci\u00f3n conversor A/D 10 bits (0...1023). 2\u00b9\u2070=1024 Distancia entre pines 1.27mm, 80 vias a doble cara <p></p>"},{"location":"#alimentacion","title":"Alimentaci\u00f3n","text":"<p>La alimentaci\u00f3n de la micro:bit puede ser a trav\u00e9s de los 5V del conector USB o mediante una bater\u00eda de 3V enchufada al conector JST. Tambi\u00e9n es posible alimentar a la micro:bit desde los anillos 3V/GND en el conector de borde. Los anillos 3V/GND se pueden usar para suministrar energ\u00eda a circuitos externos. La placa utiliza un regulador de baja ca\u00edda o LDO especificado hasta 300 mA con corte t\u00e9rmico para protecci\u00f3n contra cortocircuitos.</p> <p> Item Detalles Rango de operaci\u00f3n 1.8V ... 3.6V Consumo de corriente 300mA m\u00e1ximo Asignado a perif\u00e9erico \"on board\" 90mA Conector de bater\u00eda JST X2B-PH-SM4-TB M\u00e1xima corriente prevista para el conector de borde 190mA Mas informaci\u00f3n Power Supply <p></p>"},{"location":"#interface","title":"Interface","text":"<p>El chip de interfaz maneja la conexi\u00f3n USB y se usa para actualizar el c\u00f3digo nuevo en la micro:bit, enviar y recibir datos en serie de forma bidireccional.</p> <p> Item Detalles Modelo MKL27Z256VFM4 N\u00facleo Arm Cortex-M0+ Flash ROM 256KB (128KB reservados para uso como almacenamiento) RAM 16KB Velocidad 48MHz Depuraci\u00f3n SWD Mas informaci\u00f3n DAPLinkManual del KL27 datasheet KL27 <p></p>"},{"location":"#comunicaciones-usb","title":"Comunicaciones USB","text":"<p>La placa micro:bit tiene una pila de comunicaciones USB incorporada integrada en el firmware del chip de interface. Esta pila brinda la capacidad de arrastrar y soltar archivos en la unidad MICROBIT para cargar c\u00f3digo en el procesador. Tambi\u00e9n permite que los datos en serie se transmitan desde y hacia el procesador de micro:bit a trav\u00e9s de USB a un ordenador externo, y es compatible con el protocolo CMSIS-DAP para la depuraci\u00f3n de programas de aplicaci\u00f3n en el host.</p> <p> Item Detalles Conector USB micro, MCR-B-S-RA-SMT-CS5-TR Versi\u00f3n USB Dispositivo a velocidad completa 2.0 Velocidad 12Mbit/s Clases USB soportadas Clase de almacenamiento masivo (MSC) Clase dispositivo de comunicaciones (CDC) Mas informaci\u00f3n DAPLink <p></p>"},{"location":"#depuracion","title":"Depuraci\u00f3n","text":"<p>El procesador de interface se puede utilizar con herramientas de host especiales para depurar el c\u00f3digo que se ejecuta en el procesador de la aplicaci\u00f3n. Se conecta al procesador de aplicaciones a trav\u00e9s de 4 cables de se\u00f1al. El c\u00f3digo del procesador de la interfaz KL27 tambi\u00e9n se puede depurar a trav\u00e9s de su interfaz de depuraci\u00f3n del software SWD integral, por ejemplo, para cargar el c\u00f3digo del cargador de arranque inicial en este procesador en el momento de la fabricaci\u00f3n, o para recuperarlo si se ha perdido.</p> <p> Item Detalles Protocolo CMSIS-DAP Opciones JLink/OB (via different firmware) Mas informaci\u00f3n Mbed debugging micro:bit <p></p>"},{"location":"#mecanicos","title":"Mec\u00e1nicos","text":"<p>Hay disponibles algunos dibujos CAD 2D y 3D y modelos de la micro:bit que incluyen todas las dimensiones importantes. Estos modelos se pueden utilizar como base para generar im\u00e1genes de proyecto y marketing de micro:bit, pero tambi\u00e9n como base para la fabricaci\u00f3n precisa de accesorios, por ejemplo, mediante impresi\u00f3n 3D.</p> <p> Item Dimensiones Ancho 51,60 mm Alto 42,00 mm Profundidad 11,65 mm Altura del bot\u00f3n a la placa 4,55 mm Altura del altavoz 3 mm Conector JST 5,50 mm <p></p>"},{"location":"#conector-de-borde","title":"Conector de borde","text":"<p>Hay 25 pistas/patillas que incluyen 5 agujeros para usar con clavijas tipo banana de 4 mm o pinzas de cocodrilo. Tres de estos anillos son para entrada y salida de prop\u00f3sito general (GPIO) y tambi\u00e9n sirven para detecci\u00f3n anal\u00f3gica, PWM y t\u00e1ctil, y dos est\u00e1n conectados a la alimentaci\u00f3n de la micro:bit.</p> <p>Las pistas mas finas est\u00e1n separadas 1,27 mm, algunas son utilizadas por micro:bit y otras est\u00e1n disponibles para su uso mediante cualquiera de los conectores externos existentes.</p> <p>Solamente tienen conexi\u00f3n las pistas frontales, las posteriores est\u00e1n sin conexi\u00f3n y los anillos posteriores est\u00e1n conectados a los delanteros.</p> <p>En la imagen siguiente tenemos la descripci\u00f3n de pines de la micro:bit v2 a la izquierda y de la v1 a la derecha para poder comparar y establecer las diferencias de una forma sencilla.</p> <p> <p> Pinout micro:bit V2 y V1</p> <p></p> <p>En microbit.pinout.xyz tenemos un fant\u00e1stico recurso para obtener m\u00e1s informaci\u00f3n sobre los pines de la micro:bit y de c\u00f3mo los utilizan algunos accesorios.</p> <p>En en enlace tenemos una guia de accesorios para micro:bit</p>"},{"location":"#protectores","title":"Protectores","text":"<p>Existen en el mercado protectores para las micro:bit realizados en metacrilato transparente, silicona de distintos colores y formas y otros materiales. Estos elementos son f\u00e1ciles de encontrar en las tiendas que comercializan la placa.</p> <p>Aqu\u00ed daremos toda la informaci\u00f3n necesaria para personalizar e imprimir en 3D nuestros propios protectores.</p>"},{"location":"#microbit-v1","title":"micro:bit V1","text":"<p>Carcasa de protecci\u00f3n para la versi\u00f3n 1 de la tarjeta micro:bit basada en un dise\u00f1o de tatan.</p> <p>La base tiene el siguiente aspecto en fase de dise\u00f1o y montada:</p> <p> <p> Protector micro:bit V1</p> <p></p> <p>A continuaci\u00f3n se da el listado de ficheros de dise\u00f1o y de impresi\u00f3n 3D listos para descargar.</p> <p> Descripci\u00f3n Archivo Enlace Archivo de dise\u00f1o proteccionV1.FCStd Fuente Base en STL base.stl Base Tapa en STL tapa.stl Tapa Base STEP base.step Base Tapa STEP tapa.step Tapa <p></p>"},{"location":"#microbit-v2","title":"micro:bit V2","text":"<p>El modelo se inspira en el dise\u00f1o para microbit v1 de crozes ga\u00ebtan (tatan) y tiene el aspecto final que vemos en la animaci\u00f3n siguiente:</p> <p> <p> Partes del modelo 3D</p> <p></p> <p>En las im\u00e1genes siguientes vemos el aspecto que tiene la base por sus dos caras.</p> <p> Parte delantera de la base Parte trasera de la base <p></p> <p>En las im\u00e1genes siguientes vemos el aspecto que tiene la tapa por sus dos caras.</p> <p> Parte delantera de la tapa Parte trasera de la tapa <p></p> <p>En la tabla siguiente tenemos los archivos del proyecto listos para descargar.</p> <p> Descripci\u00f3n STL AMF STEP Base baseV2.stl baseV2.amf baseV2.step Tapa tapaV2.stl tapaV2.amf tapaV2.step <p></p> <p>Este es el enlace al archivo de dise\u00f1o en FreeCAD y este a la TTF utilizada para crear los letreros.</p> <p>El aspecto del protector una vez montado lo tenemos en la imagen siguiente.</p> <p> <p> Partes del modelo 3D</p> <p></p>"},{"location":"#enlaces","title":"Enlaces","text":"<p>Antes de poner un listado de enlaces interesantes diremos que BBC micro:bit es una placa programable de 4x5 cm de c\u00f3digo abierto que permite aprender a programar de una forma f\u00e1cil y divertida que est\u00e1 al alcance de todos.</p> <p>Dado que incorpora muchos sensores es posible realizar una cantidad importante de proyectos disponiendo solamente de la placa.</p> <p>BBC micro:bit se puede programar de muchas formas,</p> <ul> <li>De forma visual o por bloques mediante:<ul> <li>MakeCode de Microsoft, un editor gr\u00e1fico online gratuito.</li> <li>MicroBlocks, un lenguaje de programaci\u00f3n por bloques para aprender computaci\u00f3n f\u00edsica.</li> <li>Scratch (a\u00f1adiendo una extensi\u00f3n).</li> <li>Open Roberta Lab, un entorno de programaci\u00f3n en l\u00ednea para robots con el lenguaje de programaci\u00f3n gr\u00e1fico NEPO.</li> </ul> </li> <li>Mediante c\u00f3digo:<ul> <li>JavaScript, un lenguaje de programaci\u00f3n o de secuencias de comandos que permite implementar funciones complejas en p\u00e1ginas web din\u00e1micas.</li> <li>MicroPython, un peque\u00f1o pero eficiente interprete del lenguaje de programaci\u00f3n Python, optimizado para funcionar en microcontroladores.</li> <li>Python, lenguaje de programaci\u00f3n de alto nivel que no se compila, sino que se interpreta.</li> </ul> </li> </ul> <p>El c\u00f3digo interpretado necesita de un interprete, que se define como la capa l\u00f3gica de software que se pone entre el c\u00f3digo y el hardware, es decir, el interprete es el encargado de procesar el c\u00f3digo de programa y hacer posible que el hardware lo ejecute.</p> <p>Aqu\u00ed vamos a usar principalmente MakeCode, MicroBlocks y MicroPython, aunque se dar\u00e1n pinceladas con otros entornos. Tambi\u00e9n abordaremos en su momento el tema IoT utiliando la placa micro:bit.</p> <p>Enlaces muy importantes son:</p> <ul> <li>Web en ingl\u00e9s</li> <li>Web en espa\u00f1ol</li> <li>Comunidad micro:bit en espa\u00f1ol</li> <li>Github de microbit</li> <li>Comunidad de desarrollo de micro:bit. Wiki de la comunidad con informaci\u00f3n t\u00e9cnica de micro:bit.</li> <li>Editor gr\u00e1fico Makecode estable.</li> <li>Web de MicroBlocks</li> <li>Editor online de MicroBlocks</li> <li>Editor Python de micro:bit. Sencillo editor de c\u00f3digo basado en navegador.</li> <li>Mu. Sencillo editor de c\u00f3digo sin conexi\u00f3n.</li> <li>uFlash. Herramienta de l\u00ednea de comandos para mostrar secuencias de comandos de Python sin procesar en un micro:bit.</li> <li>IDLE. Un IDE de c\u00f3digo abierto multiplataforma que se instala por defecto con Python.</li> <li>BBC Micro:bit MicroPython documentation.</li> <li>Instalaci\u00f3n de Mu-editor en Linux, OSX y Window.</li> <li>Bot de programaci\u00f3n Open Roberta Lab.</li> <li>Thonny. Sencillo IDE para Python.</li> </ul>"},{"location":"configura/","title":"Configurar nuestra micro:bit","text":"<p>Para poder continuar le tenemos que decir a la micro:bit lo que queremos que haga. Esto es dar a la micro:bit una serie de instrucciones contenidas en programas. Estos programas, en el caso de micro:bit, se pueden escribir de diferentes maneras y nosotros vamos a ver fundamentalmente como hacerlo en los editores online de bloques MakeCode y MicroBlocks o Python de texto.</p> <p>Debemos disponer de un ordenador, un tel\u00e9fono o una tableta para escribir el c\u00f3digo, conectar la micro:bit a nuestro dispositivo lo que haremos de alguna de estas formas:</p> <ul> <li>Con ordenador. Es la forma mas usual y sencilla y consiste en utilizar un cable microUSB para realizar la conexi\u00f3n de la micro:bit al ordenador. Esta forma la vamos a describir de manera mas extensa a continuaci\u00f3n.</li> <li>Tel\u00e9fono o tableta. En este caso debemos utilizar Bluetooth para conectar ambos dispositivos de manera inal\u00e1mbrica. Podemos consultar mas detalles en Transferir desde la aplicaci\u00f3n m\u00f3vil, web que adem\u00e1s nos va a servir de referencia para el resto de este apartado.</li> </ul>"},{"location":"configura/#transferir-desde-ordenador","title":"Transferir desde ordenador","text":"<p>Los programas de usuario se copian en la memoria flash (no volatil) de la micro:bit por lo que a esta operaci\u00f3n se le suele conocer como flasheo. La V1 tiene 256 KB de memoria flash y la V2 512 KB</p> <p>Cuando se est\u00e1 flasheando un programa la micro:bit pausa la ejecuci\u00f3n del programa que tenga en memoria y el LED amarillo de la cara posterior estar\u00e1 parpadeando mientras se est\u00e9 copiando el nuevo programa. Una vez finalizada la copia, el nuevo programa comienza a ejecutarse en la micro:bit.</p>"},{"location":"configura/#arrastrar-y-soltar","title":"Arrastrar y soltar","text":"<p>El proceso es exactamente igual que cuando transferimos un archivo desde el ordenador a un pendrive o memoria USB y funciona en cualquier ordenador. Lo que tenemos que hacer es:</p> <ul> <li>Descargar el programa como un archivo .hex desde el editor de c\u00f3digo al ordenador, habitualmente al directorio de descargas. Finalmente se arrastra y suelta el archivo .hex en la unidad MICROBIT.</li> <li>Despu\u00e9s de transferir el archivo .hex, la unidad MICROBIT se desconectar\u00e1 y reconectar\u00e1 seg\u00fan la micro:bit se reinicia. El archivo .hex no aparecer\u00e1 en la unidad MICROBIT dado que la micro:bit no es un dispositivo de almacenamiento flash, aunque el ordenador lo muestra como tal para facilitar la transferencia de archivos .hex.</li> </ul> <p>En el enlace Transferir desde la aplicaci\u00f3n m\u00f3vil hay disponibles videos que muestran c\u00f3mo funciona este sistema. Simplemente elegimos nuestro sistema operativo (Windows, Mac, Chromebook o Linux/Raspberry Pi) y vemos el proceso.</p> <p>En la animaci\u00f3n siguiente (descarga de la web citada en el p\u00e1rrafo anterior) vemos el proceso completo en el caso de Linux.</p> <p> <p> Flasheo mediante arrastrar y soltar</p> <p></p>"},{"location":"configura/#flasheo-directo","title":"Flasheo directo","text":"<p>Se pueden enviar programas directamente desde los editores de c\u00f3digo en l\u00ednea a la micro:bit sin necesidad de descargar el archivo .hex y seguir el proceso anterior, lo que resulta f\u00e1cil y r\u00e1pido.</p> <p>El flasheo directo solamente funciona en los navegadores Chrome o Edge que soportan webUSB. Tambi\u00e9n es necesario tener actualizado el firmware de la micro:bit, especialmente si es un modelo que tiene mucho tiempo.</p> <p>IMPORTANTE: EL flasheo directo es r\u00e1pido y f\u00e1cil, y excelente para la depuraci\u00f3n, pero no SE guarda una copia deL programa en el ordenador. Si es importante mantener una copia del c\u00f3digo es preferible utilizar el m\u00e9todo de arrastrar y soltar, o en su defecto tener siempre la precauci\u00f3n de descargar el archivo .hex cuando se ha completado exit\u00f3samente el proyecto aunque durante el proceso se relicen pruebas del funcionamiento o depuraci\u00f3n del c\u00f3digo mediante este m\u00e9todo.</p> <p>En la web de referencia tenemos disponibles videos demostrativos de como se realiza el proceso.</p>"},{"location":"configura/#algunos-problemas-con-webusb","title":"Algunos problemas con WebUSB","text":"<p>La informaci\u00f3n de referencia de lo que se dice aqu\u00ed est\u00e1 en WebUSB Troubleshooting.</p> <p>Antes de nada debemos tener en cuenta todo lo indicado referente al sistema operativo, los navegadores compatibles y la versi\u00f3n de firmware requerida.</p> <p>La micro:bit nos debe aparecer en el navegador como BBC micro:bit CMSIS-DAP aunque es posible que la primera vez nos aparezca como LPC1768.</p> <p>Si nos estamos cambiando entre editores, por ejemplo MakeCode y Python, seguramente la actualizaci\u00f3n de programas mediante webUSB requiere mas tiempo del habitual ya que la micro:bit contiene un programa creado con un editor diferente.</p> <p>Si tenemos problemas cuando tenemos conectada alimentaci\u00f3n externa, procedemos a desconectar esta alimentaci\u00f3n y el cable microUSB garantizando asi el total apagado de la placa. Conectamos solamente el cable microUSB tanto a la micro:bit como al ordenador e intentamos de nuevo el flasheo. Es indiferente para esto conectar la bateria tras conectar el cable microUSB o hacerlo en otro momento.</p> <p>Si estamos en un sistema Linux y se ha instalado Chromium desde snap store, que es la tienda oficial de software de Ubuntu, no podremos acceder a dispositivos webUSB. En distribuciones como Ubuntu suele solucionar el problema declarar una regla udev. A continuaci\u00f3n se indica como hacerlo:</p> <ul> <li>Cerramos el navegador Chrome o Chormium</li> <li>Creamos un fichero 50-microbit.rules en:</li> </ul> <pre><code>/etc/udev/rules.d/50-microbit.rules\n</code></pre> <ul> <li>El contenido del fichero ser\u00e1:</li> </ul> <p>SUBSYSTEM==\"usb\", ATTR{idVendor}==\"0d28\", MODE=\"0664\", GROUP=\"plugdev\"</p> <ul> <li>A\u00f1adimos nuestro nombre de usuario al grupo plugdev mediante:</li> </ul> <pre><code>sudo usermod -a -G plugdev &lt;nombre-usuario&gt;\n</code></pre> <ul> <li>Restablecemos las reglas udev haciendo:</li> </ul> <pre><code>sudo udevadm control --reload-rules\n</code></pre> <ul> <li>Cerramos sesi\u00f3n.</li> <li>Tras iniciar sesi\u00f3n de nuevo abrimos Chrome y lo volvemos a intentar.</li> </ul> <p>Los comandos siguientes:</p> <pre><code>snap connections  | grep -v \".*-$\"\nmount | grep MICROBIT\n</code></pre> <p>nos resultar\u00e1n \u00fatiles para comprobar si el navegador ha establecido la conexi\u00f3n y si esta se ha realizado. El segundo nos ayuda a montar la unidad \"MICROBIT\" si no se monta al conectar una placa micro:bit. En la figura siguiente vemos un posible resultado.</p> <p> <p> Comandos snap connections y mount</p> <p></p>"},{"location":"configura/#sistema-de-prueba","title":"Sistema de prueba","text":"<p>Mediante el hilo indicado en la webgrafia y utilizando la informaci\u00f3n obtenida de WebUSB Troubleshooting ha quedado resuelto el tema de utilizar webUSB con Chromium y se propone un m\u00e9todo de prueba de errores que a mi entender nos puede resultar bastante \u00fatil en un momento determinado.</p> <p>Cuando estamos teniendo problemas para grabar firmware mediante la t\u00e9cnica de arrastrar y soltar (drag &amp; drop) y/o flasheando desde la web del editor, nos resultar\u00e1 \u00fatil disponer de una colecci\u00f3n de archivos que permitan ir realizando pruebas al tiempo que llevamos la cuenta de las pruebas realizadas.</p> <p>Es Martin Williams de Micro:bit Educational Foundation quien propone el sistema y el procedimiento a seguir.</p> <ul> <li>Siempre que tengamos un error tenemos que desconectar y volver a conectar el USB antes de probar de nuevo con el mismo archivo.</li> <li>Crear un script de Python en el que podamos ir cambiando el n\u00famero de intento cuando el programa se flashea o graba correctamente.</li> </ul> <p>El script de Python propuesto lo he modificado y queda as\u00ed:</p> <pre><code># Las importaciones al principio\n\"\"\"En Python, se utiliza la palabra clave import \npara hacer que el c\u00f3digo de un m\u00f3dulo est\u00e9 \ndisponible en otro.\"\"\"\nfrom microbit import *\n\ndisplay.show(Image.HEART)\nsleep(1000)\n\n# El c\u00f3digo en'while True:' se repite indefinidamente\nwhile True:\n    display.show(0) #Contamos cambiando el valor aqu\u00ed\n    sleep(1000)\n</code></pre> <p>En el fichero 10_archivos_hex_python.zip tenemos los 10 archivos hexadecimal generados y probados. El primero de los cuales (python0-main.py) tambi\u00e9n lo tenemos en formato texto.</p>"},{"location":"directo/","title":"Flasheo directo","text":"<p>Vamos a repetir y repasar todo lo necesario para poder grabar firmware en la micro:bit desde la p\u00e1gina web del editor que estemos utilizando mediante webUSB.</p>"},{"location":"directo/#repaso","title":"Repaso","text":"<ul> <li>Estoy trabajando con sistema operativo Ubuntu 22.04.2 LTS de 64 bits.</li> <li>Inicialmente el navegador utilizado ha sido Chromium Versi\u00f3n 114.0.5735.198 (Build oficial) snap (64 bits). Con este navegador se consigue conectar con la micro:bit desde remoto pero sin \u00e9xito en el volcado del firmware.</li> <li>El flasheo directo solamente funciona en los navegadores Chrome o Edge que soportan webUSB. Opto finalmente por utilizar Google Chrome para flashear.</li> <li>Recordemos que tambi\u00e9n es necesario tener actualizado el firmware de la micro:bit.</li> <li>Seguir los pasos descritos en el Soluci\u00f3n de problemas de WebUSB.</li> </ul> <p>Se han llevado a cabo los pasos siguientes:</p> <ul> <li>Cuando trabajamos con distribuciones Linux como Ubuntu hay que declarar una regla udev. Para hacerlo: cerramos el navegador, nos aseguramos de que existe el grupo plugdev haciendo:</li> </ul> <pre><code>getent group\n</code></pre> <ul> <li>Si no existe el grupo lo creamos con:</li> </ul> <pre><code>getent group plugdev &gt;/dev/null || sudo groupadd -r plugdev\n</code></pre> <ul> <li>Si es necesario agregamos nuestro usuario al grupo plugdev (reemplazamos \"tu-nombre-de-usuario\" con el nombre real de usuario):</li> </ul> <pre><code>sudo usermod -a -G plugdev &lt;tu-nombre-de-usuario&gt;\n</code></pre> <ul> <li>Creamos un archivo en el directorio /etc/udev/rules.d que llamaremos 50-microbit.rules haciendo:</li> </ul> <pre><code>sudo nano/etc/udev/rules.d/50-microbit.rules\n</code></pre> <ul> <li>Introducimos la l\u00ednea que vemos en la imagen.</li> </ul> <p> <p> Creaci\u00f3n regla udev</p> <p></p> <pre><code>SUBSISTEMA==\"usb\", ATTR{idVendor}==\"0d28\", MODO=\"0664\", GRUPO=\"plugdev\"\n</code></pre> <ul> <li>Reiniciamos las reglas udev</li> </ul> <pre><code>sudo udevadm control --reload-rules \n</code></pre> <ul> <li>Cerramos sesi\u00f3n o reiniciamos el sistema y ya podemos trabajar de nuevo.</li> </ul>"},{"location":"directo/#pruebas-finales","title":"Pruebas finales","text":"<p>Para comprobar que todos los cambios propuestos anteriormente se han realizado correctamente vamos a ejecutar desde una terminal los comandos siguientes:</p> <pre><code>groups\ncat /etc/udev/rules.d/50-microbit.rules\nls -l /etc/udev/rules.d\n</code></pre> <p>Como vemos en la imagen siguiente, el primer comando nos indica que el usuario est\u00e1 en el grupo requerido, el segundo nos muestra la sintaxis de la regla creada y con el tercero simplemente comprobamos que el fichero creado efectivamente est\u00e1 y adem\u00e1s en el directorio correspondiente.</p> <p> <p> Creaci\u00f3n regla udev</p> <p></p> <p>En la imagen se ha indicado la existencia del archivo de reglas udev creado con la instalaci\u00f3n del navegador Chromium, pero en este no existe ninguna regla para micro:bit y personalmente no he querido tocar el mismo.</p>"},{"location":"directo/#makecode","title":"MakeCode","text":"<p>Iniciamos el navegador Chromium o Google Chrome, este \u00faltimo preferiblemente desde un perfil sin cuenta o con una cuenta que tenga poca actividad.</p> <p>Conectamos nuestra micro:bit a un puerto USB y procedemos a emparejarla con el navegador. Si nos da alg\u00fan tipo de error debemos probar a desconectar y volver a conectar la micro:bit del USB y repetir la operaci\u00f3n.</p> <p>Para el caso de Chromium ser\u00e1 algo similar a lo siguiente:</p> <p> <p> Flasheo directo en Chromium</p> <p></p> <p>Para el caso de Chrome ser\u00e1 algo similar a lo siguiente:</p> <p> <p> Flasheo directo en Chrome</p> <p></p>"},{"location":"directo/#python","title":"Python","text":"<p>Para el caso de Chromium ser\u00e1 algo similar a lo siguiente:</p> <p> <p> Flasheo directo en Chromium</p> <p></p> <p>Para el caso de Chrome ser\u00e1 algo similar a lo siguiente:</p> <p> <p> Flasheo directo en Chrome</p> <p></p> <p>Tenemos que recordar siempre archivar nuestro trabajo.</p>"},{"location":"plantilla/","title":"Titulo","text":""},{"location":"plantilla/#t","title":"t","text":""},{"location":"plantilla/#t_1","title":"t","text":"<p> <p> xx</p> <p></p> <p>- Consejo: </p>"},{"location":"problemas/","title":"Soluci\u00f3n de problemas con descargas webUSB","text":"<p>Si estamos teniendo problemas para emparejar la micro:bit con WebUSB vamos a intentar averiguar por qu\u00e9.</p> <p>Las indicaciones van a estar basadas siempre en Ubuntu 22.04.2 LTS.</p>"},{"location":"problemas/#paso-1-comprobar-el-cable","title":"Paso 1: Comprobar el cable","text":"<p>Conectamos la placa micro:bit a un puerto USB mediante un cable microUSB. Debemos ver que se monta un dispositivo de nombrre MICROBIT y que est\u00e1 activo, como en la imagen siguiente:</p> <p> <p> Unidad MICROBIT montada</p> <p></p> <p>La forma de ver la unidad montada depender\u00e1 de nuestro sistema operativo.</p> <p>Si podemos ver la unidad MICROBIT montada podemos pasar al paso 2 y si no procedemos a:</p> <ul> <li>Asegurarnos que el cable no est\u00e1 da\u00f1ado. Podemos probarlo en otro ordenador o utilizar un cable diferente. Hay que tener presente que algunos cables comerciales solo conectan alimentaci\u00f3n y no tienen realizadas las conexiones de transmisi\u00f3n de datos.</li> <li>Probar en otro puerto USB del ordenador.</li> </ul> <p>Si podemos asegurar que el cable est\u00e1 bien pero no aparece la unidad MICROBIT, es posible que tengamos un problema con la micro:bit. Hay que probar los pasos adicionales descritos en la p\u00e1gina de b\u00fasqueda de fallos en microbit.org. Si esto tampoco nos ayuda, podemos crear un New support ticket para notificar el problema a la Fundaci\u00f3n Micro:bit y esperar obtener una respuesta. Si estamos en este caso hay que omitir el resto de pasos hasta obtener la respuesta.</p>"},{"location":"problemas/#paso-2-verificar-la-version-de-firmware","title":"Paso 2: Verificar la versi\u00f3n de firmware","text":"<p>Es posible que el firmware de la micro:bit necesite una actualizaci\u00f3n. Vamos a comprobarlo:</p> <ul> <li>Accedemos a la unidad MICROBIT montada.</li> <li>Abrimos con un editor de texto el archivo de solo lectura DETAILS.TXT.</li> <li>Comprobamos el n\u00famero que pone junto a Interface Version.</li> </ul> <p> <p> Comprobaci\u00f3n de la versi\u00f3n de firmware</p> <p></p> <p>Si la versi\u00f3n 0234, 0241 o 0243 es necesario actualizar el fimware de esa micro:.bit siguiendo el proceso que vamos a indicar en el paso 3. En la imagen anterior observamos que la versi\u00f3n del firmware es Interface Version: 0249.</p> <p>Si tenemos la versi\u00f3n 0249, 0250 o mayor trabajamos con el firmaware correcto y podemos saltar al paso 4.</p>"},{"location":"problemas/#paso-3-actualizar-firmware","title":"Paso 3: Actualizar firmware","text":"<p>Si se requiere una actualizaci\u00f3n del firmware para acceder a nuevas caracter\u00edsticas o para solucionar alg\u00fan problema, debemos proceder as\u00ed:</p> <ul> <li>Desconectar la micro:bit de cualquier tipo de alimentaci\u00f3n, ya sea por USB o por baterias.</li> <li>Con el pulsador de reset de la parte posterior accionado conectamos la micro:bit a un puerto USB y esperamos a que se monte una unidad llamada MAINTENANCE (en lugar de MICROBIT) como observamos en la figura siguiente.</li> </ul> <p> <p> Micro:bit en modo MAINTENANCE</p> <p></p> <p>La forma de ver la unidad montada depender\u00e1 de nuestro sistema operativo.</p> <ul> <li>Descargamos el archivo .hex apropiado para nuestra versi\u00f3n de micro:bit. El n\u00famero de versi\u00f3n est\u00e1 impreso en la parte inferior derecha de la cara trasera del dispositivo. Existen unas cuantas formas de distinguir que versi\u00f3n de placa tenemos.</li> </ul>"},{"location":"problemas/#identificar-el-numero-de-version","title":"Identificar el n\u00famero de versi\u00f3n","text":"<p>Actualmente hay dos versiones oficiales de BBC micro:bit, la V1 y la V2.</p> <p>Ambas versiones trabajan de la misma forma por lo que podemos continuar utilizando las versiones previas de la forma habitual.</p> <p>La primera forma de saber el n\u00famero de versi\u00f3n (V2.20, V2, V1.5, V1.3B) es mirar en la esquina inferior derecha de la cara posterior (figura siguiente). Si no podemos ver el n\u00famero es muy probable que tengamos una micro:bit 1.3 en la que el n\u00famero de versi\u00f3n serigrafiado se quedaba debajo de la pintura negra.</p> <p> <p> N\u00famero de versi\u00f3n serigrafiado</p> <p></p> <p>Como segunda forma, si en la parte posterior del dispositivo en versiones V2, veremos una etiquetara identifica MICROPHONE (MICR\u00d3FONO) y otra otra para el SPEAKER (ALTAVOZ), y adem\u00e1s la ANTENA BLE es de color dorado.</p> <p> <p> N\u00famero de versi\u00f3n seg\u00fan la antena</p> <p></p> <p>Para la tercer forma nos fijaremos en si el conector de borde tiene muescas que ser\u00e1n \u00fatiles para facilitar el uso de pinzas de cocodrilo o no dispone de dichas muescas. En la figura siguiente vemos la diferencia.</p> <p> <p> N\u00famero de versi\u00f3n seg\u00fan el conector de borde</p> <p></p> <p>y la cuarta forma es el logototipo de micro:bit en la parte frontal del dispositivo, que en la versi\u00f3n V2 es dorado como el conector de borde y adem\u00e1s es un pulsador t\u00e1ctil que se puede usar como un pin de entrada. En la figura vemos las diferencias.</p> <p> <p> N\u00famero de versi\u00f3n seg\u00fan el logotipo de micro:bit</p> <p></p>"},{"location":"problemas/#microbit-v1","title":"Micro:bit V1","text":"<p>Si tenemos una micro:bit V1 (sin altavoz ni micr\u00f3fono), todas las placas usan el mismo firmware.</p> <p> <p>Firmware para V1</p> <p></p>"},{"location":"problemas/#microbit-v2","title":"Micro:bit V2","text":"<p>Si tenemos una micro:bit V2 (con altavoz y micr\u00f3fono), existen dos posibles versiones de firmware; la V2.00 y la V2.20/2.21. Debemos seleccionar el firmware apropiado para nuestra placa.</p> <p> <p>Firmware para V2.00 --- Firmware para V2.20/2.21</p> <p></p> <ul> <li>Arrastramos y soltamos el fichero .hex que hemos descargado en la unidad montada como MAINTENANCE y esperamos a que el LED amarillo de la cara posterior deje de parpadear. Cuando la actualizaci\u00f3n se ha completado la micro:bit se resetear\u00e1, se expulsar\u00e1 del ordenador y volver\u00e1 a aparecer en modo MICROBIT.</li> <li>Finalmente debemos comprobar el archivo DETAILS.TXT para asegurarnos que la versi\u00f3n de firmware descargada se ha flsheado en el chip de interface.</li> <li>Si tenemos cualquier problema con el proceso de actualizaci\u00f3n del firmware debemos contactar con micro:bit support que es la p\u00e1gina de soporte en ingl\u00e9s.</li> <li>Todas las versiones de firmware, actuales, anteriores y beta est\u00e1n disponibles en previous firmware versions.</li> </ul>"},{"location":"problemas/#paso-4-comprobar-la-version-del-navegador","title":"Paso 4: Comprobar la versi\u00f3n del navegador","text":"<p>WebUSB es una caracter\u00edstica muy actual y puede requerir que el navegador est\u00e9 actualizado. Verifiquemos que el navegador coincida con los descritos navegadores soportados. Est\u00e1n soportados diferentes navegadores como Microsoft Edge, Google Chrome o Chromium, Mozilla Firefox y Safari para los distintos sistemas operativos y versiones.</p>"},{"location":"problemas/#paso-5-emparejar-dispositivo","title":"Paso 5: Emparejar dispositivo","text":"<p>Una vez que hemos actualizado el firmware, abrimos nuestro navegador compatible, vamos al editor que estemos utilizando para programar y procedemos a Emparejar dispositivo. Ya estamos preparados para comenzar a trabajar siguiendo los pasos iniciales que se describen en Configurar nuestra micro:bit.</p>"},{"location":"Miscelanea/about/","title":"Autor","text":"<p>Federico Coca</p> <ul> <li> <p>GitHub</p> </li> <li> <p>Twitter</p> </li> <li> <p>Instagram</p> </li> <li> <p>Mas informaci\u00f3n</p> </li> </ul>"},{"location":"Miscelanea/lic/","title":"Licencias","text":"<ul> <li> <p>Licencia MIT incluida en la creaci\u00f3n del repositorio.</p> </li> <li> <p>Creative Commons Atribuci\u00f3n-CompartirIgual 4.0 International (\"CC BY-SA\"). CC BY-SA 4.0 </p> </li> </ul> <p> <p> </p> <p></p>"},{"location":"Miscelanea/soft/","title":"Software utilizado","text":"<ul> <li> <p>Sistema operativo: Ubuntu 22.04</p> </li> <li> <p>Paquete ofim\u00e1tico de referencia: LibreOffice</p> </li> <li> <p>Libreria Material para MkDocs</p> </li> <li> <p>Visual Studio Code</p> </li> <li> <p>Creaci\u00f3n de GIF animados para Ubuntu Peek</p> </li> <li> <p>Sistema principal de capturas de pantalla: Shutter</p> </li> <li> <p>Dibujo 2D vectorial Inkscape</p> </li> <li> <p>Retoque de im\u00e1genes GIMP</p> </li> <li> <p>Editor gr\u00e1fico Makecode estable.</p> </li> <li> <p>Editor de MicroBlocks</p> </li> <li> <p>Editor Python de micro:bit.</p> </li> <li> <p>Mu.</p> </li> <li> <p>IDLE.</p> </li> <li> <p>Thonny. Sencillo IDE para Python.</p> </li> </ul>"},{"location":"Miscelanea/webgrafia/","title":"Webgraf\u00eda y bibliograf\u00eda","text":"<ul> <li> <p>Wikipedia</p> </li> <li> <p>Web en ingl\u00e9s</p> </li> <li>Web en espa\u00f1ol</li> <li>Comunidad micro:bit en espa\u00f1ol</li> <li>Github de microbit</li> <li>Comunidad de desarrollo de micro:bit. Wiki de la comunidad con informaci\u00f3n t\u00e9cnica de micro:bit.</li> <li>Editor gr\u00e1fico Makecode estable.</li> <li>Web de MicroBlocks</li> <li>Editor online de MicroBlocks</li> <li>Editor Python de micro:bit. Sencillo editor de c\u00f3digo basado en navegador.</li> <li>Mu. Sencillo editor de c\u00f3digo sin conexi\u00f3n.</li> <li>uFlash. Herramienta de l\u00ednea de comandos para mostrar secuencias de comandos de Python sin procesar en un micro:bit.</li> <li>IDLE. Un IDE de c\u00f3digo abierto multiplataforma que se instala por defecto con Python.</li> <li>BBC Micro:bit MicroPython documentation.</li> <li>Instalaci\u00f3n de Mu-editor en Linux, OSX y Window.</li> <li>Bot de programaci\u00f3n Open Roberta Lab.</li> <li> <p>Thonny. Sencillo IDE para Python.</p> </li> <li> <p>Gu\u00eda Programiz para aprender Python programando. Incluye un interesante compilador online y otros muchos recursos.</p> </li> <li> <p>Web Ardutaller de Francisco Soldado.</p> </li> <li> <p>MicroBlocks Wiki</p> </li> <li> <p>micro:bit Micropython API</p> </li> <li>Gu\u00eda de micro:bit paso a paso para principiantes de Bricogeek.</li> <li>Recursos sobre micro:bit de Pedro Ruiz.</li> <li> <p>Retos de Micro:bit con Python por Pedro Ruiz</p> </li> <li> <p>Consulta realizada en \u00bfC\u00f3mo podemos ayudarte? de micro:bit Help &amp; Support con el ticket 64940 referente a un error 504 con una BBC micro:bit V2.00 sobre Ubuntu 22.04.2 LTS con navegador Chromium 114.0.5735.198 version.</p> </li> </ul>"},{"location":"actividades/A01/","title":"A01. Hola mundo","text":"<p>Esta va a ser la primera actividad y vamos a indicar brevemente el procedimiento que seguiremos en esta y sucesivas.</p> <ul> <li>Introduciremos los conceptos de programaci\u00f3n para programar en BBC micro:bit MicroPython.</li> <li>Tambi\u00e9n introduciremos conceptos de micro:bit Micropython API.</li> <li>Describiremos los bloques nuevos utilizados.</li> <li>Incluiremos esquemas si resultan necesarios.</li> <li>Describiremos cualquier aspecto que se considere relevante para entender la actividad.</li> </ul> <p>La manera habitual de comenzar a programar en un nuevo lenguaje es hacer que el ordenador o dispositivo programable nos salude con un \"\u00a1Hola, mundo!\". Pues hagamos esto en los tres sistemas elegidos: MicroPython, MakeCode y MicroBlocks. Animamos a probar otros programas de los citados en la webgraf\u00eda.</p>"},{"location":"actividades/A01/#micropython","title":"MicroPython","text":"<p>Se explican los siguientes aspectos:</p> <p> <ul> <li>API: El m\u00f3dulo microbit</li> <li>API: Display que traducimos como Mostrar o pantalla</li> </ul> <p></p>"},{"location":"actividades/A01/#api-el-modulo-microbit","title":"API: El m\u00f3dulo microbit","text":"<p>Todo lo necesario para interactuar con el hardware de la micro:bit est\u00e1 en el m\u00f3dulo microbit y se recomienda su uso escribiendo al principio del programa:</p> <p> <pre><code>from microbit import *\n</code></pre> </p> <p>Las funciones disponibles directamente son:</p> <pre><code>sleep(ms) #1\nrunning_time() #2\ntemperature() #3\nscale(valor_a_convertir, from_=(min, max), to=(min, max)) #4\npanic(error_code) #5\nreset() #6\nset_volume(valor) #7 (V2)\n'''\n1 Esperar el n\u00famero de milisegundos indicado\n2 Devuelve el tiempo en ms desde la \u00faltima vez que se encendi\u00f3 la micro:bit\n3 Devuelve la temperatura en Celcius\n4 Convierte un n\u00famero de una escala de valores a otra\n5 La micro:bit entra en modo p\u00e1nico por falta de memoria y se dibuja una\ncara triste en la pantalla. El valor de error_code puede ser cualquier entero.\n6 Resetea la micro:bit\n7 Estable el volumen de salida con un *valor* entre 0 y 255\n'''\n</code></pre>"},{"location":"actividades/A01/#api-display","title":"API: Display","text":"<p>Control de la matriz de 5x5 LEDs que en micro:bit se conoce como pantalla. Los m\u00e9todos de la clase son:</p> <pre><code>display.get_pixel(x, y) #1\ndisplay.set_pixel(x, y, val) #2\ndisplay.clear() #3\ndisplay.show(image, delay=0, wait=True, loop=False, clear=False) #4\ndisplay.scroll(string, delay=400) #5\n'''\n1 Obtiene el brillo [0 (apagado) a 9 (m\u00e1x))] del pixel (x,y)\n2 Establece el brillo [0 (apagado) a 9 (m\u00e1x))] del pixel (x,y)\n3 Borra (apaga) la pantalla\n4 Muestra la imagen\n5 Desplaza una cadena por la pantalla a la velocidad en ms del *delay*\n'''\n</code></pre> <p>En ambos casos de la API existen otras muchas opciones no incluidas. La funcionalidad de autocompletar nos ayudar\u00e1 para no tener que recordar la sintaxis y conocer las que no aparece aqu\u00ed. En la animaci\u00f3n siguiente vemos un ejemplo de ambos casos.</p> <p> <p> Autocompletar funciones y m\u00e9todos</p> <p></p>"},{"location":"actividades/A01/#programa","title":"Programa","text":"<p>El programa de la actividad lo vamos a hacer utilizando algunas de las cosas descritas y comentando las l\u00edneas para que se entienda mejor. El c\u00f3digo del programa es el siguiente:</p> <pre><code># Las importaciones van a la cabeza\nfrom microbit import * #Usar todo de la biblioteca microbit\ndisplay.clear() #Borra pantalla\ndisplay.scroll('\u00a1Hola Mundo!', delay=100) #Desplaza el texto por pantalla\nsleep(1000) #Espera 1s\ndisplay.show(Image.HAPPY) #Muestra carita alegre\nsleep(1000)\ndisplay.clear()\ndisplay.set_pixel(0,0,3) #Encendemos pixel al brillo establecido\ndisplay.set_pixel(2,2,9)\ndisplay.set_pixel(4,0,3)\n</code></pre> <p>En la animaci\u00f3n vemos el funcionamiento en el simulador y el efecto de cambiar el valor del delay y del valor del brillo de uno de los LED.</p> <p> <p> Funcionamiento del programa</p> <p></p> <p>Si observamos bien, al principio del texto aparecen unas interrogaciones en lugar de el signo de abrir admiraci\u00f3n. Esto es debido a que micro:bit no muestra caracteres especiales como \u00a1, \u00bf, \u00f1, acentos, etc.</p> <p>El programa lo podemos descargar de:</p> <ul> <li>A01-Hola_Mundo-main en hexadecimal</li> <li>A01-Hola_Mundo-main en Python</li> </ul>"},{"location":"actividades/A01/#makecode","title":"MakeCode","text":"<p>Se explican los bloques utilizados de los men\u00fas de bloques. Referencia a micro:bit reference The micro:bit APIs.</p> <p> <ul> <li>B\u00e1sico: Funcionalidades b\u00e1sicas de micro:bit</li> <li>LED: Control de la pantalla LED</li> <li>Comentarios</li> </ul> <p></p>"},{"location":"actividades/A01/#comentarios","title":"Comentarios","text":"<p>Todo lenguaje de programaci\u00f3n contempla la posibilidad de realizar comentarios en el c\u00f3digo para que sirvan de aclaraci\u00f3n de para que sirve cada bloque en el programa, en especial en alguna parte que transcurrido un tiempo nos resulte complicada de entender.</p> <p>En MakeCode la forma de hacer comentarios es siempre sobre un bloque, as\u00ed que si Si necesitamos a\u00f1adir un comentario a un bloque desplegamos las opciones del bloque pinchando con el bot\u00f3n derecho y a\u00f1adimos un comentario pinchando en la entrada 'a\u00f1adir comentario'. Esto har\u00e1 que aparezca, en la esquina superior izquierda del bloque, un peque\u00f1o icono con forma de hoja escrita. Si pulsamos sobre este icono se despliega un peque\u00f1o editor, dimensionable y movible, donde podemos escribir nuestro comentario. En este editor hay un s\u00edmbolo de papelera que elimina el comentario actual. Esta opci\u00f3n est\u00e1 disponible tambi\u00e9n en el men\u00fa contextual, l\u00f3gicamente si se ha creado un comentario. En la animaci\u00f3n siguiente vemos el funcionamiento.</p> <p> <p> Comentarios</p> <p></p>"},{"location":"actividades/A01/#basico","title":"B\u00e1sico","text":"<p>En este grupo tenemos acceso a la funcionalidad b\u00e1sica de la micro:bit.</p> <ul> <li>al iniciar. Se trata del bloque de la imagen y es un bloque que se ejecuta una sola vez cuando se inicia la micro:bit. Es uno de los dos bloques que aparecen al principio cuando escogemos Restablecer o creamos un nuevo proyecto desde Mis proyectos.</li> </ul> <p> <p> Bloque 'al iniciar'</p> <p></p> <ul> <li>para siempre. Se trata del bloque de la imagen y es un bloque que se ejecuta de manera infinita. Es el otro de los dos bloques que aparecen al principio cuando escogemos Restablecer o creamos un nuevo proyecto desde Mis proyectos.</li> </ul> <p> <p> Bloque 'para siempre'</p> <p></p> <ul> <li>mostrar cadena. Muestra la cadena de texto en la pantalla caracter a caracter. En la imagen la palabra es Hello.</li> </ul> <p> <p> Bloque 'mostrar cadena'</p> <p></p> <ul> <li>mostrar icono. Dibuja el icono seleccionado en la pantalla.</li> </ul> <p> <p> Bloque 'mostrar icono'</p> <p></p> <ul> <li>borrar la pantalla. Apaga todos los LEDs.</li> </ul> <p> <p> Bloque 'borrar la pantalla'</p> <p></p> <ul> <li>pausa (ms). Detiene la ejecuci\u00f3n del programa el tiempo establecido en milisegundos.</li> </ul> <p> <p> Bloque 'pausa (ms)'</p> <p></p>"},{"location":"actividades/A01/#led","title":"LED","text":"<p>Control de la pantalla LED.</p> <ul> <li>ajustar brillo. Configura el brillo de la pantalla desde 0 (apagada) a 255 (m\u00e1ximo brillo). Los bloques de pantalla posteriores a este tendr\u00e1n el brillo establecido hasta que no se cambien el valor a otro distinto.</li> </ul> <p> <p> Bloque 'ajustar brillo'</p> <p></p> <ul> <li>graficar x,y,brillo. Enciende el LED indicado en la coordenada x,y con el brillo especificado. La coordenadas x es la horizontal y la y es la vertical. La coordenada 0,0 es la esquina superior ezquierda, la 0,4 es la derecha, la 4,0 es la inferior izquierda y la 4,4 la inferior derecha.</li> </ul> <p> <p> Bloque 'graficar x,y,brillo'</p> <p></p>"},{"location":"actividades/A01/#programa_1","title":"Programa","text":"<p>El programa de la actividad lo vamos a hacer utilizando los bloques descritos y comentando algunas de las l\u00edneas para que se entienda mejor. El programa es el siguiente:</p> <p> <p> Programa de la actividad A01 en MakeCode</p> <p></p> <p>En la animaci\u00f3n vemos el funcionamiento en el simulador.</p> <p> <p> Funcionamiento del programa</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>microbit-A01-Hola_Mundo</li> </ul>"},{"location":"actividades/A01/#microblocks","title":"MicroBlocks","text":"<p>Se explican los bloques utilizados de los men\u00fas de bloques por defecto y de la libreria a\u00f1adida. Referencia a Blocks Reference.</p> <p> <ul> <li>Control</li> <li>Pantalla LED</li> <li>Comentarios</li> </ul> <p></p>"},{"location":"actividades/A01/#comentarios_1","title":"Comentarios","text":"<p>En MicroBlocks los comentarios son tratados desde un \u00fanico bloque que podemos encontrar en el men\u00fa 'Control'. Es un bloque no hace nada. Se utiliza para a\u00f1adir notas y documentaci\u00f3n a los scripts.</p> <p> <p> Comentarios</p> <p></p> <p>La ventana de entrada de texto se autodimensiona seg\u00fan introducimos texto y se pueden a\u00f1adir l\u00edneas pulsando la tecla enter.</p>"},{"location":"actividades/A01/#control","title":"Control","text":"<p>En este grupo tenemos acceso a los bloques de control de la micro:bit.</p> <ul> <li>al empezar. Los bloques debajo de este se ejecutan cuando se enciende la placa o cuando se hace clic en el icono verde EJECUTAR que tiene forma de flecha.</li> </ul> <p> <p> Bloque 'al empezar'</p> <p></p> <ul> <li>por siempre. Se trata del bloque de la imagen y es un bloque que se ejecuta de manera indefinida.</li> </ul> <p> <p> Bloque 'por siempre'</p> <p></p> <ul> <li>espera xx milisegundos. Espera el n\u00famero de milisegundos indicado antes de continuar.</li> </ul> <p> <p> Bloque 'espera xx milisegundos'</p> <p></p>"},{"location":"actividades/A01/#pantalla-led","title":"Pantalla LED","text":"<p>Libreria con los bloques de control de la pantalla LED.</p> <ul> <li>limpia pantalla. Apaga todos los LEDs.</li> </ul> <p> <p> Bloque 'limpia pantalla'</p> <p></p> <ul> <li>pantalla. Muestra una imagen de la pantalla que permite cambiar el estado de cada LED haciendo clic sobre el mismo.</li> </ul> <p> <p> Bloque 'pantalla'</p> <p></p> <ul> <li>anima el texto. Muestra el texto introducido mediante desplazamiento caracter a caracter con el retardo en milisegundos que establezcamos.</li> </ul> <p> <p> Bloque 'anima el texto'</p> <p></p> <ul> <li>enciende x,y. Enciende el LED indicado en la coordenada x,y. La coordenadas x es la horizontal y la y es la vertical. La coordenada 1,1 es la esquina superior ezquierda, la 1,5 es la derecha, la 5,1 es la inferior izquierda y la 5,5 la inferior derecha.</li> </ul> <p> <p> Bloque 'enciende x,y'</p> <p></p>"},{"location":"actividades/A01/#programa_2","title":"Programa","text":"<p>El programa de la actividad lo vamos a hacer utilizando los bloques descritos. El programa es el siguiente:</p> <p> <p> Programa de la actividad A01 en MicroBlocks</p> <p></p> <p>En el caso de MicroBlocks no disponemos de simulador pero los botones Iniciar/parar nos permiten estar viendo en la placa real todo lo que ocurre mientra elaboramos nuestro programa.</p> <p>El programa lo podemos descargar de:</p> <ul> <li>A01-Hola_Mundo.ubp</li> </ul>"},{"location":"actividades/A02/","title":"A02. Im\u00e1genes","text":"<p>Vamos a entrar en las posibilidades art\u00edsticas que nos puede ofrecer una matriz cuadrada de 5x5 LEDs.</p>"},{"location":"actividades/A02/#micropython","title":"MicroPython","text":"<p>Se explican los siguientes aspectos:</p> <p> <ul> <li>Las listas en Python</li> <li>Im\u00e1genes DIY</li> <li>Animar im\u00e1genes</li> <li>Bucles</li> </ul> <p></p> <p>MicroPython nos ofrece muchas im\u00e1genes integradas para mostrar por pantalla y podemos crear efectos interesantes. Mediante la caracter\u00edstica de autocompletar se nos van a mostrar todas las definidas que est\u00e1n listadas en la documentaci\u00f3n oficial. Ya hemos visto como cargar una imagen, lo que puedo aconsejar en este momento es realizar el ejercicio de mostrar cada una de las disponibles para familiarizarnos con ellas.</p> <p>Es perfectamente posible crar nuestras propias im\u00e1genes configurando cada Pixel o LED de la pantalla. Tambi\u00e9n es posible crear animaciones con im\u00e1genes.</p>"},{"location":"actividades/A02/#las-listas-en-python","title":"Las listas en Python","text":"<p>Se trata de un tipo de dato que permite almacenar series de datos de cualquier tipo bajo su estructura. Se suelen asociar a las matrices o arrays de otros lenguajes de programaci\u00f3n.</p> <p>En Python las listas son muy versatiles permitiendo almacenar un conjunto arbitrario de datos. Es decir, podemos guardar en ellas lo que sea.</p> <p>Una lista se crea con [] y sus elementos se separan por comas. Una gran ventaja es que pueden tener datos de diferentes tipos.</p> <pre><code>lista = [1, \"Hola\", 3.141592, [1 , 2, 3], Image.HAPPY]\n</code></pre> <p>Las de principales propiedades de las listas:</p> <ul> <li>Son ordenadas, mantienen el orden en el que han sido definidas</li> <li>Pueden ser formadas por tipos arbitrarios de datos</li> <li>Pueden ser indexadas con [i]</li> <li>Se pueden anidar, es decir, meter una lista dentro de otra</li> <li>Son mutables, ya que sus elementos pueden ser modificados</li> <li>Son din\u00e1micas, ya que se pueden a\u00f1adir o eliminar elementos</li> </ul> <p>Evidentemente queda muchas cosas que aprender sobre las listas, pero con estos conocimientos tendremos suficiente para hacer lo que pretendemos, que no es otra cosa que animar im\u00e1genes.</p>"},{"location":"actividades/A02/#bucles","title":"Bucles","text":"<p>Los Bucles son un tipo de estructura de control muy \u00fatil cuando queremos repetir un bloque de c\u00f3digo varias veces. En Python existen dos tipos de bloques, el bucle for para contar la cantidad de veces que se ejecuta un bloque de c\u00f3digo, y el bucle while que realiza la acci\u00f3n hasta que la condici\u00f3n especificada no sea cierta.</p>"},{"location":"actividades/A02/#while","title":"While","text":"<p>La sintaxis de while es la siguiente:</p> <pre><code>while condicion:\n    bloque de codigo\n</code></pre> <p>donde \"condicion\", que se eval\u00faa en cada iteraci\u00f3n, puede ser cualquier expresi\u00f3n realizado con operadores condicionales que devuelva como resultado un valor True o False. Mientra que \"bloque de codigo\" es el conjunto de instrucciones que se estar\u00e1n ejecutando mientras la condici\u00f3n sea verdadera (True o '1'). Es lo mismo poner <code>while true:</code> que poner <code>while 1:</code>.</p> <p>Para recorrer los bucles se utilizan variables que forman parte de la condici\u00f3n, estableciendose en esta lo que deben cumplir.</p> <p>Un ejemplo sencillo podr\u00eda ser el siguiente, controlar el riego de una planta en funci\u00f3n del valor de la humedad de la tierra en la que est\u00e1.</p> <pre><code>from microbit import *\n\nwhile (humedad() &lt; 45):\n    display.scroll(Image.SAD)\n    sleep(1000)\n\ndisplay.show(Image.HAPPY)\n</code></pre> <p>que har\u00e1 que si la humedad baja por debajo de 45 se muestre una carita triste indicando que hay que regar y si es mayor mostrar\u00e1 una carita feliz. Evidentemente hay que resolver el tema de como obtener la humedad, pero esa es una historia que veremos mas adelante.</p> <p>El bucle <code>while</code> puede tener de manera opcional un bloque <code>else</code> cuyas sentencias se ejecutan cuando se han realizado todas las iteraciones del bucle. Un ejemplo lo vemos a continuaci\u00f3n:</p> <pre><code>cuenta = 0\nwhile cuenta &lt; 5:\n    print(\"Iteraci\u00f3n del bucle\")\n    cuenta = cuenta + 1\nelse:\n    print(\"bucle finalizado\")\n</code></pre>"},{"location":"actividades/A02/#for","title":"for","text":"<p>Son tambi\u00e9n bucles pero su acci\u00f3n est\u00e1 dirigida a contar el n\u00famero de veces que ocurre algo o realizar una acci\u00f3n un determinado n\u00famero de veces. Es especialmente \u00fatil para recorrer los datos de una lista, tupla o diccionario.</p> <p>La sintaxis de este tipo de bucles en Python es:</p> <pre><code>for variable in secuencia:\n    declaracion\n</code></pre> <p>Siendo \"variable\" la variable que se va a recorrer en el bucle de forma que cuando se alcance el valor establecido se sale del bucle.</p> <p>La variable puede ser una cadena, un rango de valores que se expresa con <code>range(n)</code>, siendo n el n\u00famero de valores del rango que se inicia en 0 y que pueden ser iterados con una variable. Mas ampliamente, la sintaxis de <code>range()</code> es <code>range(start, stop, step)</code> siendo <code>start</code> y <code>stop</code> opcionales.</p> <p>Veamos un primer ejemplo en el que vamos a utilizar un bucle para encender uno a uno por filas los LEDs de la primera y \u00faltima columna.</p> <pre><code>from microbit import *\nfor var in range(5): # var puede tomar 5 valores, del 0 al 4\n    display.set_pixel(0, var, 9) # Se ilumina el LED de la fila 0 y el valor de var para columna\n    sleep(300)\n    display.set_pixel(4, var, 9) # Se ilumina el LED de la fila 4 y el valor de var para columna\n    sleep(300)\n</code></pre> <p>Los bucles se pueden anidar, es decir se puede crear un bucle dentro de otro del mismo o diferente tipo, de forma que por cada iteraci\u00f3n del bucle mas externo se tienen que producir todas las iteraciones del bucle mas interno. Veamos como ejemplo el de encender todos los LEDs de uno en uno, de izquierda a derecha, utilizando el valor de sus coordenadas x,y. El programa ser\u00eda:</p> <pre><code>from microbit import *\n\ndisplay.clear()\nfor y in range(0, 5): # Valor de columna\n    for x in range(0, 5): # Valor de fila\n        display.set_pixel(x, y, 9) # Encender LED x,y\n        sleep(100)\n</code></pre> <p>En la animaci\u00f3n siguiente vemos el programa en funcionamiento.</p> <p> <p> Uso de bucle for</p> <p></p> <p>El bucle <code>for</code> puede tener de manera opcional un bloque <code>else</code> cuyas sentencias se ejecutan cuando se han realizado todas las iteraciones del bucle. Un ejemplo lo vemos a continuaci\u00f3n:</p> <pre><code>for var in range(5):\n    print(var)\nelse:\n    print(\"bucle finalizado\")\n</code></pre>"},{"location":"actividades/A02/#sentencias-break-y-continue","title":"Sentencias <code>break</code> y <code>continue</code>","text":"<p>La sentencia <code>break</code> se utiliza para terminar un bucle de forma inmediata al ser encontrada. En la imagen vemos la sintaxis de la sentencia <code>break</code> y su funcionamiento.</p> <p> <p> Sintaxis y funcionamiento de <code>break</code></p> <p></p> <p>La sentencia <code>continue</code> se utiliza para saltar la iteraci\u00f3n actual del bucle y el flujo de control del programa pasa a la siguiente iteraci\u00f3n. En la imagen vemos la sintaxis de la sentencia <code>continue</code> y su funcionamiento.</p> <p> <p> Sintaxis y funcionamiento de <code>continue</code></p> <p></p> <p>En la figura siguiente vemos dos ejemplos de esta sentencia.</p> <p> <p> Funcionamiento de <code>continue</code></p> <p></p>"},{"location":"actividades/A02/#imagenes-diy","title":"Im\u00e1genes DIY","text":"<p>Crear nuestras propias im\u00e1genes va a resultar una tarea sencilla cuando conozcamos la informaci\u00f3n para hacerlo. Cada pixel (LED) de la pantalla se puede configurar con diez valores que pueden tomar un valor entre 0 (cero) y 9 (nueve). Cuando le damos valor 0 (cero) es decirle literalmente que el brillo es nulo y sin embargo cuando le damos el valor 9 (nueve) lo ponemos al m\u00e1ximo de brillo posible. Podemos jugar con todos los valores intermedios para crear niveles de brillo.</p> <p>La forma mas sencilla de definir una imagen consiste en utilizar la clase microbit.Image para crearla a partir de una cadena o string que devuelva el pictograma. Es decir utilizando el comando Image(string) teniendo que constar de d\u00edgitos con los valores 0 a 9 indicados. Para verlo rapidamente hacemos el ejemplos de dibujar una X en relieve asign\u00e1ndola a una variable.</p> <pre><code>mi_imagen_X = Image(\"90009:\"\n                    \"06060:\"\n                    \"00300:\"\n                    \"06060:\"\n                    \"90009\")\n</code></pre> <p>Los dos puntos indican un salto de l\u00ednea por lo que se puede usar el ASCII no imprimible \"\\n\" que es precisamente eso, un salto de l\u00ednea.</p> <pre><code>mi_imagen_X = Image(\"90009\\n\"\n                    \"06060\\n\"\n                    \"00300\\n\"\n                    \"06060\\n\"\n                    \"90009\")\n</code></pre> <p>Los valores de brillo dan la sensaci\u00f3n de relieve de profundidas a la X.</p> <p>En cualquier caso esto no se escribe normalmente as\u00ed, salvo para hacer mas o menos un gr\u00e1fico del pixelado, sino en una sola l\u00ednea.</p> <pre><code>mi_imagen_X = Image(\"90009\\n06060\\n00300\\n06060\\n90009\")\n</code></pre> <p>Ahora parece mas elegante utilizar los dos puntos como indicador de salto de l\u00ednea.</p> <pre><code>mi_imagen_X = Image(\"90009:06060:00300:06060:90009\")\n</code></pre> <p>En la imagen vemos el resultado de lo explicado.</p> <p> <p> mi imagen de una X en relieve</p> <p></p> <p>Este es el c\u00f3digo creado:</p> <pre><code>from microbit import * \n\"\"\"mi_imagen_X = Image(\"90009\\n\"\n                       \"06060\\n\"\n                       \"00300\\n\"\n                       \"06060\\n\"\n                       \"90009\")\"\"\"\n#mi_imagen_X = Image(\"90009\\n06060\\n00300\\n06060\\n90009\")\nmi_imagen_X = Image(\"90009:06060:00300:06060:90009\")\ndisplay.show(mi_imagen_X)\n</code></pre>"},{"location":"actividades/A02/#animar-imagenes","title":"Animar im\u00e1genes","text":"<p>En micro:bit Python ya disponemos de un par de listas de im\u00e1genes incorporadas que se llaman</p> <pre><code>Image.ALL_Clocks\nImage.ALL_ARROWS\n</code></pre> <p>Estas dos ordenes hacen que MicroPython entienda que necesita mostrar cada imagen de la lista, una tras otra.</p> <p>Cuando queremos mostrar en la pantalla una imagen se nos muestra la siguiente ayuda contextual:</p> <p> <p> Ayuda contextual para display.show()</p> <p></p> <p>donde nos indica claramente qie image puede ser una cadena, un n\u00famero, una imagen o una lista de im\u00e1genes. Adem\u00e1s aparecen las opciones que podemos configurar.</p> <p>Con esta informaci\u00f3n crear un \"reloj\" que est\u00e9 continuamente marcando cada hora es bastante sencillo, basta con poner el siguiente c\u00f3digo y darle a simular.</p> <pre><code># Imports go at the top\nfrom microbit import *\ndisplay.show(Image.ALL_CLOCKS, delay=400, loop=True)\n</code></pre> <p>En la animaci\u00f3n vemos el funcionamiento de este \"reloj\".</p> <p> <p> \"Reloj\" creado con display.show() y mostrar una lista</p> <p></p> <p>Si cambiamos el reloj por las flechas veremos como van rotando flechas en \u00e1ngulos de 45 grados.</p> <p> <p> Flechas creado con display.show() y mostrar una lista</p> <p></p> <p>Para animar nuestras propias im\u00e1genes tendremos que crear cada una sobre un lienzo de 5x5 pixeles y establecer las diferencias para crear la animaci\u00f3n. Podemos crear tantas im\u00e1genes como creamos oportuno. Creamos una lista con todas las im\u00e1genes en el orden que se tienen que reproducir y ya podemos mostrar nuestra lista en la pantalla.</p> <p>En la animaci\u00f3n siguiente vemos un efecto creado de esta forma.</p> <p> <p> Cortinilla animada</p> <p></p> <p>Este es el c\u00f3digo para crear la animaci\u00f3n.</p> <pre><code># Imports go at the top\nfrom microbit import *\ndisplay.clear()\ncor1=Image(\"90000:90000:90000:90000:90000\")\ncor2=Image(\"79000:79000:79000:79000:79000\")\ncor3=Image(\"57900:57900:57900:57900:57900\")\ncor4=Image(\"35790:35790:35790:35790:35790\")\ncor5=Image(\"13579:13579:13579:13579:13579\")\ncor6=Image(\"01357:01357:01357:01357:01357\")\ncor7=Image(\"00135:00135:00135:00135:00135\")\ncor8=Image(\"00013:00013:00013:00013:00013\")\ncor9=Image(\"00001:00001:00001:00001:00001\")\ncor10=Image(\"00000:00000:00000:00000:00000\")\ntodas_las_cortinas=[cor1,cor2,cor3,cor4,cor5,cor6,cor7,cor8,cor9,cor10]\ndisplay.show(todas_las_cortinas, delay=100, loop=True)\n</code></pre>"},{"location":"actividades/A02/#programa","title":"Programa","text":"<p>Cualquiera de los ejemplos vistos nos puede valer como programa de ejemplo para el apartado Im\u00e1genes, pero por su facilidad vamos a hacer el ejemplo del coraz\u00f3n que late. Resulta muy f\u00e1cil de resolver pues ya est\u00e1n predise\u00f1adas las im\u00e1genes de un coraz\u00f3n grande y peque\u00f1o.</p> <pre><code>from microbit import *\ndisplay.clear()\nwhile True:\n    display.show(Image.HEART_SMALL)\n    sleep(300)\n    display.show(Image.HEART)\n    sleep(300)\n</code></pre> <p>En la animaci\u00f3n vemos su funcionamiento.</p> <p> <p> Coraz\u00f3n latiendo</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>A02-Corazon_latiendo en hexadecimal</li> <li>A02-Corazon_latiendo en Python</li> </ul>"},{"location":"actividades/A02/#makecode","title":"MakeCode","text":"<p>Aunque todos los bloques que se requieren para resolver el problema del coraz\u00f3n latiendo ya se han explicado y no se requiere nada nuevo vamos a explicar como son los bloques para bucles y para im\u00e1genes en MakeCode.</p> <p>Se explican los siguientes aspectos:</p> <p> <ul> <li>Arrays o arreglos</li> <li>Variables</li> <li>Bucles</li> <li>Im\u00e1genes</li> </ul> <p></p>"},{"location":"actividades/A02/#arrays-o-arreglos","title":"Arrays o arreglos","text":"<p>Se van a utilizar para agregar, eliminar y sustituir elementos en listas. En MakeCode las listas se nombran indistintamente como array, matriz o lista y tienen su propio men\u00fa de bloques que es visible cuando desplegamos 'Avanzado'. Los bloques existentes est\u00e1n clasificados en los siguientes grupos:</p> <ol> <li>Create</li> <li>Leer</li> <li>Modificar</li> <li>Operaciones</li> </ol> <p>Describiremos estos grupos de forma somera porque esta es suficiente para entender lo que hace el bloque. No obstante, algunos se describen de manera mas explicita.</p>"},{"location":"actividades/A02/#create","title":"Create","text":"<ul> <li>fijar 'nn' a. Le da a la variable el valor de la entrada, para valores num\u00e9ricos.</li> <li>fijar 'tt' a. Le da a la variable el valor de la entrada, para texto.</li> <li>matriz vacia. Crea una lista con los elementos que introduzcamos con el '+'.</li> </ul>"},{"location":"actividades/A02/#leer","title":"Leer","text":"<ul> <li>longitud del arreglo. Devuelve el n\u00famero de elementos de una lista.</li> <li>obtener el valor en 'x'. Obtiene el valor del elemento 'x'.</li> <li>eliminar el valor en 'x'. Elimina el elemento 'x' de la lista.</li> <li>obtener y eliminar el \u00faltimo valor de (<code>pop</code>). Elimina y devuelve el \u00faltimo elemento de una matriz. Se elimina el \u00faltimo elemento de la matriz, por lo que la matriz se reduce en un elemento.</li> <li>obtener y eliminar el primer valor de (<code>shift</code>). Elimina y devuelve el primer elemento de una matriz. Se elimina el primer elemento de la matriz, por lo que la matriz se reduce en un elemento.</li> <li>obtener valor aleatorio. Devuelve un valor al azar de la matriz.</li> </ul>"},{"location":"actividades/A02/#modificar","title":"Modificar","text":"<ul> <li>establecer el valor en 'x' a 'nn'. Estable el valor del elemento 'x' al valor indicado en 'nn'.</li> <li>a\u00f1adir valor 'nn' al final (<code>push</code>). A\u00f1ade un nuevo elemento al final de una matriz.</li> <li>eliminar el \u00faltimo valor de. Elimina el \u00faltimo elemento de la matriz y lo devuelve.</li> <li>eliminar el primer valor de. Elimina el primer elemento de la matriz y lo devuelve.</li> <li>insertar 'nn' al principio (<code>unshift</code>). A\u00f1adir un elemento al principio de una matriz y devolver la nueva longitud de la matriz.</li> <li>insertar en 'x' valor 'nn' (<code>insertAt</code>). Inserta el valor 'nn' en la posici\u00f3n espe\u00edfica indicada por 'x' aumentando la longitud del array en uno. El elemento se agrega a la matriz en la posici\u00f3n que indiquemos. Si ya hay un elemento en esa posici\u00f3n, entonces \u00e9l y todos los elementos posteriores se desplazan a la posici\u00f3n superior siguiente.</li> <li>eliminar valor en 'x' (<code>removeAt</code>). Elimina el elemento que hay en la posici\u00f3n 'x'. El tama\u00f1o de la matriz se reduce en uno. El elemento se elimina de la matriz en la posici\u00f3n que indiquemos. Todos los dem\u00e1s elementos posteriores se desplazan hacia abajo a la posici\u00f3n inferior siguiente.</li> </ul>"},{"location":"actividades/A02/#operaciones","title":"Operaciones","text":"<ul> <li>bloque encontrar indice de (<code>IndexOf</code>). Devuelve la posici\u00f3n o \u00edndice de la primera aparici\u00f3n de un valor en una matriz. Devuelve un n\u00famero, que es la posici\u00f3n en la matriz del elemento. El resultado es -1 si no se encuentra ninguna coincidencia.</li> <li>invertir (<code>reverse</code>). Invertir los elementos de una matriz.</li> </ul>"},{"location":"actividades/A02/#variables","title":"Variables","text":"<p>Cuando vamos a utilizar bucles, estos siempre llevan asociada una variable, y por eso debemos aprender a gestionar el tema de las variables en MakeCode. Las variables tienen su propio men\u00fa y es relativamente sencillo de usar. Como ya se ha dicho, una variable es un espacio en la memoria donde el programa puede almacenar valores. El sistema nos permite asignarles un nombre simb\u00f3lico como por ejemplo \u201ctemperatura\u201d, \u201cvelocidad\u201d, \u201destado\u201d,\u2026 para facilitar su uso.</p> <p>Cuando accedemos al men\u00fa 'Variables' por primera vez y si no hemos pues ning\u00fan bloque en el \u00e1rea de programa, el aspecto del men\u00fa es el siguiente:</p> <p> <p> Variables en MakeCode</p> <p></p> <p>Veamos como funciona la creaci\u00f3n de una variable, cambiarle el nombre, eliminarla y dem\u00e1s tareas que podemos hacer con ellas. En la animaci\u00f3n siguiente vemos el proceso de crear y poner nombre a una variable. Vemos que al hacer clic en el bot\u00f3n se abre una ventana de di\u00e1logo donde nos pide el nombre, que tecleamos seg\u00fan las reglas establecidas, y que al hacer clic en 'Aceptar' se nos crean tres bloques, dos para trabajar con la variable creada y uno que es la propia variable, todos ellos con el nombre que hemos puesto a esa variable.</p> <p> <p> Creaci\u00f3n de una variable en MakeCode</p> <p></p> <p>El bloque 'fijar' sirve para inicializar la variable al valor especificado, el bloque 'cambiar' es el equivalente al operador '+=' con el incremento que establezcamos en 'por' y el \u00faltimo bloque es el valor de la variable.</p> <p>Al final de la animaci\u00f3n tambi\u00e9n vemos que al hacer clic en la flechita de cualquiera de los bloques se despliega un men\u00fa en el que aparece la variable, la opci\u00f3n de crear otra nueva, renombrarla o borrar la variable que est\u00e1 seleccionada en ese momento. En la animaci\u00f3n siguiente vemos estos aspectos en funcionamiento.</p> <p> <p> Trabajo con el men\u00fa desplegable en una variable en MakeCode</p> <p></p> <p>Cuando pasamos por el men\u00fa de bloques vemos que 'fijar' y 'cambiar' no se vuelven a crear cuando creamos nuevas variables ya que est\u00e1n todas en el desplegable y lo \u00fanico que tenemos que hacer es seleccionarlas. Si se crea, en cambio, un bloque para el contenido de cada variable. Tambi\u00e9n vemos que si eliminamos una variable que est\u00e1 en uso en varios sitios se elimina, preva advertencia, de todos ellos.</p> <p>Ahora bien, la variables como tal se eliminan de la zona de programa pero no del men\u00fa 'Variables, donde siguen estando disponibles hasta que las eliminemos, tarea que solamente es posible hacer desde alguno de los bloques situado en la zona de programa.</p>"},{"location":"actividades/A02/#bucles_1","title":"Bucles","text":""},{"location":"actividades/A02/#bloque-for","title":"Bloque for","text":"<p>Son bloques que repiten el c\u00f3digo asociado un n\u00famero determinado de veces, Lo pueden hacer utilizando una variable como \u00edndice o estableciendo el n\u00famero exacto de veces.</p> <p>El aspecto del bloque para recorrer con una variable lo vemos en la imagen siguiente:</p> <p> <p> Bloque for en MakeCode</p> <p></p> <p>Cuando llevamos el bloque a la zona de programa se crear\u00e1 una variable index, salvo que esta ya exista. Un bloque como el siguiente crear\u00e1 un contador con la variable i desde 0 hasta 4 y mostrar\u00e1 los n\u00fameros 0 al 9 uno tras otro en la pantalla LED.</p> <p> <p> Contador de 0 a 9</p> <p></p> <p>Una variedad de este bloque la tenemos en el bloque 'repetir' para el n\u00famero de veces que indiquemos, que tiene el aspecto que vemos en la figura siguiente.</p> <p> <p> Bloque repetir nn veces</p> <p></p> <p>En el ejemplo siguiente, cuando se inicia el dispositivo, se producen tres efectos de latido de un coraz\u00f3n.</p> <p> <p> Ejemplo de uso del bloque repetir nn veces</p> <p></p> <p>Otro bloque que utiliza el bucle for es el que vemos en la imagen siguiente, un bloque pensado para repetir el c\u00f3digo para cada valor de los contenidos en una lista.</p> <p> <p> Bucle for para elementos de una lista</p> <p></p> <p>En la imagen siguiente vemos un programa que utiliza este bloque. Hemos creado una lista aleatoria de valores y el programa lo que hace es encontrar y mostrar el mayor de ellos. El funcionamiento del programa lo leemos asi: se crea una variable <code>mayor</code> para guardar el valor del elemento de la lista de mayor valor, la matriz le hemos dejado el nombre <code>lista</code> y para recorrerla se utiliza la variable <code>valor</code>. El condicional (los veremos en una actividad posterior) va comprobando si <code>valor &gt; mayor</code> y mientras sea cierto se guarda en <code>mayor</code> el <code>valor</code> leido y si no es cierto se contin\u00faa con el siguiente elemento de la lista. Una vez finalizado el condicional se mestra la cadena con la variable <code>mayor</code>.</p> <p> <p> Ejemplo de bucle for para elementos de una lista</p> <p></p>"},{"location":"actividades/A02/#bloque-while","title":"Bloque while","text":"<p>Se trata de un bloque que repite su bloque de c\u00f3digo mientras la condici\u00f3n sea cierta (<code>True</code>). Su aspecto lo vemos en la imagen siguiente.</p> <p> <p> Bucle while</p> <p></p> <p>El bucle while tiene una condici\u00f3n que se eval\u00faa con un valor <code>booleano</code>. La condici\u00f3n se comprueba antes de que se ejecute ning\u00fan c\u00f3digo. Lo que significa que si la condici\u00f3n es falsa la primera vez que se eval\u00faa, el c\u00f3digo dentro del bucle no se ejecuta n\u00fanca.</p> <p>Con el bloque tal cual es solamente podemos establecer la condici\u00f3n como <code>True</code> o <code>False</code>, lo que es muy poca cosa. Es evidente que podr\u00e1 tener mucha mas potencia si recurrimos a condiciones mas complejas y utilizamos los operadores. Este apartado no lo vamos a estudiar en este momento, pero si diremos que estos bloques est\u00e1n en el men\u00fa 'L\u00f3gica' y su funcionamiento es el mismo que en visto en Python -&gt; Introducci\u00f3n.</p> <p>Como ejemplo vamos a ver como dibujar una l\u00ednea diagonal en los LEDs [(0,0) - (1,1) - (2,2) - (3,3) - (4,4) y (5,5)] de la pantalla. En la imagen vemos el programa final, donde observamos que la condici\u00f3n va a ser cierta hasta que index alcance el valor 4, por lo que se va a ir encendiendo cada LED a intervalos de un segundo. Esto solamente va a ocurrir cuando se inicia el disposiivo, aunque en este ejemplo concreto esto no tiene importancia.</p> <p> <p> Programa bucle while</p> <p></p>"},{"location":"actividades/A02/#bloque-cada-nn-ms","title":"Bloque cada 'nn' ms","text":"<p>Repite el c\u00f3digo en segundo plano de forma contnuada en el intervalo de tiempo que se indique. Establecemos la cantidad de tiempo que el bucle espera antes de que el c\u00f3digo en su interior se ejecute de nuevo. Esto es similar a un bucle \"forever\" (por siempre), en el sentido de que se ejecuta continuamente, excepto que hay un intervalo de tiempo establecido para esperar antes de que el bucle se ejecute la pr\u00f3xima vez. El bloque es muy \u00fatil si, por ejemplo, queremos estar comprobando cada cierto tiempo si ocurre un evento, como pulsar una tecla, escuchar un sonido, etc.</p> <p>En la imagen siguiente vemos el aspecto que tiene el bloque.</p> <p> <p> Bloque cada 'nn' ms</p> <p></p>"},{"location":"actividades/A02/#bloques-salir-y-continuar","title":"Bloques salir y continuar","text":"<p>Son los bloques equivalentes a las sentencias <code>break</code> y <code>continue</code> en MicroPython y funcionan exactamente igual, es decir, el bloque 'salir' permite salir de un bucle de forma inmediata y el bloque 'continuar' sirve para saltarse la iteraci\u00f3n actual del bucle.</p> <p>Los bloques tienen el aspecto que vemos en la imagen.</p> <p> <p> <code>break</code> y <code>continue</code></p> <p></p>"},{"location":"actividades/A02/#programa_1","title":"Programa","text":"<p>El programa de corazon latiendo es el siguiente:</p> <p> <p> Programa de la actividad A02 en MakeCode</p> <p></p> <p>En la animaci\u00f3n vemos el funcionamiento en el simulador.</p> <p> <p> Funcionamiento del programa</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>A02-Coraz\u00f3n_latiendo</li> </ul>"},{"location":"actividades/A02/#microblocks","title":"MicroBlocks","text":"<p>Por tema de hacer homog\u00e9nea esta actividad se explican los siguientes aspectos:</p> <p> <ul> <li>Operadores</li> <li>Variables</li> <li>Bucles</li> <li>Listas</li> </ul> <p></p>"},{"location":"actividades/A02/#operadores","title":"Operadores","text":"<p>Esta entrada se crea porque en MicroBlocks, en el men\u00fa espec\u00edfico, aparecen algunos operadores especiales. Las descripciones siguiente son las obtenidas de MicroBlocks Wiki.</p> <p>Dentro del grupo de bloques est\u00e1ndar tenemos los que se ven en la imagen.</p> <p> <p> Bloques est\u00e1ndar</p> <p></p> <ul> <li>  Devuelve el resto de la divisi\u00f3n entre los dos n\u00fameros introducidos, ambos inclusive.</li> <li> Devuelve un n\u00famero aleatorio (al azar) entre el primer y el segundo valor indicado.</li> </ul> <p>En la imagen vemos un ejemplo donde se averigua si un n\u00famero generado al azar es par o impar.</p> <p>A la variable <code>num_aleatorio</code> se le asigna un n\u00famero aleatorio del 1 al 15. La operaci\u00f3n <code>m\u00f3dulo</code> se utiliza para comprobar si el resto es 0 y as\u00ed saber si el n\u00famero es par. Si el resto de la operaci\u00f3n <code>num_aleatorio</code> dividido por 2 da como resultado 0, el n\u00famero es par, en caso contrario es impar.</p> <p> <p> Par o impar</p> <p></p> <p>Con este ejemplo comprobamos que una vez conectada la micro:bit (si no el programa nos indica que no lo est\u00e1 y no funcionar\u00e1), el bloque <code>di</code> muestra como retorno un mensaje que aparece asociado al bloque <code>al empezar</code> en la pantalla del ordenador. Esta es la forma de trabajar de MicroBlocks y hace que el c\u00f3digo se compruebe de manera instant\u00e1nea siempre que los bloques est\u00e9n acoplados a <code>al empezar</code>.</p> <p>Descargar el programa</p> <ul> <li>  Devuelve <code>True</code> si la expesi\u00f3n de entrada del lado izquierdo coincide con la selecci\u00f3n del men\u00fa de tipos de datos realizada en el lado derecho. Los tipos de datos son importantes a la hora de programar. Aunque un entorno como MicroBlocks facilita las cosas a los usuarios principiantes al encargarse de las conversiones de tipos de datos, todav\u00eda es posible enga\u00f1arse visualmente al comparar variables cuyos valores parecen iguales. Este bloque pertenece al grupo de condicionales, pero se describe ahora porque se utiliza en el ejemplo siguiente.</li> </ul> <p> <p> N\u00famero o cadena</p> <p></p> <p>Descargar el programa</p> <p>Desplegando la secci\u00f3n 'Avanzados' vemos algunos bloques que representan operaciones bit a bit. Los operadores bit a bit (bitwise) trabajan sobre representaciones binarias de datos y su utilidad est\u00e1 en cambiar bits individuales en un operando. Los dos operandos asociados al operador bit a bit deben ser enteros. En la imagen vemos los bloques que aparecen en avanzados.</p> <p> <p> Bloques de operadores avanzados</p> <p></p> <ul> <li> Permite modificar el rango de un valor o variable desde un rango origen a un rango destino. Esta funci\u00f3n es especialmente \u00fatil para adaptar los valores le\u00eddos de sensores o para adaptar valores a aplicar en un actuador.</li> <li> Convierte una cadena Hexadecimal en un n\u00famero decimal. Por ejemplo, 5A hex. = 90 dec.</li> <li>  El operador AND compara dos bits y genera un resultado igual a 1 si ambos bits son 1; en caso contrario, devuelve 0. N\u00fameros de mas de un bit son comparados bit a bit. Un ejemplo de aplicaci\u00f3n lo vemos en la imagen siguiente.</li> </ul> <p> <p> bitwise AND</p> <p></p> <p>La tabla siguiente muestra la forma de obtener el resultado de forma te\u00f3rica.</p> <p> <p> </p> <p></p> <ul> <li>  El operador OR compara dos bits y devuelve 1 si uno o ambos bits son 1 y da 0 si ambos bits son 0. Bitwise OR compara todas las posiciones de bits de ambos n\u00fameros e informa de aquellas en las que cualquiera de los dos est\u00e1 a 1.</li> </ul> <p>Un ejemplo de aplicaci\u00f3n lo vemos en la imagen siguiente.</p> <p> <p> bitwise OR</p> <p></p> <p>La tabla siguiente muestra la forma de obtener el resultado de forma te\u00f3rica.</p> <p> <p> </p> <p></p> <ul> <li>  El operador EXCLUSIVE-OR compara dos bits y genera un resultado de 1 si los bits son complementarios (el bit se establece en un operando pero no en ambos); en caso contrario, devuelve 0. Otra forma de pensar en la operaci\u00f3n XOR es que invertir\u00e1 las posiciones de los bits en las que el segundo operando tenga un 1. Todas las dem\u00e1s se copiar\u00e1n igual.</li> </ul> <p>Un ejemplo de aplicaci\u00f3n lo vemos en la imagen siguiente.</p> <p> <p> bitwise XOR</p> <p></p> <p>La tabla siguiente muestra la forma de obtener el resultado de forma te\u00f3rica.</p> <p> <p> </p> <p></p> <ul> <li>  El operador NOT se utiliza para invertir (BIT FLIP) todos los bits del operando Cuando el bit de posici\u00f3n m\u00e1s alta de un n\u00famero se convierte en 1, ese n\u00famero se considera un n\u00famero negativo. La representaci\u00f3n inform\u00e1tica real de un n\u00famero entero con signo en MicroBlocks es de 31 bits. El bit de mayor peso es un bit de signo. Esto permite n\u00fameros en el rango de -1073741824 a 1073741823. Cuando el bit de signo es 0, el n\u00famero es positivo; y cuando es 1, el n\u00famero es negativo.</li> </ul> <p>Un ejemplo de aplicaci\u00f3n lo vemos en la imagen siguiente.</p> <p> <p> bitwise NOT</p> <p></p> <p>La explicaci\u00f3n es sencilla, el n\u00famero 3 (0011) se convierte al binario 1100 y como el bit de mayor peso es 1 indica que es negativo y el n\u00famero es 4, por lo tanto el resultado es -4.</p> <ul> <li> El valor del operando izquierdo se desplaza hacia la izquierda el n\u00famero de bits especificado por el operando derecho. Los bits se desplazan hacia la izquierda, el bit situado m\u00e1s a la izquierda se descarta y al bit situado m\u00e1s a la derecha se le asigna el valor 0. Cada posici\u00f3n de bit desplazada a la izquierda equivale en binario a multiplicar por 2. En la imagen siguiente vemos el funcionamiento del desplazamiento a la izquierda a nivel de bit.</li> </ul> <p> <p> bitwise desplazamiento izquierda</p> <p></p> <ul> <li> El valor del operando izquierdo se desplaza hacia la derecha el n\u00famero de bits especificado por el operando derecho. Los bits se desplazan hacia la derecha, el bit situado m\u00e1s a la derecha se descarta y al bit situado m\u00e1s a la izquierda se le asigna una copia del bit de signo. Esto se denomina desplazamiento aritm\u00e9tico. Por cada posici\u00f3n de bit desplazada a la derecha, esta operaci\u00f3n es el equivalente binario de dividir por 2. En la imagen siguiente vemos el funcionamiento del desplazamiento a la derecha a nivel de bit.</li> </ul> <p> <p> bitwise desplazamiento izquierda</p> <p></p>"},{"location":"actividades/A02/#variables_1","title":"Variables","text":"<p>En MicroBlocks se contemplan dos tipos de variables, las globales y las locales. Cuando hablamos en estos t\u00e9rminos hablamos de \u00e1mbito (scope) de las variables y determina la zona donde se define la variable, que son global y local.</p> <p>Las variables locales son las definidas dentro de una funci\u00f3n y solamente est\u00e1 disponible para el c\u00f3digo que se ejecuta dentro de la funci\u00f3n.</p> <p>Las variables globales se definen en cualquier punto del programa, normalmente al principio, y pueden ser llamadas desde cualquier sitio del programa, incluso desde las funciones.</p> <ul> <li> Este bloque es en realidad un bot\u00f3n que crea una nueva variable global. Si existe una variable con el mismo nombre, se crear\u00e1 una nueva con el mismo nombre y el n\u00famero 2 a\u00f1adido. Cuando creamos una variable se nos pide el nombre de la misma en una ventana emergente y una vez creada aparecer\u00e1 un nuevo bloque para acceder al valor de la variable creada. Adem\u00e1s esta nueva variable estar\u00e1 disponible para su selecci\u00f3n en dos de los bloques que explicaremos despu\u00e9s.</li> <li>  Este bloque es en realidad un bot\u00f3n que sirve para eliminar una variable previamente creada.</li> </ul> <p>En la animaci\u00f3n siguiente vemos el proceso de creaci\u00f3n y eliminaci\u00f3n de variables.</p> <p> <p> Creaci\u00f3n y eliminaci\u00f3n de variables</p> <p></p> <p>La opci\u00f3n de mostrar el nombre de las variables mostrada desde el bloque se puede utilizar para a\u00f1adir variables mientras se edita el c\u00f3digo del programa, sin pasar a las opciones de la categor\u00eda variables.</p> <ul> <li>  Este bloque asigna el valor a cualquier variable, global o local, en la cantidad especificada en el \u00e1rea de entrada. La cantidad que se asigna puede ser un n\u00famero positivo o negativo. Para mostrar los nombres de las variables locales en el men\u00fa de selecci\u00f3n, este bloque debe estar f\u00edsicamente unido a la secuencia de bloques en la que se utiliza el bloque 'Inicializar local' que veremos a continuaci\u00f3n.</li> <li>  Este bloque suma algebraicamente (cambia) el valor de cualquier variable, global o local, en la cantidad especificada en el \u00e1rea de entrada. La cantidad de cambio puede ser un n\u00famero positivo o negativo.</li> <li>  Este bloque se utiliza para crear e inicializar variables locales. El nombre predeterminado de la variable 'var' puede cambiarse por cualquier otro haciendo clic en el nombre y escribiendo un nuevo nombre en el cuadro de di\u00e1logo que se abre. Desp\u00e9s, si es necesario cambiar el valor de la variable local, se puede utilizar el bloque 'asigna valor a' de la categor\u00eda variables. En la animaci\u00f3n siguiente vemos este proceso y la disponibilidad o no de la variable local.</li> </ul> <p> <p> Inicializa variable local</p> <p></p> <p>Una variable global tiene:</p> <ul> <li>Alcance global: Una variable global puede utilizarse en cualquier script que no tenga una variable local del mismo nombre que la anule.</li> <li>Tiempo de vida largo: Una variable global es creada expl\u00edcitamente y vive hasta que es expl\u00edcitamente borrada. Conserva su valor cuando los scripts se inician y detienen e incluso cuando no hay scripts en ejecuci\u00f3n. Sin embargo, al hacer clic en el bot\u00f3n \"Detener\", todas las variables globales se borran e inicializan con el valor cero. Las variables globales tambi\u00e9n se inicializan a cero cuando se crean por primera vez y cuando se carga un proyecto.</li> </ul> <p>Por el contrario, una variable local tiene:</p> <ul> <li>\u00c1mbito local: Una variable local s\u00f3lo puede utilizarse en el script en el que aparece. Si varios scripts utilizan variables locales con el mismo nombre, esas variables son independientes entre s\u00ed. Aunque esta pr\u00e1ctica se desaconseja porque puede inducir a errores.</li> <li>Tiempo de vida limitado: Una variable local de un script se crea cuando se inicia el script y se elimina cuando \u00e9ste finaliza. Se crea una nueva variable local cada vez que se inicia un script (incluyendo un script de funci\u00f3n), y las variables locales de cada invocaci\u00f3n de script son independientes entre s\u00ed.</li> <li>Precedencia sobre las globales: Si una variable local tiene el mismo nombre que una variable global, la variable local prevalece sobre la global en el script en el que aparece la variable local. Una variable es local en todo el script sin importar en qu\u00e9 parte del script aparezca \"inicializar var local a\", aunque es una buena pr\u00e1ctica de codificaci\u00f3n que \"inicializar var local a\" preceda a cualquier otra referencia a esa variable.</li> </ul> <p>Un ejemplo comentado de aplicaci\u00f3n lo vemos en la imagen siguiente.</p> <p> <p> Variables</p> <p></p> <p>Descargar el programa</p>"},{"location":"actividades/A02/#bucles_2","title":"Bucles","text":"<p>En el caso de MicroBlocks los bucles, condicionales y funciones est\u00e1n todos englobados en la categor\u00eda 'Control'. Vamos a ver algunos de ellos en esta ocasi\u00f3n y los que no veamos en esta actividad se ir\u00e1n viendo cuando los necesitemos.</p> <ul> <li>  Los bloques con forma de sombrero forman parte de un grupo de bloques de control que comienzan a ejecutarse cuando se pulsa el icono verde <code>Inicia</code>. Este bloque se activa cuando se cumple la condici\u00f3n de inicio del programa.</li> <li>  Los bloques con forma de \"C\" son un grupo de bloques de control que ejecutan el c\u00f3digo colocado en su interior siempre que se cumplan las condiciones descritas en sus subt\u00edtulos. Estos son los bloques de tipo bucle. Este en particular ejecutar\u00e1 los bloques en su interior indefinidamente.</li> <li>  Este bloque C ejecuta el c\u00f3digo colocado en su interior el n\u00famero especificado de veces. En el ejemplo siguiente veremos tanto en el programa como en la pantalla la suma de los 10 primero n\u00fameros naturales.</li> </ul> <p> <p> Suma de los 10 primeros n\u00fameros</p> <p></p> <p>Descargar el programa</p> <ul> <li> <p>  Este bloque estambi\u00e9n de tipo C y pertenece al grupo de los bucles. Funciona de dos formas distintas en funci\u00f3n del tipo de entrada especificado.</p> </li> <li> <p>Si la entrada es un n\u00famero, los bloques interiores se ejecutar\u00e1n tantas veces como el n\u00famero. En cada iteraci\u00f3n del bucle, empezando por uno, el par\u00e1metro o variable de control es 'i' por defecto y se incrementar\u00e1 en uno. Este valor se puede utilizar en el c\u00f3digo del programa como se crea conveniente.</p> </li> <li>El nombre del par\u00e1metro de control puede cambiarse por otro haciendo clic en la 'i' y escribiendo un nuevo nombre.</li> <li>Si la entrada es una lista, los bloques colocados dentro se ejecutar\u00e1n tantas veces como elementos tenga la lista. En cada iteraci\u00f3n, el par\u00e1metro de control 'i' tomar\u00e1 el valor de cada elemento de la lista de manera secuencia. En el ejemplo siguiente vemos una animaci\u00f3n de un sencillo programa de como hacer un contador con los 5 primeros n\u00fameros y hacer que se muestre en el ordenador y en la pantalla de la micro:bit.</li> </ul> <p> <p> Mostrar los 5 primeros n\u00fameros</p> <p></p> <p>Descargar el programa</p> <ul> <li>  Este bloque pausa el flujo de ejecuci\u00f3n del programa por el tiempo especificado en milisegundos. Se utiliza para pausar y reanudar la ejecuci\u00f3n de c\u00f3digo de forma controlada.</li> <li>  Este bloque pausa el flujo de ejecuci\u00f3n del programa por el tiempo especificado en microsegundos. Se utiliza para pausar y reanudar la ejecuci\u00f3n de c\u00f3digo de forma controlada.</li> <li>  Emite el mensaje especificado. V\u00e9ase en conjunto a . Este bloque env\u00eda el contenido del mensaje especificado. Todos los bloques de mensajes <code>al recibir</code> con el mismo mensaje en su contenido recibir\u00e1n el mensaje y actuar\u00e1n ejecutando su contenido.</li> <li>  Ejecuta cuando se emita el mensaje especificado. Este bloque y su par funcional  se suelen utilizar juntos para conseguir un medio de comunicaci\u00f3n dentro del programa. Cualquier mensaje enviado con el comando <code>env\u00eda</code> es detectado y recibido por este bloque. As\u00ed, los bloques colocados bajo este bloque se ejecutar\u00e1n al recibir el mensaje correspondiente. Los mensajes pueden ser cadenas o n\u00fameros. Adem\u00e1s, el bloque  contiene el \u00faltimo mensaje emitido y recibido.</li> <li>  Devuelve el \u00faltimo mensaje enviado en todo el programa, cronol\u00f3gicamente hablando. N\u00f3tese que NO es el \u00faltimo mensaje recibido por una secuencia de bloques concreta del programa, y es independiente de la ejecuci\u00f3n del bloque <code>al recibir</code>. No hay colas de mensajes en el sistema. Si no hay ning\u00fan <code>al recibir</code> en espera cuando se env\u00eda un mensaje, se perder\u00e1 y ser\u00e1 sobrescrito por el siguiente mensaje.</li> </ul> <p>En el ejemplo siguiente vemos de forma sencilla el funcionamiento de estos tres \u00faltimos bloques.</p> <p> <p> Di el \u00faltimo mensaje</p> <p></p> <p>Descargar el programa</p>"},{"location":"actividades/A02/#listas","title":"Listas","text":"<p>Los bloques para trabajar con listas est\u00e1n en el men\u00fa 'Datos' y sus bloques los vemos en la imagen siguiente.</p> <p> <p> Bloques para Listas. Datos</p> <p></p> <ul> <li> Devuelve una lista corta que contiene algunos elementos en ingl\u00e9s. Con las flechas podemos a\u00f1adir o eliminar elementos a la lista aunquw a partir del cuarto se repite siempre el mismo. Para crear una lista vac\u00eda () basta con eliminar el \u00fanico elemento existente cuando se crea una nueva.</li> <li> Une (concatena) cadenas, listas o matrices de bytes y devuelve el resultado.</li> <li> Devuelve el car\u00e1cter Unicode del n\u00famero dado.</li> <li> Devuelve el en\u00e9simo elemento de una lista, cadena o matriz de bytes.</li> <li>  Combina los elementos de una lista en una cadena, opcionalmente se puede usar un car\u00e1cter delimitador.</li> <li>  A\u00f1ade un elemento al final de una lista.</li> </ul> <p>En el ejemplo siguiente vemos el uso de estos bloques. Comenzamos por crear una cadena de caracteres de la que vamos a extraer la palabra un mediante la uni\u00f3n de los elementos 9 y 10 de la cadena. Se crea una lista con cuatros animales y finalmente se muestra la palabra 'un' seguida de la posici\u00f3n 3 de la lista creada.</p> <p> <p> Un pajaro</p> <p></p> <p>Descargar el programa</p> <p>En este otro ejemplo vemos como se generan los caracteres de lat\u00edn b\u00e1sico comenzando por el espacio en blanco (32), diferentes s\u00edmbolos, n\u00fameros, letras may\u00fasculas y letras min\u00fasculas.</p> <p> <p> Caracteres Unicode de Lat\u00edn b\u00e1sico</p> <p></p> <p>Descargar el programa</p> <ul> <li> Devuelve el n\u00famero de elementos de una lista, cadena o matriz de bytes.</li> <li> Sustituye el en\u00e9simo elemento de una lista por el valor dado. Tambi\u00e9n puede sustituir todos los elementos por un valor.</li> <li> Elimina el elemento N de una lista. La lista resultante se reduce de tama\u00f1o. Tambi\u00e9n puede eliminar todos los elementos.</li> </ul> <p>A continuaci\u00f3n vemos un ejemplo en el que se demuestra la funcionalidad de estos tres bloques.</p> <p> <p> Sustituir, eliminar y tama\u00f1o</p> <p></p> <p>Descargar el programa</p> <ul> <li> Devuelve la posici\u00f3n de la primera coincidencia de una subcadena dentro de una cadena o un elemento de una lista. Devuelve -1 si no encuentra coincidencias.</li> </ul> <p>En el ejemplo las variables locales <code>cadena</code> y <code>animales</code> se inicializan como de tipo string y list respectivamente. El primer conjunto de resultados opera sobre la cadena, buscando la posici\u00f3n de la primera apariciones de \"es\". La primera coincidencia se encuentra en el car\u00e1cter n\u00famero uno. La segunda b\u00fasqueda se inicia en el car\u00e1cter n\u00famero tres, y localiza el objetivo de la b\u00fasqueda en el car\u00e1cter n\u00famero seis. La b\u00fasqueda de \"perro\" en la lista 'animales' la encuentra en el elemento n\u00famero dos de la lista. La segunda b\u00fasqueda de \"perro\" en la lista 'animales' comienza en el elemento n\u00famero tres y devuelve -1 porque no lo encuentra. No hay ning\u00fan \"raton\" en la lista, por lo que la b\u00fasqueda devuelve -1.</p> <p> <p> Buscar</p> <p></p> <p>Descargar el programa</p> <ul> <li> Copia una cadena desde/hasta el caracter especificado, o una desde/hasta el elemento indicado. Como ya sabemos para mostrar el par\u00e1metro hasta hay que hacer clic en el tri\u00e1ngulo negro.</li> </ul> <p> <p> Copiar</p> <p></p> <p>Descargar el programa</p> <ul> <li> Devuelve una lista separando la cadena especificada por el delimitador opcional. Si no se especifica ning\u00fan delimitador, la cadena se divide por cada car\u00e1cter.</li> </ul> <p>En la imagen vemos una cadena delimitada por comas que separa los caracteres mediante el delimitador coma en una lista de tres elementos.</p> <p> <p></p> <p></p> <p>A continuaci\u00f3n vemos una cadena que incluye un car\u00e1cter retorno de l\u00ednea despu\u00e9s del ABC y DEF que se separa mediante el caracter unicode de nueva l\u00ednea (return) en una lista de tres elementos.</p> <p> <p></p> <p></p> <p>En este otro caso separamos la URL de la descarga de MicroBlocks en partes mediante el delimitador /.</p> <p> <p></p> <p></p> <ul> <li>  Devuelve el valor Unicode del car\u00e1cter en\u00e9simo de la cadena introducida. El n\u00famero de caracteres introducido debe estar comprendido entre uno y la longitud de la cadena. Este bloque es el opuesto de .</li> </ul> <p> <p></p> <p></p> <ul> <li> Crea una nueva lista del n\u00famero de elementos especificado. Hay que controlar la disponibilidad de memoria. Los elementos de la lista creada se pueden inicializar a cualquier valor utilizando la opci\u00f3n de bloque con todos.</li> <li> Crea una matriz del n\u00famero de elementos especificado en funci\u00f3n de la disponibilidad de memoria. Cada elemento es de tama\u00f1o byte y se le pueden asignar valores en el rango de 0-255 (0-FF).</li> <li> Devuelve una cadena que indica el n\u00famero de palabras de 32 bits de memoria din\u00e1mica disponibles para asignar nuevos objetos (cadenas, listas o matrices de bytes). Al pulsar el bot\u00f3n de parada se libera toda la memoria. Justo despu\u00e9s de pulsar el bot\u00f3n de parada, este bloque informa del total de memoria din\u00e1mica disponible en un dispositivo determinado. Los dispositivos tienen diferentes cantidades de memoria din\u00e1mica, basadas en la cantidad de RAM proporcionada por el hardware. Por ejemplo, la micro:bit v2 tiene mucha m\u00e1s RAM que la micro:bit original.</li> </ul> <p>Un ejemplo de uso.</p> <p> <p> Copiar</p> <p></p> <p>Descargar el programa</p> <ul> <li>  Convierte un byte, una lista o una cadena especificada en una matriz de bytes. Cada elemento es el valor unicode de las letras de la cadena en el rango de 0-255 (0-FF).</li> </ul>"},{"location":"actividades/A02/#programa_2","title":"Programa","text":"<p>Todos los bloques que se requieren para resolver el problema del coraz\u00f3n latiendo ya se han explicado y no se requiere nada nuevo. Pero en MicroBlocks no tenemos una definici\u00f3n previa de los corazones por lo que tendremos que crearla nosotros a partir del bloque \"pantalla\", tal y como vemos en la imagen siguiente.</p> <p> <p> Dibujos de los corazones en el bloque pantalla</p> <p></p> <p>El programa de la actividad lo vamos a hacer utilizando los bloques descritos. El programa es el siguiente:</p> <p> <p> Programa de la actividad A02 en MicroBlocks</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>A02-Corazon_latiendo.ubp</li> </ul>"},{"location":"actividades/A03/","title":"A03. Botones","text":"<p>Los ejemplos vistos hasta ahora han permitido que la micro:bit nos muestre algo. Esto es lo que se conoce como salida. Ahora bien, es evidente que necesitamos tambi\u00e9n que la micro:bit reacciones a cosas externas, y estas cosas se denominan entradas. Para que sea f\u00e1cil de recordar:</p> <ul> <li>Salida es lo que micro:bit nos muestra</li> <li>Entrada es lo que recibe la micro:bit para procesarlo</li> </ul> <p>Aunque existen otros sistemas, por ahora nos vamos a centrar en los botones de la micro:bit. Si trabajamos con versiones anteriores a la V2 disponemos de dos botones etiquetados como A y B. Si trabajamos con alguna versi\u00f3n V2 disponemos adem\u00e1s de un tercer bot\u00f3n, en este caso tactil, que est\u00e1 en el logo de la placa. En la imagen vemos estos botones.</p> <p> <p> Botones en las micro:bit V1 y V2</p> <p></p>"},{"location":"actividades/A03/#micropython","title":"MicroPython","text":"<p>Se explican los siguientes aspectos:</p> <p> <ul> <li>Sentencia condicional if...else</li> <li>Funciones en Python</li> <li>M\u00f3dulos en Python</li> <li>Funciones definidas en MicroPython para los botones</li> </ul> <p></p>"},{"location":"actividades/A03/#sentencia-condicional-ifelse","title":"Sentencia condicional if...else","text":"<p>En Python hay tres formas de declaraci\u00f3n de <code>if...else</code></p> <ol> <li>Declaraci\u00f3n <code>if</code></li> <li>Declaraci\u00f3n <code>if...else</code></li> <li>Declaraci\u00f3n <code>if...elif...else</code></li> </ol> <ol> <li>Declaraci\u00f3n <code>if</code>. La sintaxix de esta declaraci\u00f3n en Python tiene la forma siguiente:</li> </ol> <pre><code>if condicion:\n    # Cuerpo de la sentencia if\n\n# C\u00f3digo despu\u00e9s del if\n</code></pre> <p>Si el resultado de evaluar la condici\u00f3n es cierto (True o 1), el c\u00f3digo en \"Cuerpo de la sentencia if\" y lo estar\u00e1 haciendo mientras se cumpla la condici\u00f3n.</p> <p>En el momento que la condici\u00f3n sea evaluada como falsa (False o 0) el c\u00f3digo en \"Cuerpo de la sentencia if\" se omite y  continua la ejecuci\u00f3n del programa por \"C\u00f3digo despu\u00e9s del if\". En la figura siguiente vemos la explicaci\u00f3n de forma gr\u00e1fica.</p> <p> <p> Funcionamiento de la sentencia <code>if</code></p> <p></p> <ol> <li>Declaraci\u00f3n <code>if...else</code>. Una sentencia <code>if</code> puede tener de manera opcional una clausula <code>else</code>. La sintaxix de esta declaraci\u00f3n en Python tiene la forma siguiente:</li> </ol> <pre><code>if condicion:\n    # Bloque de sentencias si condicion es True\n\n    else:\n    # Bloque de sentencias si condicion es False\n</code></pre> <p>La sentencia se eval\u00faa de la siguiente forma: Si <code>condici\u00f3n</code> es <code>True</code> se ejecuta el c\u00f3digo dentro del <code>if</code> y el c\u00f3digo dentro del <code>else</code> se omite. Si <code>condici\u00f3n</code> es <code>False</code> se ejecuta el c\u00f3digo dentro del <code>else</code> y el c\u00f3digo dentro del <code>if</code> se omite. Cuando finaliza bien la parte del <code>if</code> o bien la del <code>else</code> el programa continua con la siguiente sentencia.</p> <p>En la figura siguiente vemos la explicaci\u00f3n de forma gr\u00e1fica.</p> <p> <p> Funcionamiento de la sentencia <code>if...else</code></p> <p></p> <ol> <li>Declaraci\u00f3n <code>if...elif...else</code>. La sentencia <code>if...else</code> se utiliza para ejecutar un bloque de c\u00f3digo entre dos alternativas posibles. Sin embargo, si necesitamos elegir entre m\u00e1s de dos alternativas, entonces utilizamos la sentencia <code>if...elif...else</code>. La sintaxis de la sentencia <code>if...elif...else</code> es:</li> </ol> <pre><code>if condicion_1:\n    # Bloque 1\nelif condicion_2:\n    #Bloque 2\n\n    else:\n    # Bloque 3\n</code></pre> <p>Se eval\u00faa as\u00ed: Si <code>condicion_1</code> es <code>True</code>, se ejecuta Bloque 1. Si <code>condicion_1</code> es <code>False</code>, se eval\u00faa <code>condicion_2</code>. Si <code>condicion_2</code> es <code>True</code>, se ejecuta Bloque 2. Si <code>condicion_2</code> es <code>False</code>, se ejecuta Bloque 3.</p> <p>En la figura siguiente vemos la explicaci\u00f3n de forma gr\u00e1fica.</p> <p> <p> Funcionamiento de la sentencia <code>if...elif...else</code></p> <p></p>"},{"location":"actividades/A03/#funciones-en-python","title":"Funciones en Python","text":"<p>En esta secci\u00f3n vamos a dar solamente una breve introducci\u00f3n a lo que son las funciones y los m\u00f3dulos en Python para estudiar dos funciones concretas definidas en MicroPhyton para micro:bit.</p> <p>Una funci\u00f3n es un bloque de c\u00f3digo que realiza una tarea espec\u00edfica.</p> <p>Supongamos que necesitas crear un programa para crear un c\u00edrculo y colorearlo. Puedes crear dos funciones para resolver este problema:</p> <ul> <li>crear una funci\u00f3n de c\u00edrculo</li> <li>crear una funci\u00f3n de color</li> </ul> <p>Dividir un problema complejo en trozos m\u00e1s peque\u00f1os hace que nuestro programa sea f\u00e1cil de entender y reutilizar.</p> <p>Existen dos tipos de funciones en Python:</p> <ul> <li>Standard library functions (Funciones de biblioteca est\u00e1ndar). Son funciones incorporadas en Python que est\u00e1n disponibles para su uso.</li> <li>User-defined functions (Funciones definidas por el usuario). Podemos crear nuestras propias funciones para que cumplan con nuestros requisitos.</li> </ul> <p>La sintaxis de una funci\u00f3n es la siguiente:</p> <pre><code>def nombre_funcion(argumentos):\n    #Cuerpo de la funci\u00f3n\n\n    return\n</code></pre> <p>Donde,</p> <ul> <li><code>def</code> es la palabra reservada para declarar una funci\u00f3n</li> <li><code>nombre_funcion</code> es el nombre que le damos a la funci\u00f3n</li> <li><code>argumentos</code> es el valor o valores pasados a la funci\u00f3n</li> <li><code>return</code> retorna un valor desde la funci\u00f3n. Es opcional</li> </ul> <p>Veamos un ejemplo sencillo que no manda parametros ni retorna nada.</p> <p><pre><code>def saludo():\n    print(\"Hola Mundo!\")\n\nsaludo() #Llama a la funci\u00f3n\nprint(\"Programa\")\nsaludo()\nprint(\"Otra vez programa\")\n</code></pre> Va a generar como salida la cadena \"Hola Mundo!\" seguida de la cadena \"Programa\" seguida otra vez de \"Hola Mundo!\" y finaliza con \"Otra vez programa\".</p> <p>Cuando se llama a la funci\u00f3n, el control del programa pasa a la definici\u00f3n de la funci\u00f3n, se ejecuta todo el c\u00f3digo dentro de la funci\u00f3n y desp\u00e9s el control del programa salta a la siguiente sentencia despu\u00e9s de la llamada a la funci\u00f3n.</p> <p>Como ya se ha mencionado, una funci\u00f3n tambi\u00e9n puede tener argumentos. Un argumento es un valor aceptado por una funci\u00f3n. Cuando creamos una funci\u00f3n con argumentos necesitamos pasar los correspondientes valores cuando la llamamos.</p> <p>De forma gen\u00e9rica una funci\u00f3n con argumentos tiene la siguiente sintaxis:</p> <pre><code>def funcion(arg1, arg2, ar3,...):\n    #C\u00f3digo\n\n#Llamada a la funci\u00f3n\nfuncion(valor1, valor2, valor3, ...)\n#C\u00f3digo\n</code></pre> <p>Cuando llamamos a la funci\u00f3n le pasamos los valores correspondiendo valor1 a arg1, valor2 a arg2 y as\u00ed sucesivamente.</p> <p>La llamada a la funci\u00f3n se puede hacer mencionando el nombre del argumento, que es lo que se conoce como 'argumentos con nombre', siendo el c\u00f3digo totalmente equivalente al anterior.</p> <pre><code>funcion(arg1=valor1, arg2=valor2, arg3=valor3, ...)\n</code></pre> <p>Una funci\u00f3n Python puede o no devolver un valor. Si queremos que nuestra funci\u00f3n devuelva alg\u00fan valor a una llamada realizada a funci\u00f3n, utilizamos la sentencia <code>return</code>.</p> <p>En el ejemplo siguiente se llama a la funci\u00f3n cuatro veces con valores diferentes.</p> <pre><code>def cal_potencia(base, exponente):\n    resultado = base ** exponente\n    return resultado\n\n#Llamadas a la funci\u00f3n\nprint('Potencia =', cal_potencia(2,8))\nprint('Potencia =', cal_potencia(3,3))\nprint('Potencia =', cal_potencia(4,5))\nprint('Potencia =', cal_potencia(9,6))\n</code></pre> <p>El resultado es:</p> <pre><code>Potencia = 256\nPotencia = 27\nPotencia = 1024\nPotencia = 531441\n</code></pre> <p>En Python, las funciones de la biblioteca est\u00e1ndar son las funciones incorporadas que se pueden utilizar directamente en nuestro programa. Por ejemplo,</p> <ul> <li><code>print()</code>, imprime la cadena entre comillas</li> <li><code>sqrt()</code>, devuelve la ra\u00edz cuadrada de un n\u00famero</li> <li><code>pow()</code>, devuelve la potencia de un n\u00famero</li> </ul> <p>Estas funciones est\u00e1n definidas dentro de un m\u00f3dulo. Y, para utilizarlas debemos incluir dicho m\u00f3dulo en nuestro programa. Por ejemplo, <code>sqrt()</code> y <code>pow()</code> est\u00e1n definidos en el m\u00f3dulo <code>math</code>. Para usar las funciones podemos hacer como en el ejemplo siguiente:</p> <pre><code>import math #Carga el m\u00f3dulo math\n\nraiz = math.sqrt(25)\nprint(\"La raiz cuadrada de 25 es \", raiz)\n\npotencia = pow(2, 8)\nprint(\"2^8 =\", potencia)\n</code></pre> <p>En el ejemplo la variable raiz contendr\u00e1 el c\u00e1lculo de la raiz cuadrada y se define por defecto como variable real o decimal y potencia contendr\u00e1 el resultado de elevar a 8 el n\u00famero 2. Los resultados obtenidos son:</p> <pre><code>La raiz cuadrada de 25 es 5.0\n2^8 = 256\n</code></pre> <p>Las principales ventajas de utilizar funciones son:</p> <ul> <li>C\u00f3digo reutilizable. Podemos llamar a la misma funci\u00f3n tantas veces en nuestro programa como necesitemos, lo que hace que nuestro c\u00f3digo sea reutilizable.</li> <li>C\u00f3digo legible. Las funciones nos ayudan a dividir nuestro c\u00f3digo en trozos para que nuestro programa sea mas legible y f\u00e1cil de entender.</li> </ul>"},{"location":"actividades/A03/#modulos-en-python","title":"M\u00f3dulos en Python","text":"<p>A medida que nuestro programa crece, puede contener muchas l\u00edneas de c\u00f3digo. En lugar de poner todo en un solo archivo, podemos utilizar m\u00f3dulos para separar por funcionalidad los c\u00f3digos en varios archivos. Esto hace que nuestro c\u00f3digo quede organizado y sea m\u00e1s f\u00e1cil de mantener.</p> <p>Un m\u00f3dulo es un archivo que contiene c\u00f3digo para realizar una tarea espec\u00edfica. Un m\u00f3dulo puede contener variables, funciones, clases, etc. Veamos un ejemplo, vamos a crear un m\u00f3dulo escribiendo algo como lo siguiente:</p> <pre><code>#Definici\u00f3n del m\u00f3dulo suma\n\ndef sumar(a, b):\n\n    resultado = a + b\n    return resultado\n</code></pre> <p>Guardamos este programa en un archivo, por ejemplo <code>modulo_sumar.py</code> y tendremos definida una funci\u00f3n de nombre <code>sumar</code> en ese m\u00f3dulo. La funci\u00f3n recibe dos valores y devuelve la suma.</p> <p>Cuando, en un programa diferente, queramos sumar dos n\u00fameros podemos importar la definici\u00f3n creada utilizando la palabra reservada <code>import</code>. Para acceder a la funci\u00f3n definida en el m\u00f3dulo tenemos que utilizar el operador <code>.</code> (punto). Se parece mucho a que el m\u00f3dulo es una clase y la funci\u00f3n una instancia de esa clase.</p> <pre><code># Programa de sumas\nimport modulo_sumar\n\nmodulo_sumar.sumar(4, 5) #devolver\u00e1 9\n</code></pre> <p>Python tiene mas de 200 m\u00f3dulos est\u00e1ndar que pueden ser importados de la misma manera que importamos los m\u00f3dulos definidos por nosotros. En la documentaci\u00f3n de Python en espa\u00f1ol encontramos la referencia a La biblioteca est\u00e1ndar de Python.</p>"},{"location":"actividades/A03/#los-botones-eventos","title":"Los botones. Eventos","text":"<p>Si trabajamos con versiones anteriores a V2 solamente disponemos de los botones A, B y A+B, pero si tenemos una versi\u00f3n V2 tambi\u00e9n disponemos del bot\u00f3n t\u00e1ctil incorporado en el logo, aunque a todos los efectos este se considera un pin de entrada.</p> <p>El logo no es tratado exactamente como un bot\u00f3n, sino como un pin de nombre logo. En el borde existen otros tres pines, los 0, 1 y 2. Por ello la forma de trabajar con el logo va a ser un poco diferente, como veremos en la actividad A04.</p> <p>La diferencia fundamental, ademas de la forma, es que el logo es un sensor capacitivo y los pines son sensores resistivos. En la pr\u00e1ctica esto significa que el logo funciona simplemente tocandolo y los pines necesitan cerrar el circuito con GND, por lo que para que funcionen como pulsador debemos tocar tanto el pinto como GND.</p> <p>Si queremos que MicroPython reaccione a los eventos de pulsaci\u00f3n de los botones, debemos ponerlo en un bucle infinito y comprobar si el bot\u00f3n <code>is_pressed</code>.</p> <ul> <li>Funci\u00f3n <code>is_pressed()</code></li> </ul> <p>Para trabajar con los botones de la micro:bit tenemos disponibles funciones que se han cargado al importar el m\u00f3dulo <code>microbit</code>. Estas funciones est\u00e1n basadas en la funci\u00f3n gen\u00e9rica <code>is_pressed()</code> pensada para saber que tecla de un teclado se ha pulsado. Sin embargo, en el caso de MicroPython a para micro:bit a estos botones se les ha asignado un nombre a cada uno, <code>button_a</code> para el A y  <code>button_b</code> para el B, de manera que para usarlos se llama al bot\u00f3n y con el operador <code>.</code> a la funci\u00f3n <code>is_pressed()</code>. Por ejemplo, <code>button_a.is_pressed()</code> es el c\u00f3digo encargado de saber si estamos pulsando el bot\u00f3n A y <code>button_b.is_pressed()</code> si lo es el B.</p> <ul> <li>Funci\u00f3n <code>get_pressed()</code></li> </ul> <p>Esta funci\u00f3n retorna el total acumulado de pulsaciones de botones y restablece este total a cero antes de volver. Es decir, podemos capturar el n\u00famero de veces que hemos pulsado un bot\u00f3n. El valor de retorno es un n\u00famero, por lo que, para mostrarlo en la pantalla de LEDs hay que convertirlo en cadena con la funci\u00f3n <code>str()</code>.</p> <ul> <li>Funci\u00f3n <code>was_pressed()</code></li> </ul> <p>Devuelve <code>True</code> o <code>False</code> para indicar si se ha presionado el bot\u00f3n desde la \u00faltima vez que se inicio el dispositivo o se llam\u00f3 a este m\u00e9todo. Llamar a este m\u00e9todo borra el estado de que ha sido pulsado, de modo que el bot\u00f3n debe pulsarse de nuevo antes de que este m\u00e9todo vuelva a retornar <code>True</code>.</p> <p>Vamos a hacer un ejemplo que aclarar\u00e1 mejor lo explicado. Se trata de crear un programa (le podremos de nombre Caritas_X) en el que mientras mantegamos pulsado el bot\u00f3n A se muestra una cara sonriente, si no se pulsa ning\u00fan bot\u00f3n se muestra una cara triste y si se pulsa el bot\u00f3n B la cara desaparece (se apagan todos los LEDs) y tras 2 segundos aparece una X que se va haciendo cada vez mas grande partiendo del punto central. Finalmente pasados otros 2 segundos el programa vuelve a empezar. El c\u00f3digo es:</p> <pre><code>from microbit import *\nwhile True:\n    while True:\n        if button_a.is_pressed():\n            display.show(Image.HAPPY)\n        elif button_b.is_pressed():\n            break\n        else:\n            display.show(Image.SAD)\n\n    display.clear()\n    sleep(2000)\n    mi_X_peque = Image(\"00000:00000:00900:00000:0000\")\n    display.show(mi_X_peque)\n    sleep(200)\n    mi_X_media = Image(\"00000:09090:00900:09090:0000\")\n    display.show(mi_X_media)\n    sleep(200)\n    mi_X_grande = Image(\"90009:09090:00900:09090:90009\")\n    display.show(mi_X_grande)\n    sleep(2000)\n</code></pre> <p>En la animaci\u00f3n siguiente vemos como funciona</p> <p> <p> Funcionamiento de Caritas_X</p> <p></p> <p>Si observamos con cuidado apreciaremos que en alg\u00fan momento se accionan los botones A y B pero los que aparecen en la parte inferior, debajo de la pantalla de simulaci\u00f3n. Est\u00e1n al lado de un logotipo que indica que se pulsen con una flechita. Justo debajo de estos aparecen los citados del borde de placa y el logo junto a ellos, pues es tratado asi, como un pin, y adem\u00e1s a su izquierda hay un candado cerrado indicativo de que no se est\u00e1 usando ninguno de ellos. En la imagen siguiente se ve mejor lo indicado.</p> <p> <p> Control de acciones del simulador</p> <p></p> <p>Vamos a crear otro ejemplo en el que se cuenten las veces que pulsamos el bot\u00f3n A o el bot\u00f3n B durante un tiempo de 3 segundo. El programa es el siguiente:</p> <pre><code>from microbit import *\n\nsleep(3000) #Espera de 3 segundos\n\n#Convertimos n\u00famero a cadena con str()\npulsado = str(button_b.get_presses())\n\ndisplay.show(pulsado)\n\n# Por si hemos pulsado mas de 9 veces\ndisplay.scroll(pulsado)\n</code></pre> <p>En la 'Referencia' del compilador, dentro de Botones tenemos un ejemplo que nos indica el bot\u00f3n que hemos pulsado con cuatro opciones posibles, el A, el B, A o B y finalmente A y B. Animamos a cargarlos y probarlos para familiarizarnos todo lo posible con ellos.</p>"},{"location":"actividades/A03/#programa","title":"Programa","text":"<p>El programa que vamos a crear como ejemplo nos va a mostrar en la pantalla el bot\u00f3n que estamos pulsando mientras lo mantengamos accionado.</p> <p>El c\u00f3digo del programa 'Boton_pulsado' es el siguiente:</p> <pre><code>from microbit import *\n\nwhile True:\n    if button_a.is_pressed():\n        display.scroll('A')\n    elif button_b.is_pressed():\n        display.scroll('B')\n</code></pre> <p>El funcionamiento lo vemos en la animaci\u00f3n siguiente:</p> <p> <p> Muestra 'Boton_pulsado' funcionando</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>A03-Boton_pulsado en hexadecimal</li> <li>A03-Boton_pulsado en Python</li> </ul>"},{"location":"actividades/A03/#makecode","title":"MakeCode","text":"<p>Se explican los siguientes aspectos:</p> <p> <ul> <li>Operadores de comparaci\u00f3n y booleanos</li> <li>Sentencia condicional if...elif...else</li> <li>Texto</li> <li>Bloques de 'Entrada' para los botones</li> </ul> <p></p>"},{"location":"actividades/A03/#operadores-de-comparacion-y-booleanos","title":"Operadores de comparaci\u00f3n y booleanos","text":"<p>Como sabemos un valor booleano solamente puede tomar uno de dos valores posibles: <code>True (verdadero)</code> o <code>False (falso)</code>. Estos bloques los encontramos en la entrada 'L\u00f3gica' y son:</p> <p> <p> Valores booleanos</p> <p></p> <p>Los dos bloques existen de forma separada, pero cada uno de ellos puede adoptar el valor contrario al que muestra por defecto seleccionandolo con la flechita.</p> <p>Los operadores booleanos u operadores l\u00f3gicos son AND, OR y NOT y son operadores que a partir de valores de entrada booleanos crean otro valor tambi\u00e9n booleano. Estos bloques tambi\u00e9n los encontramos en la entrada 'L\u00f3gica' y son:</p> <p> <p> Operadores booleanos</p> <p></p> <p>A continuaci\u00f3n vemos una serie de bloques con operadores que satisfacen la condici\u00f3n.</p> <p> <p> Operadores booleanos</p> <p></p> <p>Tanto los valores booleanos como los operadores se usan con instrucciones <code>if</code> o <code>while</code> para determinar qu\u00e9 c\u00f3digo se ejecutar\u00e1 a continuaci\u00f3n. Por ejemplo:</p> <p> <p> Bucle <code>while</code> con una condici\u00f3n</p> <p></p> <p>En el siguiente ejemplo se utilizan operadores booleanos en el bucle.</p> <p> <p> Bucle <code>while</code> con una condici\u00f3n y operadores booleanos</p> <p></p>"},{"location":"actividades/A03/#sentencia-condicional-ifelifelse","title":"Sentencia condicional if...elif...else","text":"<ul> <li><code>if</code>. Ejecuta c\u00f3digo dependiendo de si una condici\u00f3n booleana es verdadera o falsa. El c\u00f3digo dentro del bloque <code>if</code> s\u00f3lo se ejecuta cuando el bloque <code>condici\u00f3n</code> es verdadero.</li> </ul> <p> <p> Condicional <code>if</code></p> <p></p> <p>Se pueden comparar variables con valores o variables con variables, para una condici\u00f3n verdadera o falsa.</p> <ul> <li><code>else</code>. Si necesitamos que se ejecute alg\u00fan otro c\u00f3digo cuando la condici\u00f3n del <code>if</code> no sea verdadera, lo ponemos en un \u00e1rea de bloque adicional llamada <code>else</code> (si no).</li> </ul> <p> <p> Condicional <code>if...else</code></p> <p></p> <p>Un condicional como el siguiente se podr\u00eda leer como: \"<code>si</code> tengo dinero por encima de una cantidad, <code>entonces</code> estoy feliz y <code>si no</code> estoy triste.</p> <p> <p> Condicional <code>if...else</code></p> <p></p> <p>Cambiando el valor asignado a dinero vemos el funcionamiento.</p> <p>La clausula <code>else</code> se a\u00f1ade al condicional <code>if</code> haciendo clic en el signo '+'.</p> <ul> <li><code>if...else if</code>. Condici\u00f3n <code>if</code> que si resulta falsa se evalua una nueva condici\u00f3n puesta en <code>elif</code>. Otra acci\u00f3n condicional es a\u00f1adir un <code>if</code> a un <code>else</code> para obtener un <code>else if</code>. Funciona as\u00ed</li> </ul> <p> <p> Condicional <code>if...else if</code></p> <p></p> <p>Hacemos clic en el s\u00edmbolo m\u00e1s '+' para a\u00f1adir secciones <code>else</code> o <code>else if</code> al bloque <code>if</code> actual.</p>"},{"location":"actividades/A03/#texto","title":"Texto","text":"<p>Si expandimos el men\u00fa 'Avanzado' nos encontraremos con una entrada 'Texto' que vamos a describir en esta actividad.</p> <ul> <li> Una letra, palabra o l\u00ednea de texto que puede contener letras, n\u00fameros y caracteres.</li> <li> Devuelve el n\u00famero de caracteres de la cadena de texto.</li> <li> A\u00f1ade una cadena de texto a otra para crear una cadena mas larga. Se pueden a\u00f1adir mas cadenas.</li> <li> Convierte un texto que s\u00f3lo tiene caracteres num\u00e9ricos en un valor num\u00e9rico de coma flotante. Se puede convertir una cadena de texto con caracteres num\u00e9ricos en un valor real de coma flotante. El texto debe tener s\u00f3lo caracteres num\u00e9ricos. Aunque tambi\u00e9n puede incluir los s\u00edmbolos '-' y '.'. Si el texto tiene otros caracteres, como \"-5.8g5u7\", s\u00f3lo se devuelve -5.8 ya que es el mejor intento de conversi\u00f3n a un n\u00famero. Por lo tanto, hay que no mezclar caracteres num\u00e9ricos con letras u otros s\u00edmbolos.</li> </ul> <p>Potencias de 10. Si la cadena de texto tiene la letra 'e' despu\u00e9s de los caracteres num\u00e9ricos y luego algunos caracteres num\u00e9ricos m\u00e1s como \"2e4\", entonces los caracteres num\u00e9ricos despu\u00e9s de la 'e' son un exponente de 10. Esto significa que una cadena con \"7.5e2\" se convierte en el valor de 750 cuando se convierte a un n\u00famero de coma flotante. Esto se debe a que el 2 despu\u00e9s de la 'e' indica 10\u00b2, lo que equivale a <code>10 * 10 =  100</code>. El valor resultante es entonces 7.5 * 100 que es igual a 750. En el siguiente ejemplo se toman los primeros d\u00edgitos de PI de la frase \"pi vale 3.141592\" y los convierte en un n\u00famero.</p> <p> <p> Extraer PI de una cadena</p> <p></p> <p>Descargar el programa</p> <ul> <li> Divide una cadena en cadenas m\u00e1s peque\u00f1as utilizando un caracter (una cadena) de separaci\u00f3n para dividir la cadena m\u00e1s grande.</li> <li> Determina si una cadena contiene los caracteres de una cadena especificada.</li> <li> Obtiene la posici\u00f3n (\u00edndice) de la primera aparici\u00f3n de un valor especificado en una cadena.</li> <li> Determina si una cadena de texto contiene caracteres o no. TODO</li> <li> Toma una parte de la cadena \"this\" para hacer una cadena m\u00e1s peque\u00f1a (subcadena). * Si una cadena tiene una parte que est\u00e1 copiada de otra cadena, se llama subcadena. Se puede crear una nueva cadena que s\u00f3lo contenga la palabra \"aqu\u00ed\" a partir de una cadena mayor que diga \"\u00a1Hola, estamos aqu\u00ed!\". Para ello, la subcadena se copia desde la posici\u00f3n de car\u00e1cter 15 en la primera cadena y se copian 4 caracteres. Se hace as\u00ed: . En el ejemplo se copian los sustantivos de la frase en dos cadenas m\u00e1s peque\u00f1as.</li> </ul> <p> <p> Extraer de cade a subcadenas</p> <p></p> <p>Descargar el programa</p> <ul> <li> Se comparan dos cadenas de texto en funci\u00f3n de los caracteres que aparecen en primer lugar. Dos cadenas se comparan en funci\u00f3n del orden de sus caracteres. Si la cadena \"A\" vale \"111\" ser\u00e1 menor que una cadena con \"512\". Una cadena con \"Everything (Todo)\" es menor que \"Nothing (Nada)\" porque la 'N' viene despu\u00e9s de la 'E' en el alfabeto. La cadena \"abcdefg\" es mayor que \"abcdefa\". Son casi iguales, pero la \u00faltima letra de la segunda cadena es menor que la \u00faltima letra de la primera. Esto hace que toda la segunda cadena se compare como menor. En bloques, la comparaci\u00f3n de estas cadenas tiene el siguiente aspecto:</li> </ul> <p> <p> Comparar cadenas</p> <p></p> <ul> <li> Obtiene un car\u00e1cter (letra, n\u00famero o s\u00edmbolo) de un lugar de la cadena de texto. Podemos averiguar qu\u00e9 car\u00e1cter se encuentra en cualquier lugar de un texto. Puedes tener un texto que diga \"Hello there!\". El car\u00e1cter en la posici\u00f3n 6 es 't'. La palabra \"Hello\" m\u00e1s el espacio tienen las posiciones 0 - 5, as\u00ed que, 't' est\u00e1 en la posici\u00f3n 6. Para obtener el car\u00e1cter en esta posici\u00f3n, la letra 't', se podr\u00eda usar un bloque como este:</li> </ul> <p> <p> Extraer caracter de una cadena</p> <p></p> <ul> <li> Convierte el valor de cualquier tipo de dato a una cadena de texto. El siguiente ejemplo convierte un valor booleano y un valor num\u00e9rico en cadenas y las une en una cadena o frase.</li> </ul> <p> <p> Convertir valores booleanos y num\u00e9ricos en cadena</p> <p></p> <p>Descargar el programa</p> <ul> <li> Hacer que una cadena de un caracter sea representada a partir del c\u00f3digo num\u00e9rico que le asignemos. Al igual que el c\u00f3digo ASCII es un juego de caracteres que asigna un valor a cada uno de ellos, nosotros podemos crear nuestro propio c\u00f3digo asign\u00e1ndole un c\u00f3digo con este bloque. Por ejemplo, hacer que la letra B sea: </li> </ul>"},{"location":"actividades/A03/#bloques-de-entrada-para-los-botones","title":"Bloques de 'Entrada' para los botones","text":"<p>Cuando presionamos los botones A y/o B ocurre un evento (se ha presionado un bot\u00f3n). Este tipo de acci\u00f3n se considera una entrada a la microbit y tenemos bloques para manejarlo.</p> <ul> <li>al presionar el bot\u00f3n</li> </ul> <p>Presionar un bot\u00f3n inicia un manejador de eventos, que es una parte del programa que se ejecutar\u00e1 cuando ocurra algo, como por ejemplo,  cuando se pulsa un bot\u00f3n. Este manejador funciona cuando se pulsa el bot\u00f3n A o B, o A y B al mismo tiempo.Cuando estemos utilizando esta funci\u00f3n en un navegador, pulsaremos los botones de la pantalla en lugar de los del micro:bit.</p> <ul> <li>Para el bot\u00f3n A o B: Este manejador de evento funciona cuando el bot\u00f3n se pulsa y se suelta en menos de un segundo.</li> <li>Para A y B juntos: Este manejador funciona cuando A y B son presionados simultanemente. Disponemos de un segundo y medio desde que pulsamos el primer bot\u00f3n hasta que pulsamos el seg\u00fando para que se consideren ambos pulsados a la vez.</li> </ul> <p> <p> Bloque 'Al presionar el bot\u00f3n...'</p> <p></p> <p>En el siguiente ejemplo se cuenta cu\u00e1ntas veces se pulsa el bot\u00f3n A. Cada vez que se pulsa el bot\u00f3n, la pantalla LED muestra la variable de recuento que cada vez ser\u00e1 mayor.</p> <p> <p></p> <p>Contar pulsaciones de A</p> <p></p> <p>Descargar el programa</p> <p>En el ejemplo siguiente se simula un dado mostrando un n\u00famero del 1 al 6 cuando pulsamos el bot\u00f3n B. En el programa se utiliza el bloque de generaci\u00f3n de n\u00famero aleatorios entre dos valores dados que podemos encontrar en el men\u00fa 'Matem\u00e1ticas'.</p> <p> <p></p> <p>Dado</p> <p></p> <p>Descargar el programa</p> <ul> <li>bot\u00f3n A o B presionado</li> </ul> <p>El bloque siguiente comprueba si se est\u00e1 pulsando un bot\u00f3n en ese momento.</p> <p> <p></p> <p>Se ha presionado el bot\u00f3n</p> <p></p> <p>Un sencillo ejemplo nos aclara como funciona el bloque.</p> <p> <p></p> <p>Bot\u00f3n A presionado</p> <p></p> <p>Descargar el programa</p> <ul> <li>al pulsar el logotipo  (solo en versiones V2)</li> </ul> <p>El logo de micro:bit V2 act\u00faa como un bot\u00f3n t\u00e1ctil, por lo que es un actuador de entrada que cuando lo pulsamos (tocamos) se ejecuta su c\u00f3digo y cuando lo soltamos (no lo tocamos) deja de hacerlo.</p> <p> <p></p> <p>Bot\u00f3n t\u00e1ctil</p> <p></p> <p>El bloque funciona solamente con micro:bit V2 y si lo usamos con una placa V1 nos generar\u00e1 el c\u00f3digo de error 927 en la pantalla.</p> <ul> <li>el logotipo est\u00e1 pulsado  (solo en versiones V2)</li> </ul> <p>Comprueba si se est\u00e1 pulsando el logotipo de micro:bit. Utilizamos el valor booleano del estado de la pulsaci\u00f3n del logo para tomar una decisi\u00f3n l\u00f3gica en el programa. </p> <p>El ejemplo muestra una u otra imagen en funci\u00f3n de si se ha pulsado el logo o no.</p> <p> <p></p> <p>Logo presionado</p> <p></p> <p>Descargar el programa</p>"},{"location":"actividades/A03/#programa_1","title":"Programa","text":"<p>El programa que vamos a crear como ejemplo nos va a mostrar en la pantalla el bot\u00f3n que estamos pulsando mientras lo mantengamos accionado. El programa es el siguiente:</p> <p> <p> </p> <p></p> <p>En la animaci\u00f3n vemos el funcionamiento en el simulador.</p> <p> <p> </p> <p>Funcionamiento del programa</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>A03-boton_pulsado</li> </ul>"},{"location":"actividades/A03/#microblocks","title":"MicroBlocks","text":"<p>Se explican los siguientes aspectos:</p> <p> <ul> <li>Operadores</li> <li>Bloques de control</li> <li>Bloques de 'Entrada' para los botones</li> </ul> <p></p>"},{"location":"actividades/A03/#operadores","title":"Operadores","text":"<p>Los operadores a\u00fan no vistos son:</p> <p> <p></p> <p>Operadores aritm\u00e9ticos, de comparaci\u00f3n y booleanos</p> <p></p> <p>Los operadores aritm\u00e9ticos y de comparaci\u00f3n no requieren de mayor explicaci\u00f3n por lo que nos vamos a centrar en los booleanos.</p> <ul> <li> Operador booleano <code>True</code> o <code>False</code>. Devuelve verdadero o falso en funci\u00f3n de la posici\u00f3n del selector, o de la evaluaci\u00f3n binaria de la expresi\u00f3n utilizada como entrada. Este bloque se usa dentro de muchos otros bloques, donde se utiliza para controlar el flujo de las ejecuciones y eventos.</li> </ul> <p>El bloque <code>if</code> es un buen ejemplo para demostrar el uso del bloque verdadero/falso.</p> <p> <p></p> <p>Uso sencillo del operador <code>True/False</code></p> <p></p> <p>Descargar el programa</p> <p>El c\u00f3digo del ejemplo se ejecuta de dos maneras diferentes siempre dentro de un bucle infinito en el que se genera un n\u00famero aleatorio que puede valer 1, 2 o 3:</p> <ul> <li>La primera es la condici\u00f3n de la rama <code>IF</code> que ser\u00e1 verdadera si el n\u00famero generado es 1.</li> <li>La segunda es la rama <code>ELSE IF</code> que se eval\u00faa si la condici\u00f3n del <code>IF</code> no es verdadera y se pone a verdadero, ejecutando su c\u00f3digo.</li> <li> <p>La tercera es la condici\u00f3n <code>ELSE</code> a la que nunca se llega porque si el n\u00famero vale 1 se ejecuta el <code>IF</code> y si no se ejecuta el <code>ELSE IF</code> que siempre es cierto. Es decir, aunque se genere <code>variable = 3</code> la condici\u00f3n <code>ELSE</code> no se ejecuta.</p> </li> <li> <p> Invierte el valor l\u00f3gico asociado a la expresi\u00f3n sobre la que opera. Tal y como se muestra, <code>NOT</code> devolver\u00e1 <code>FALSE</code> si el deslizador se establece en <code>TRUE</code>, y <code>TRUE</code> si se establece en <code>FALSE</code>.</p> </li> </ul> <p>En el ejemplo siguiente, una variable llamada <code>cadena</code> se inicializa como \"MicroBlocks es genial\", y una variable llamada <code>expresion</code> se inicializa en <code>TRUE</code> de una forma peculiar, diciendo que algo es igual a si mismo. Cuando se aplica <code>NOT</code> al resultado de la expresi\u00f3n de igualdad, se cambia a <code>FALSE</code>.</p> <p> <p></p> <p>Uso sencillo del operador <code>NOT</code></p> <p></p> <p>Descargar el programa</p> <ul> <li>  Devuelve verdadero s\u00f3lo si todas sus entradas son verdadero y devuelve falso en caso contrario. Como ambas condiciones tienen que ser verdaderas para obtener un resultado verdadero, si se detecta un falso en la primera condici\u00f3n, no es necesario evaluar la segunda; se devuelve falso inmediatamente.</li> </ul> <p>En el ejemplo tenemos dos variables <code>salir</code> y <code>llueve</code> que se inicializan a verdadero. Se muestran una serie de mensajes y al final se eval\u00faa si \"necesito un paraguas\" comprobando si es voy a salir y si llueve. Ambas condiciones tienen que ser verdaderas para que necesitemos un paraguas. Podemos cambiar el estado de las variables y comprobar lo que ocurre.</p> <p> <p></p> <p>Uso sencillo del operador <code>AND</code></p> <p></p> <p>Descargar el programa</p> <ul> <li>  Devuelve verdadero si uno o ambos operandos son verdaderos y devuelve falso en caso contrario. Similar a <code>AND</code> pero opuesto a \u00e9l, aqu\u00ed s\u00f3lo una de las dos condiciones tiene que ser verdadera para un resultado verdadero. Por lo tanto, si la primera condici\u00f3n es verdadera, no es necesario comprobar la segunda.</li> </ul> <p>En el ejemplo estamos generando aleatoriamente dos n\u00fameros en el rango de 1 a 5. A continuaci\u00f3n, comprobamos si alguno de los dos n\u00fameros es igual al n\u00famero que estamos buscando (3). El bloque <code>OR</code> se utiliza para verificar el resultado de la comparaci\u00f3n.</p> <p> <p></p> <p>Uso sencillo del operador <code>OR</code></p> <p></p> <p>Descargar el programa</p> <p>Cada vez que pulsemos en 'Iniciar' se genera un nuevo resultado.</p>"},{"location":"actividades/A03/#bloques-de-control","title":"Bloques de control","text":"<ul> <li>  Los bloques en este bloque de sombrero se ejecutan cuando se pulsan los botones A, B, o A+B. Se dispara una vez por cada pulsaci\u00f3n de bot\u00f3n. Si se mantiene pulsado el bot\u00f3n, no se vuelve a disparar hasta que se suelta el bot\u00f3n y se vuelve a pulsar. Por ejemplo, cuando se pulsa el bot\u00f3n A aparece en pantalla una A.</li> </ul> <p> <p></p> <p>cuando se pulsa el bot\u00f3n</p> <p></p> <ul> <li>  El bloque <code>IF</code> comprueba la condici\u00f3n booleana y ejecuta los bloques de una sola vez si la condici\u00f3n booleana se eval\u00faa como verdadera. El tri\u00e1ngulo negro permite la expansi\u00f3n del bloque <code>IF</code> con m\u00faltiples condiciones <code>ELSE IF</code> a\u00f1adidas. En caso de que las ramas <code>IF</code> o <code>ELSE IF</code> anteriores no sean verdaderas, entonces se eval\u00faan y ejecutan sucesivamente cada una de las siguientes <code>ELSE IF</code>.</li> </ul> <p>En el ejemplo, a la variable <code>aleatorio</code> se le asigna un n\u00famero al azar entre el 1 y el 10. La operaci\u00f3n MOD se utiliza para sondear el estado par/impar del n\u00famero. Si el resto de la operaci\u00f3n num dividido por 2 da como resultado 0, el n\u00famero es par, en caso contrario es impar.</p> <p> <p></p> <p>Sentencia <code>IF</code></p> <p></p> <p>Descargar el programa</p> <p>Cada vez que pulsemos en 'Iniciar' se genera un nuevo resultado.</p> <ul> <li>  El bloque 'cuando' comprueba repetidamente una condici\u00f3n booleana. Cuando la condici\u00f3n se convierte en verdadera, se ejecutan los bloques bajo el sombrero. Si la condici\u00f3n sigue siendo verdadera al final de la ejecuci\u00f3n, entonces los bloques se ejecutar\u00e1n de nuevo, y ese proceso se repite hasta que la condici\u00f3n se convierte en falsa.</li> </ul> <p>Nota: El sombrero 'cuando' incluye una espera de 10 milisegundos entre ciclos. Esto es \u00fatil para eliminar ruido en las entradas, por ejemplo rebotes en los botones, pero limita el rendimiento a un m\u00e1ximo de 100 iteraciones/segundo.</p> <p>Vamos a ver el mismo ejemplo que en el bloque <code>IF</code> pero utilizando este bloque. Los tres bloques del tipo <code>WHEN</code> empiezan a funcionar simult\u00e1neamente cuando se pulsa el icono <code>START</code>. El bloque 'por siempre' debajo de 'al empezar' genera un n\u00famero aleatorio cada segundo. Y de forma simultanea los otros dos bloques evaluan continuamente sus condiciones mostrando el resultado que corresponde a cada uno.</p> <p> <p></p> <p>Bloque 'cuando'</p> <p></p> <p>Descargar el programa</p> <ul> <li>  Este bloque de control pausa la ejecuci\u00f3n del programa y espera hasta que la condici\u00f3n booleana especificada se convierta en verdadera. Se puede utilizar para sincronizar bloques de c\u00f3digo que se ejecutan en paralelo, bas\u00e1ndose en los eventos monitorizados.</li> </ul> <p>En este ejemplo, el nivel de luz ambiental se controla mediante el sensor de luz integrado. El sensor de luz tiene un rango de 0-255, siendo 0 oscuridad total y 255 claridad m\u00e1xima. Cuando se inicia el programa, ambos bloques 'cuando se pulse el boton' comienzan a ejecutarse y a comprobar el estado del bot\u00f3n.</p> <p>Al pulsar el bot\u00f3n A, se inicia la monitorizaci\u00f3n de la luz y el programa espera hasta que los sensores de la micro:bit informen de un nivel de luz &lt; 75. Cuando esa condici\u00f3n se cumple, se emite una alerta para avisar de que hay que encender las luces.</p> <p>El bot\u00f3n B est\u00e1 programado para detener el proceso de monitorizaci\u00f3n. Al pulsarlo, detiene la ejecuci\u00f3n de esa rama del programa.</p> <p> <p></p> <p>Bloque 'cuando se pulsa el boton'</p> <p></p> <p>Descargar el programa</p> <p>El bloque 'nivel de luz' se encuentra en la libreria 'Sensores b\u00e1sicos' y el bloque 'deten las otras tareas' se explica un poco mas abajo.</p> <ul> <li> <p>  El bloque <code>RETURN</code> se utiliza para devolver el valor especificado en su \u00e1rea de entrada. El valor retornado puede ser cualquier tipo de dato. Aunque es posible utilizar el bloque <code>RETURN</code> en cualquier parte de un programa para mostrar un valor, de forma similar al bloque <code>di</code>, su uso correcto y m\u00e1s com\u00fan es en una funci\u00f3n (o bloque personalizado) para devolver un valor como resultado del proceso realizado. Hay que tener en cuenta que los bloques colocados despu\u00e9s del bloque <code>RETURN</code> no se ejecutar\u00e1n.</p> </li> <li> <p>  Este bloque tipo C es un bucle que se utiliza para ejecutar los bloques colocados dentro de \u00e9l, hasta que la condici\u00f3n booleana especificada se convierte en verdadera. En ese momento, se ejecutar\u00e1 el siguiente bloque despu\u00e9s del bloque en forma de C.</p> </li> </ul> <p>En el ejemplo vemos como se monitoriza si se ha pulsado el bot\u00f3n A enviando un mensaje </p> <p> <p></p> <p>Bloque 'repetir hasta que'</p> <p></p> <ul> <li>  Este bloque, y su par relacionado , se utilizan para controlar el hilo de ejecuci\u00f3n del programa. Este bloque detiene la ejecuci\u00f3n de todos los bloques de los que forma parte, o que est\u00e1n bajo el mismo bloque sombrero. Una vez ejecutado este bloque en un grupo de bloques, no se ejecutar\u00e1 nada m\u00e1s en ese grupo.</li> </ul> <p>En el ejemplo, el grupo de bloques de la derecha est\u00e1 en un bucle continuo que cuenta hacia atr\u00e1s y decrementa su variable local <code>numero</code>. El grupo de bloques de la izquierda tambi\u00e9n est\u00e1 en un bucle continuo, contando hacia abajo y decrementando su variable local <code>numero</code>. Cuando la cuenta atr\u00e1s alcanza el valor 7 se cumple la condici\u00f3n del <code>else if</code> y se detiene la cuenta del bloque derecho, mientras que la secuencia del bloque izquierdo continua su ejecuci\u00f3n hasta que se cumpla la condici\u00f3n del <code>if</code> que ser\u00e1 cuando se alcance el n\u00famero 2, momento en que se detiene esta tarea.</p> <p>Podemos comprobar como el \u00faltimo bloque <code>di</code> de la secuencia de la izquierda NUNCA se ejecuta porque una vez que el bloque 'deten esta tarea' se ejecuta, todas las actividades de este bloque izquierdo terminan.</p> <p> <p></p> <p>Bloques 'deten esta tarea' y 'deten las otras tareas'</p> <p></p> <p>Podemos observar como desaparece el marco verde de cada bloque cuando su tarea finaliza indicando precisamente eso, que el bloque no se est\u00e1 ejecutando.</p> <p>Descargar el programa</p>"},{"location":"actividades/A03/#bloques-de-entrada-para-los-botones_1","title":"Bloques de 'Entrada' para los botones","text":"<ul> <li> y   Devuelve el estado del bot\u00f3n A o B. <code>true</code> = pulsado y <code>false</code> = no pulsado.</li> <li> equivalente al bloque  cuando lo configuramos con el pin 26, que es el correspondiente al logotipo .  Devuelve el estado del logo. <code>true</code> si lo tocamos (equivale a pulsador A o B pulsado) y <code>false</code> cuando no lo tocamos. Estos bloques est\u00e1n disponibles dentro la 'Libreria' 'Sensores[ ]' y aparece como 'Touch (microbit)'. El bloque para configurar el n\u00famero de pin tiene su sentido en la existencia de sensores t\u00e1ctiles en el borde de placa, como veremos mas adelante.</li> </ul> <p>En el ejemplo vemos como chequear el estado de los botones mediante la sentencia <code>IF</code>.</p> <p> <p></p> <p>Bloques para chequear el estado de los botones</p> <p></p> <p>Descargar el programa</p>"},{"location":"actividades/A03/#programa_2","title":"Programa","text":"<p>El programa que vamos a crear como ejemplo nos va a mostrar en la pantalla el bot\u00f3n que estamos pulsando mientras lo mantengamos accionado. El programa es el siguiente:</p> <p> <p> Programa de la actividad A03 en MicroBlocks</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>A03-boton-pulsado.ubp</li> </ul>"},{"location":"guias/intro/","title":"Introducci\u00f3n a Python","text":""},{"location":"guias/intro/#que-es-python-y-de-donde-viene","title":"\u00bfQue es Python y de donde viene?","text":"<p>Una breve introducci\u00f3n a cosas de Python que nos pueden ayudar con la gu\u00eda de MicroPython. Al final se trata el asunto de los permisos en Linux, que aunque sea un poco \"off topic\" puede resultar \u00fatil.</p>"},{"location":"guias/intro/#creador-de-python","title":"Creador de Python","text":"<p>Python es un lenguaje de programaci\u00f3n interpretado (no hay que compilar los programas) cuya filosof\u00eda hace hincapi\u00e9 en una sintaxis que favorezca un c\u00f3digo legible.</p> <p>Python fue creado a finales de los ochenta, por el holand\u00e9s Guido van Rossum en el Centro para las Matem\u00e1ticas y la Inform\u00e1tica (CWI, Centrum Wiskunde &amp; Informatica), en los Pa\u00edses Bajos.</p> <p>El nombre del lenguaje proviene de la afici\u00f3n de su creador por los humoristas brit\u00e1nicos Monty Python y no de la serpiente del mismo nombre. Aunque se suele usar un s\u00edmbolo con una serpiente pit\u00f3n para representarlo, de ah\u00ed la normal confusi\u00f3n.</p> <p>Se trata de un lenguaje de programaci\u00f3n multiparadigma o que soporta m\u00e1s de un paradigma de programaci\u00f3n, representando un paradigma un enfoque particular o filosof\u00eda para la construcci\u00f3n del software. Python soporta:</p> <ul> <li>Orientaci\u00f3n a objetos. En la programaci\u00f3n orientada a objetos (OOP) los objetos manipulan los datos de entrada para la obtenci\u00f3n de datos de salida espec\u00edficos, donde cada objeto ofrece una funcionalidad especial. Los objetos permiten la agrupaci\u00f3n en librer\u00edas y usualmente permiten al usuario la creaci\u00f3n de sus propias librer\u00edas. Se basa en t\u00e9cnicas de herencia, cohesi\u00f3n, abstracci\u00f3n, polimorfismo, acoplamiento y encapsulamiento.</li> <li>Programaci\u00f3n imperativa. Es la forma natural de programar un ordenador, es el estilo de programaci\u00f3n que se utiliza en el ensamblador y el m\u00e1s cercano a la m\u00e1quina. Sigue la arquitectura arquitectura cl\u00e1sica de Von Newmann con una memoria donde se almacenan los datos y el programa y una unidad de control que ejecuta las instrucciones del programa, conocida c\u00f3mo contador del programa.</li> <li>Programaci\u00f3n funcional. Es un estilo de programaci\u00f3n cuyo m\u00e9todo b\u00e1sico de computaci\u00f3n es la aplicaci\u00f3n de funciones a sus argumentos.</li> </ul>"},{"location":"guias/intro/#filosofia-python","title":"Filosof\u00eda Python","text":"<p>Es muy parecida a la filosof\u00eda de Unix. El c\u00f3digo que sigue los principios de Python de legibilidad y transparencia se dice que es \"pythonic\". Por el contrario, el c\u00f3digo opaco u ofuscado es bautizado como \"unpythonic\". Los puntos que describen su filosofia son:</p> <ul> <li>Bello es mejor que feo.</li> <li>Expl\u00edcito es mejor que impl\u00edcito.</li> <li>Simple es mejor que complejo.</li> <li>Complejo es mejor que complicado.</li> <li>Plano es mejor que anidado.</li> <li>Disperso es mejor que denso.</li> <li>La legibilidad cuenta.</li> <li>Los casos especiales no son tan especiales como para quebrantar las reglas.</li> <li>Lo pr\u00e1ctico gana a lo puro.</li> <li>Los errores nunca deber\u00edan dejarse pasar silenciosamente.</li> <li>A menos que hayan sido silenciados expl\u00edcitamente.</li> <li>Frente a la ambig\u00fcedad, rechaza la tentaci\u00f3n de adivinar.</li> <li>Deber\u00eda haber una -y preferiblemente s\u00f3lo una- manera obvia de hacerlo.</li> <li>Aunque esa manera puede no ser obvia al principio a menos que usted sea holand\u00e9s (en clara referencia a su autor).</li> <li>Ahora es mejor que nunca.</li> <li>Aunque nunca es a menudo mejor que ya mismo.</li> <li>Si la implementaci\u00f3n es dif\u00edcil de explicar, es una mala idea.</li> <li>Si la implementaci\u00f3n es f\u00e1cil de explicar, puede que sea una buena idea.</li> <li>Los espacios de nombres (namespaces) son una gran idea \u00a1Hagamos m\u00e1s de esas cosas!</li> </ul> <p>El Zen de Python viene incorporado (en ingl\u00e9s) a partir de la versi\u00f3n 2.1.2 y podemos invocarlo con <code>import this</code> abriendo Python en una terminal en un sistema en el que lo tengamos instalado, l\u00f3gicamente.</p> <p> <p> Arrastrar y soltar un fragmento de c\u00f3digo</p> <p></p>"},{"location":"guias/intro/#tipos-de-permisos-en-linux","title":"Tipos de permisos en Linux","text":"<p>El comando CHMOD nos da la posibilidad de poder cambiar los permisos de los archivos y directorios combinando entre clases y tipos. Hay cuatro clases:</p> <ul> <li>Propietario (u). Creador del archivo o la carpeta</li> <li>Grupo (g). Usuarios que tendr\u00e1n acceso al archivo o carpeta</li> <li>Otros (o). Todos los usuarios</li> <li>Todos (a). Todos los tipos de usuario (propietario, grupo y otros)</li> </ul> <p>Hay tres tipos de permisos:</p> <ul> <li>Lectura ( r). Permite que el usuario vea el archivo pero no puede realizar cambios en el mismo ni copiarlo o borrarlo.</li> <li>Escritura (w). Se permite que los usuarios que acceden al archivo o carpeta puedan realizar sobre el mismo cualquier tipo de edici\u00f3n, copiar, cortar o borrar.</li> <li>Ejecutar (x). Al activar esta opci\u00f3n, la cual viene por defecto deshabilitada, podemos ejecutar archivos.</li> </ul> <p>Hay tres modificadores para la tarea:</p> <ul> <li>+. Concede el permiso</li> <li>-. Deniega el permiso</li> <li>=. Sobreescribe un permiso con el permiso anterior.</li> </ul> <p>En entornos Unix cada permiso tiene el siguiente valor:</p> <ul> <li>Lectura: 4</li> <li>Escritura: 2</li> <li>Ejecuci\u00f3n: 1</li> </ul> <p>Jugando con sumas de estos valores establecemos distintos permisos, por ejemplo, si queremos dar un permiso de escritura usaremos el 6 = 4 + 2 (Lectura + Escritura). Si queremos que pueda ejecutar usaremos el 7 = 4 + 2 + 1 (Lectura + Escritura + Ejecuci\u00f3n).</p> <p>En la tabla tenemos todos los valores posibles.</p> <p> Dec. Bin. Permiso read write exe 0 000 Sin permisos N N N 1 001 Ejecuci\u00f3n N N Y 2 010 Escritura N Y N 3 011 Lectura y escritura N Y Y 4 100 Lectura Y N N 5 101 Lectura y ejecuci\u00f3n Y N Y 6 110 Lectura y escritura Y Y N 7 111 Lectura, escritura y ejecuci\u00f3n Y Y Y <p></p> <p>El procedimiento para establecer el permiso es muy sencillo. Basta con ir a una terminal y ejecutar la siguiente orden:</p> <pre><code>chmod Tipo-permiso Ruta-Archivo\n</code></pre> <p>Ejemplos para modificar permisos en modo terminal:</p> <pre><code>chmod o=rwx * \u2192 Dar permisos de lectura, escritura y ejecuci\u00f3n a los otros usuarios.\n\nchmod go= * \u2192 Quitar todos los permisos a grupo y los otros usuarios.\n\nchmod 666 /Documentos/curso-python/Ejercicios/holamundo.py\n</code></pre> <p>En sistemas Linux con letras veremos algo como lo siguiente:</p> <ul> <li>0 \u2192 ---  \u2192 sin acceso</li> <li>1 \u2192 --x \u2192 ejecuci\u00f3n</li> <li>2 \u2192 -w- \u2192 escritura</li> <li>3 \u2192 -wx \u2192 escritura y ejecuci\u00f3n</li> <li>4 \u2192 r-- \u2192 lectura</li> <li>5 \u2192 r-x \u2192 lectura y ejecuci\u00f3n</li> <li>6 \u2192 rw- \u2192 lectura y escritura</li> <li>7 \u2192 rwx \u2192 lectura, escritura y ejecuci\u00f3n</li> </ul> <p>Por ejemplo: chmod 777. Le damos a los 3 tipos de usuarios permiso de lectura, ejecuci\u00f3n y escritura (hemos sumado4+2+1).  Si queremos dar permisos de lectura y escritura ser\u00eda 4+2 = 6 y si si lo que queremos es s\u00f3lo dar lectura ser\u00eda 4. Si lo que queremos es dar lectura y ejecuci\u00f3n ser\u00eda de sumar 4 + 1 = 5.</p> <p>Diferentes combinaciones t\u00edpicas:</p> <ul> <li>chmod 755. Permiso de lectura y ejecuci\u00f3n (4+1) a todos los usuarios excepto al propietario que lo tiene completo (lectura, escritura, ejecuci\u00f3n 4+2+1).</li> <li>chmod 666. Permisos de lectura y escritura a todos, excepto ejecuci\u00f3n (4+2). Todos pueden acceder al archivo, leer su contenido y modificarlo.</li> <li>chmod 644. Se suele utilizar para no permitr la escritura a nadie que no sea el propietario. El 755 es similar, lectura y ejecuci\u00f3n aunque este es m\u00e1s restrictivo (s\u00f3lo lectura) y (lectura, escritura para propietario).</li> </ul>"},{"location":"guias/intro/#palabras-reservadas-e-identificadores","title":"Palabras reservadas e identificadores","text":""},{"location":"guias/intro/#palabras-reservadas","title":"Palabras reservadas","text":"<p>Son palabras reservadas que tienen un significado especial para el compilador y que no podemos usar para poner nombres a variables o funciones. Todas las palabras, excepto <code>True</code>, <code>False</code> y <code>None</code> se escriben en min\u00fasculas. A continuaci\u00f3n se da un listado de todas las palabras reservadas o keywords:</p> <pre><code>False, None, True, and, as, assert, async, await, break, class, continue, \n\ndef, del, elif, else, except, finally, for, from, global, if, import, in, \n\nis, lambda, nonlocal, not, or, pass, raise, return, try, while, with, yield\n</code></pre> <p>El listado al principio nos puede resultar abrumador, pero imaginemos un lenguaje con tan solo esas palabras y entenderemos que no resultar\u00e1 tan complejo familiarizarse, al menos con las mas usuales.</p>"},{"location":"guias/intro/#identificadores","title":"Identificadores","text":"<p>Los identificadores son los nombres que se dan a variables, clases, m\u00e9todos, etc. No podemos usar palabras reservadas para estos nombres.</p> <p>Algunas reglas que nos pueden resultar \u00fatiles para nombrar idetificadores son:</p> <ul> <li>Los identificadores son sensibles a may\u00fasculas y min\u00fasculas</li> <li>Los identificadores no pueden ser palabras reservadas</li> <li>Los espacios en blanco no est\u00e1n permitidos</li> <li>Un identificador puede ser una secuencia de letras y n\u00fameros. Siempre debe empezar por una letra o por el s\u00edmbolo de subrayado \"_\". El primer car\u00e1cter de un identificador no puede ser un n\u00famero.</li> <li>No podemos utilizar caracteres especiales como la \u00f1, \u00a1, \u00bf o letras con acentos.</li> <li>No podemos utilizar los s\u00edmbolos como !, @, #, $, etc.</li> </ul> <p>Nos va a resultar muy \u00fatil recordar lo siguiente:</p> <ul> <li>Python es un lenguaje que distingue entre may\u00fasculas y min\u00fasculas. Esto significa que <code>Variable</code> y <code>variable</code> no son lo mismo</li> <li>Damos siempre a los identificadores un nombre que tenga sentido. Aunque que <code>c = 10</code> es un perfectamente v\u00e1lido, escribir <code>contador = 10</code> tendr\u00eda m\u00e1s sentido, y ser\u00eda m\u00e1s f\u00e1cil averiguar lo que representa cuando miremo el c\u00f3digo pasado un tiempo.</li> <li>Las palabras m\u00faltiples se pueden separar usando un gui\u00f3n bajo, como por ejemplo <code>esto_es_un_nombre_de_variable_muy_largo</code>.</li> </ul>"},{"location":"guias/intro/#variables-constantes-y-literales","title":"Variables, constantes y literales","text":""},{"location":"guias/intro/#variables","title":"Variables","text":"<p>En programaci\u00f3n, una variable es un nombre que se utiliza para referirse a una posici\u00f3n de memoria donde se almacena un valor. De forma m\u00e1s abstracta, puede considerarse como una caja que almacena un valor. El nombre de la caja es el nombre de la variable y el contenido su valor. Todas las variables constan de tres partes: un nombre, un tipo de dato y un valor. En la figura siguiente vemos tres variables de distintos tipos:</p> <p> <p> Concepto gr\u00e1fico de variable</p> <p>Enlace a la fuente</p> <p></p> <p>La variable <code>name</code> contiene la cadena <code>Bob</code>, la variable <code>winner</code> es cierta y la variable <code>score</code> contiene el valor <code>35</code>.</p> <p>Python no dispone de ning\u00fan comando para declarar variables. Una variable se crea cuando se le asigna valor por primera vez. La t\u00e9cnica de declarar variables es poner un nombre seguido del signo de asignaci\u00f3n (=) y el valor asignado a la variable. En la declaraci\u00f3n es importante tener claro que se distinguen may\u00fasculas de min\u00fasculas y que no est\u00e1n permitidos los caracteres especiales.</p> <p>En Python no se declara de forma explicita el tipo de la variable pues se trata de un lenguaje inferido. Las variables incluso pueden cambiar de tipo desde el que se establece al asignarle valor la primera vez. Es decir, si declaro <code>valor = 5</code> inicialmente la variable ser\u00e1 de tipo entero (int), pero si en el programa se realizan operaciones que al final hacen que <code>valor = 1.33</code> ahora valor es de tipo float. Autom\u00e1ticamente sabe que <code>valor</code> es un n\u00famero entero y declara la variable <code>valor</code> como un <code>int</code>.</p> <p>Aunque no es necesario si es posible especificar el tipo de dato de una variable, haciendo:</p> <pre><code>x = str(22) # x ser\u00e1 la cadena '22'\ny = int(22) # y ser\u00e1 el entero 22\nz = float(22) # z ser\u00e1 el n\u00famero de coma flotante 22.0\n</code></pre> <p>Es posible saber el tipo de una variable en un momento dado con la sentencia <code>type(variable)</code>.</p> <p>Algunas reglas para nombrar variables que podemos tener en cuenta son:</p> <ul> <li>Los nombres pueden tener una combinaci\u00f3n de letras min\u00fasculas o may\u00fasculas o n\u00fameros o el s\u00edmbolo de subrayado \"_\".</li> <li>Crear nombres que tengan sentido, aunque sean largos.</li> <li>Si usamos varias palabras para definir el nombre, estas las separamos por \"_\"</li> <li>Python es sensible a may\u00fasculas y min\u00fasculas.</li> <li>Hay que evitar palabras reservadas en nombres de variables.</li> </ul>"},{"location":"guias/intro/#constantes","title":"Constantes","text":"<p>Una constante no es mas que un tipo especial de variable cuyo valor no puede modificarse.</p> <p>En Python, las constantes suelen declararse y asignarse en un m\u00f3dulo (un nuevo archivo que contiene variables, funciones, etc y que se importa al archivo principal).</p> <p>Veamos c\u00f3mo declaramos constantes en un archivo separado y lo usamos en el archivo principal,</p> <ul> <li>Creamos un archivo que nombramos constantes.py y que contendr\u00e1:</li> </ul> <pre><code>PI = 3.141592\nFUERZA_GRAVEDAD = 9.82\n</code></pre> <ul> <li>Creamos el archivo principal main.py, que contendr\u00e1:</li> </ul> <pre><code>import constantes\n\nprint(constantes.PI)\nprint(constantes.FUERZA_GRAVEDAD)\n</code></pre> <p>En el ejemplo creamos el archivo de m\u00f3dulo constantes.py y asignamos el valor constante a PI y FUERZA_GRAVEDAD.</p> <p>Despu\u00e9s, creamos el archivo main.py e importamos el m\u00f3dulo constantes. Finalmente, imprimimos el valor de cada constante.</p> <p>La convenci\u00f3n es nombrarlas en may\u00fasculas para distinguirlas de las variables.</p>"},{"location":"guias/intro/#literales","title":"Literales","text":"<ul> <li>Num\u00e9ricos</li> </ul> <p>Los literales son representaciones de valores fijos en un programa. Pueden ser n\u00fameros, caracteres, cadenas, etc. Por ejemplo, \"\u00a1Hola, mundo!\", 12, 23.0, \"C\", etc.</p> <p>Los literales num\u00e9ricos son inmutables (no pueden cambiar) y pueden pertenecer a uno de los tres tipos de datos num\u00e9ricos posibles: Entero, Coma flotante y Complejo. Los tipos son:</p> <ul> <li>Decimal. N\u00fameros regulares. Por ejemplo: 5, 22, -40</li> <li>Binario. Deben comenzar por 0b. Por ejemplo: 0b110, 0b11</li> <li>Octal. Deben empezar con 0o. Por ejemplo: 0o13, 0o7</li> <li>Hexadedicmal. Deben empezar con 0x. Por ejemplo 0x13, 0xFF</li> <li>Coma flotante. Contienen el punto decimal. Por ejemplo 10.2, 3.14</li> <li> <p>Complejo. Tienen la forma <code>a + bj</code>. Por ejemplo: 3 - 2j, -4 + j</p> </li> <li> <p>Booleanos</p> </li> </ul> <p>Solamente hay dos literales booleanos <code>True</code> y <code>False</code></p> <ul> <li>Cadenas de caracteres</li> </ul> <p>Los literales de caracteres son caracteres unicode encerrados entre comillas, por ejemplo <code>S</code>. Los literales cadenas de caracteres son cadenas de csaracteres encerradas entre comillas, por ejemplo <code>Python es divertido</code>.</p> <ul> <li>Especiales</li> </ul> <p>En Python existe un literal especial, <code>None</code>. Podemos usarlo, por ejemplo, para especificar una variable nula, por ejemplo:</p> <pre><code>var = None\nprint(var)\n# El resultado ser\u00e1: None\n</code></pre>"},{"location":"guias/intro/#tipos-de-datos-en-python","title":"Tipos de datos en Python","text":"<p>En Python, al igual que en programaci\u00f3n en general, los tipos de datos especifican el tipo de datos que puede almacenarse en una variable.</p>"},{"location":"guias/intro/#numericos","title":"Num\u00e9ricos","text":"<p>Contienen valores num\u00e9ricos y sabemos que:</p> <ul> <li>Los n\u00fameros enteros son de tipo int</li> <li>Los fraccionarios son de tipo float</li> <li>La divisi\u00f3n (/) siempre devuelve un n\u00famero en coma flotante</li> <li>Para obtener la parte entera de una divisi\u00f3n se usa el operador //</li> <li>Para calcular el resto de una divisi\u00f3n se usa el operador %</li> <li>Para calcular potencias podemos usar el operador **</li> <li>Los par\u00e9ntesis se pueden usar para agrupar expresiones</li> <li>El signo igual (=) se utiliza para asignar un valor (n\u00fameros, booleanos, cadenas, \u2026) a una variable</li> <li>El tipo de la variable ser\u00e1 el del dato asignado, no se declara el tipo de la variable al crearla</li> <li>Por convenci\u00f3n el nombre comienza en min\u00fascula y si son varias palabras se unen por gui\u00f3n bajo</li> </ul> <p>Los tipos b\u00e1sicos de datos son:</p> <ul> <li><code>int</code>: n\u00fameros enteros con signo sin l\u00edmite de tama\u00f1o, ejemplo: entero = 5</li> <li><code>float</code>: n\u00fameros reales, decimales o de coma flotante con precisi\u00f3n de hasta 15 decimales, ejemplo: real = 5.6</li> <li><code>complex</code>: n\u00fameros complejos, por ejemplo 5.5 - 5j</li> <li>Para averiguar el tipo de dato usamos la funci\u00f3n <code>type()</code>.</li> </ul> <p>Podemos realizar conversi\u00f3n de tipos as\u00ed:</p> <ul> <li>A entero int(variable)</li> <li>A real float(variable)</li> </ul>"},{"location":"guias/intro/#cadenas","title":"Cadenas","text":"<p>Contienen secuencias de caracteres. Una cadena es una secuencia de caracteres representada entre comillas simples o dobles.</p> <p>Las cadenas pueden estar encerradas entre comillas simples ('...') o dobles (\"...\") con el mismo resultado. Podemos usar  para incluir comillas en una cadena.</p> <p>La funci\u00f3n print() devuelve la cadena que encierra entre los par\u00e9ntesis, omitiendo las comillas que la encierran.</p> <p>En la imagen siguiente se ven varios ejemplos con cadenas utilizando como editor el IDLE que por defecto se instala con Python y que se abre desde una terminal simplemente invocando a Python.</p> <p> <p> Cadenas en el IDLE</p> <p></p> <p>Una cadena raw (cruda) se interpreta tal como se escribe, es decir, se omiten los caracteres especiales expresados con . Las cadenas raw se escriben entrecomilladas y van precedidas del car\u00e1cter 'r'. En la imagen vemos un ejemplo.</p> <p> <p> Cadena cruda en el IDLE</p> <p></p> <p>Es posible aplicar la operaci\u00f3n de multiplicar a textos haciendo que estos se repitan. En la imagen siguientes vemos ejemplos de concatenaci\u00f3n y multiplicaci\u00f3n, as\u00ed como un error cometido.</p> <p> <p> Concatenar y multiplicar textos en el IDLE</p> <p></p>"},{"location":"guias/intro/#secuencias","title":"Secuencias","text":"<p>Contienen colecciones de datos, como las listas, las tuplas, las colecciones de datos (set) o los diccionarios.</p> <p>Una lista es una colecci\u00f3n ordenada de elementos similares o de distinto tipo separados por comas y encerrados entre corchetes [ ].</p> <p>Tupla es una secuencia ordenada de elementos, igual que una lista. La \u00fanica diferencia es que las tuplas son inmutables. Una vez creadas, las tuplas no pueden modificarse. En Python, se utilizan los par\u00e9ntesis () para almacenar los elementos de una tupla.</p> <p>Las colecciones de datos son un conjunto desordenada de elementos \u00fanicos. Una colecci\u00f3n de datos se define por valores separados por comas dentro de llaves { }.</p> <p>Un diccionario es una colecci\u00f3n ordenada de elementos. Almacena los elementos como pares clave/valor. Siendo las claves identificadores \u00fanicos que se asocian a cada valor.</p> <p>Estudiaremos estos \u00faltimos tipos mas extensamente cuando los necesitemos.</p> <p>Los datos de tipo booleano solamente pueden contener <code>True</code> o <code>False</code>.</p> <p>Dado que en programaci\u00f3n Python todo es un objeto, los tipos de datos son en realidad clases y las variables son instancias(objeto) de estas clases.</p>"},{"location":"guias/intro/#comentarios-en-python","title":"Comentarios en Python","text":"<ul> <li> <p>Una sola linea: Escribiendo el s\u00edmbolo almohadilla (#) delante del comentario.</p> </li> <li> <p>Multilinea: Escribiendo triple comillas dobles (\u201c\u201d\u201d) al principio y al final del comentario.</p> </li> </ul> <p>En los comentarios, pueden incluirse palabras que nos ayuden a identificar adem\u00e1s, el subtipo de comentario:</p> <pre><code># TODO esto es algo por hacer\n# FIXME (arreglarme) esto es algo que debe corregirse\n# XXX esto tambi\u00e9n, es algo que debe corregirse\n</code></pre>"},{"location":"guias/intro/#identation-o-sangria-en-python","title":"Identation o sangria en Python","text":"<p>La sangr\u00eda se refiere a los espacios al comienzo de una l\u00ednea de c\u00f3digo.</p> <p>Mientras que en otros lenguajes de programaci\u00f3n la sangr\u00eda en el c\u00f3digo es solo para facilitar la lectura, la sangr\u00eda en Python es muy importante ya que se usa para indicar un bloque de c\u00f3digo.</p> <pre><code>if 5 &gt; 2:\n    print(\"Cinco es mayor que 2\")\n</code></pre> <p>Lo siguiente ser\u00eda un error de sintaxis.</p> <pre><code>if 5 &gt; 2:\nprint(\"Cinco es mayor que 2\")\n</code></pre> <p>El n\u00famero de espacios de la identation puede ser cualquiera siempre que al menos sea un espacio. Siempre hay que usar el mismo n\u00famero de espacios en el mismo bloque de c\u00f3digo.</p>"},{"location":"guias/intro/#operadores-en-python","title":"Operadores en Python","text":"<p>Los operadores son s\u00edmbolos especiales que realizan operaciones con variables y valores.</p> <p>A continuaci\u00f3n tenemos una lista de los diferentes tipos de operadores de Python:</p> <ul> <li>Operadores aritm\u00e9ticos</li> <li>Operadores de asignaci\u00f3n</li> <li>Operadores de Comparaci\u00f3n</li> <li>Operadores L\u00f3gicos</li> <li>Operadores Bitwise</li> <li>Operadores especiales</li> </ul>"},{"location":"guias/intro/#operadores-aritmeticos","title":"Operadores aritm\u00e9ticos","text":"<p>Los operadores aritm\u00e9ticos se utilizan para realizar operaciones matem\u00e1ticas como sumas, restas, multiplicaciones, etc.</p> <p> Operador Descripci\u00f3n Ejemplo + Suma o concatenaci\u00f3n en textos <code>5+3=8</code>, <code>\"Hola\" + \"Mundo\" = \"Hola Mundo</code> - Diferencia <code>6-3=3</code> * Multiplicaci\u00f3n <code>3*3=9</code> / Divisi\u00f3n <code>6/2=3</code> // Parte entera de un cociente <code>10//3=3</code> % Resto de un cociente <code>10%3=1</code> ** Potenciaci\u00f3n <code>5**2=25</code> <p></p>"},{"location":"guias/intro/#operadores-de-asignacion","title":"Operadores de asignaci\u00f3n","text":"<p>Los operadores de asignaci\u00f3n se utilizan para asignar valores a variables.</p> <p> Operador Descripci\u00f3n Ejemplo = Asignaci\u00f3n <code>x=4</code>, <code>a = a + 1</code> += Suma y asignaci\u00f3n <code>x+=1</code> equivale a <code>x = x + 1</code> -= Diferencia y asignaci\u00f3n <code>x-=1</code> equivale a <code>x = x - 1</code> *= Multiplicaci\u00f3n y asignaci\u00f3n <code>x*=3</code> equivale a <code>x = x * 3</code> /= Divisi\u00f3n y asignaci\u00f3n <code>x/=3</code> equivale a <code>x = x / 3</code> %= Asignaci\u00f3n de restos <code>x%=3</code> equivale a <code>x = x % 3</code> **= Asignaci\u00f3n de exponentes <code>x**=3</code> equivale a <code>x = x ** 3</code> <p></p>"},{"location":"guias/intro/#operadores-de-comparacion","title":"Operadores de Comparaci\u00f3n","text":"<p>Los operadores de comparaci\u00f3n comparan dos valores/variables y devuelven un resultado booleano: Verdadero o Falso <code>True</code> o <code>False</code>.</p> <p> Operador Descripci\u00f3n Ejemplo == Igual a <code>2==3</code> retorna <code>False</code> != Distinto de <code>2!=3</code> retorna <code>True</code> &lt; Menor que <code>2&lt;3</code> retorna <code>True</code> &gt; Mayor que <code>2&gt;3</code> retorna <code>False</code> &lt;= Menor o igual que <code>2&lt;=3</code> retorna <code>True</code> &gt;= Mayor o igual que <code>2&gt;=3</code> retorna <code>False</code> <p></p>"},{"location":"guias/intro/#operadores-logicos","title":"Operadores L\u00f3gicos","text":"<p>Los operadores l\u00f3gicos se utilizan para comprobar si una expresi\u00f3n es Verdadera o Falsa. Se utilizan en la toma de decisiones.</p> <p> Operador Descripci\u00f3n Ejemplo and AND l\u00f3gica <code>a and b #True si a y b son ciertos</code> or OR l\u00f3gica <code>a or b #True si a o b son ciertos</code> not NOT l\u00f3gica <code>not a #True si el operador a es falso</code> <p></p> <p>En la figura siguiente vemos un ejemplo con lo que devuelve en cada caso.</p> <p> <p> Ejemplos en el IDLE de operadores l\u00f3gicos</p> <p></p>"},{"location":"guias/intro/#operadores-bitwise","title":"Operadores Bitwise","text":"<p>Los operadores bit a bit o bitwise act\u00faan sobre los operandos como si fueran cadenas de d\u00edgitos binarios. Operan bit a bit, de ah\u00ed su nombre.</p> <p> Operador Descripci\u00f3n Ejemplo &amp; AND bit a bit <code>5&amp;6 # 101 &amp; 110 = 110 = 4</code> | OR bit a bit <code>5 \\| 6 # 101 \\| 110 = 111 = 7</code> ~ NOT bit a bit <code>~3 # ~011 = 100 = -4</code> ^ XOR bit a bit <code>5^3 # 101^011 = 110 = 6</code> &lt;&lt; Desplazamiento izquierda <code>4&lt;&lt;1 # 100 &lt;&lt; 1 = 1000 = 8</code> &gt;&gt; Desplazamiento derecha <code>4 &gt;&gt; 1 # 100 &gt;&gt; 1 = 010 = 2</code> <p></p>"},{"location":"guias/intro/#operadores-especiales","title":"Operadores especiales","text":"<p>El lenguaje Python ofrece algunos tipos especiales de operadores como el operador de identidad (<code>identity</code>) y el operador de pertenencia (<code>membership</code>).</p> <ul> <li>Operadores <code>identity</code></li> </ul> <p>En Python, <code>is</code> e <code>is not</code> se utilizan para comprobar si dos valores se encuentran en la misma parte de la memoria. Dos variables que son iguales no implica que sean id\u00e9nticas. Algunos ejemplos aclaran mejor lo dicho.</p> <pre><code>x1 = 5\ny1 = 5\nx2 = 'Hello'\ny2 = 'Hello'\n\nprint(x1 is not y1)  # False\n\nprint(x2 is y2)  # True\n</code></pre> <p>Vemos que x1 e y1 son enteros con los mismos valores, por lo que son iguales e id\u00e9nticos. Lo mismo ocurre con x2 e y2 (cadenas).</p> <ul> <li>Operadores <code>membership</code></li> </ul> <p>En Python, <code>in</code> y <code>not in</code> son los operadores de pertenencia. Se utilizan para comprobar si un valor o variable se encuentra en una secuencia (cadena, lista, tupla, conjunto y diccionario).</p> <p>En un diccionario s\u00f3lo podemos comprobar la presencia de la clave, no del valor.</p>"},{"location":"guias/mblocks/","title":"Microblocks","text":"<p>MicroBlocks es una herramienta de programaci\u00f3n por bloques basada en Snap!. Se trata de un software que puede trabajar online o localmente y que nos va a permitir programar diferentes placas, entre ellas la micro:bit.</p> <p> <p> Logotipo de MicroBlocks</p> <p>Logotipo descargado de la entrada en SAP de Kathy Giori  titulada Recap of \u201cSneak Preview into MicroBlocks\u201d.</p> <p></p> <p>MicroBlocks es un lenguaje de programaci\u00f3n por bloques similar a Scratch que es una excelente herramienta para aprender desde nivel principiante hasta nivel experto y v\u00e1lido para edades que van desde los 8 hasta los 99 a\u00f1os.</p> <p>En el apartado Get Started de su web tenemos descrito como trabajar desde un navegador y los distintos sistemas operativos as\u00ed como los pasos a seguir para configurar nuestra placa y como comenzar a crear programas.</p> <p>En esta ocasi\u00f3n vamos a trabajar de forma local descargando e instalando el programa en nuestro ordenador. En mi caso trabajar\u00e9 con Linux de 64 bits instalando el paquete debian descargado 'ublocks-amd64.deb'. La forma elegida para instalarlo, suponiendo que el paquete est\u00e1 en Descargas, es:</p> <pre><code>sudo dpkg -i ~/Descargas/ublocks-amd64.deb\n</code></pre> <p>Tras la instalaci\u00f3n verificamos que todo est\u00e1 correcto y que Linux ve la placa ejecutando en una terminal lo que vemos en la imagen siguiente.</p> <p> <p> Verificaci\u00f3n de conexi\u00f3n con micro:bit en Linux</p> <p></p> <p>En el enlace Mis notas sobre Linux trabajando con Ubuntu tenemos un par de entradas que describen problemas con el paquete brltty (Braille TTY). En el caso de placas con un chip microcontrolador de la serie USB CP210x, algunas de ellas compatibles con MicroBlocks. Si tenemos este caso el problema se puede resolver eliminando el paquete BRLTTY.</p> <pre><code>sudo apt remove brltty\n</code></pre> <p>El programa una vez instalado lo tenemos disponible en aplicaciones, como vemos en la imagen siguiente.</p> <p> <p> App MicroBlocks disponible</p> <p></p>"},{"location":"guias/mblocks/#por-que-usar-microblocks","title":"\u00bfPor qu\u00e9 usar MicroBlocks?","text":"<p>MicroBlocks tiene una caracter\u00edstica que lo distingue de otros lenguajes de programaci\u00f3n por bloques y es que la programaci\u00f3n real ocurre seg\u00fan se desarrolla el programa, lo que podemos denominar como programaci\u00f3n en directo o en vivo y, debido a esto, que implica que el c\u00f3digo se descarga seg\u00fan se escribe tenemos la otra caracter\u00edstica que le dota de independencia o autonom\u00eda, ya que cuando demos el programa por bueno, este ya est\u00e1 grabado como firmware en la placa.</p> <p>Otra de la caracter\u00edsticas importantes que ofrece MicroBlocks es la multitarea o posibilidad de desarrollar funcionalidades que trabajan de forma paralela y separada cada tarea. Por ejemplo, reproducir un sonido mientras se controla un servomotor. Esta forma de trabajo hace que el c\u00f3digo sea mas sencillo de escribir y de entender.</p> <p>Cuando trabajamos con MicroBlocks la placa que conectemos se comporta como una tarjeta de memoria. No hay necesidad de leer un archivo de proyecto, simplemente conectamos la placa y el script o programa nos aparecer\u00e1 en el IDE. Es decir, MicroBlocks lee el programa que hay en la placa y lo carga de manera autom\u00e1tica.</p> <p>El funcionamiento de MicroBlocks se basa en:</p> <ul> <li>El editor de bloques o IDE que se puede ejecutar online o de manera local.</li> <li>Una m\u00e1quina virtual que se ejecuta en la placa microcontroladora. Esta m\u00e1quina virtual es la encargada de ejecutar el programa de usuario y lo hace compilando en c\u00f3digo de bytes o instrucciones de bajo nivel muy parecidas al c\u00f3digo m\u00e1quina. Si tenemos habilitados los bloques avanzados podemos ver los bytes generados por el programa, como vemos en la animaci\u00f3n siguiente:</li> </ul> <p> <p> C\u00f3digo de bytes</p> <p></p> <p>La parte m\u00e1s importante de la informaci\u00f3n de bytes es la primera l\u00ednea, que muestra el n\u00famero de bytes compilados. Los scripts en MicroBlocks no deben superar los 1000 bytes, de ah\u00ed la importancia de esta informaci\u00f3n.</p> <ul> <li>El sistema de comunicaci\u00f3n entre la placa y el host remoto o el ordenador que hace que el firmware se actualice seg\u00fan se escribe el programa. Este sistema es el encargado de enviar los bytes y comandos para iniciar el programa y procesar mensajes del microcontrolador. As\u00ed el editor proporciona realimentaci\u00f3n gr\u00e1fica de lo que sucede en el microcontrolador y directamente puede mostrar valolres en un \"bocadillo de conversaci\u00f3n\" como el de la figura siguiente.</li> </ul> <p> <p> Bocadillo de conversaci\u00f3n</p> <p></p> <p>MicroBlocks tambi\u00e9n dispone de una herramienta de representaci\u00f3n gr\u00e1fica que estudiaremos en su momento.</p> <p>Una funcionalidad importante del editor es que, adem\u00e1s de programar por bloques, administra las Librerias, que est\u00e1n escritas en MicroBlocks. Existen muchas que iremos viendo poco a poco. Las librerias escritas en MicroBlocks pueden ser editadas por los usuarios.</p>"},{"location":"guias/mblocks/#configuracion-del-equipo","title":"Configuraci\u00f3n del equipo","text":"<p>Necesitamos un ordenador (\u00a1no un dispositivo m\u00f3vil!) con un puerto USB, un cable USB y una placa soportada. Podemos ejecutar MicroBlocks en un navegador Chromium, Chrome o Edge, o descargarlo como una aplicaci\u00f3n independiente para Linux, Chromebook, Windows o MacOS. Las placas soportadas son:</p> <ul> <li>BBC micro:bit v1 y v2</li> <li>Calliope mini</li> <li>Circuit Playground Express y Bluefruit</li> <li>Citilab ED1</li> <li>Raspberry Pi Pico and Pico W</li> <li>Adafruit Clue</li> <li>M5Stack Core Grey</li> <li>ESP8266 y ESP32</li> </ul> <p>Los instaladores est\u00e1n disponibles para las versiones liberadas listas para descargar la apropiada para nuestro sistema operativo. Si estamos trabajando con Chrome o Edge es muy posible que nos advierta de que estamos descargando un archivo que podr\u00eda da\u00f1ar nuestro ordenador. Debemos ignorar esta y sucesivas advertencias para proceder con la descarga.</p> <p>En Linux se descarga un paquete .deb, ublocks-amd64.deb en concreto para esta ocasi\u00f3n que se instala de forma muy sencilla. Con una terminal abierta en el directorio donde est\u00e1 el archivo .deb tecleamos:</p> <pre><code>dpkg -i ~/Descargas/ublocks-amd64.deb\n</code></pre> <p>Tras breves instantes el programa estar\u00e1 instalado y lo tendremos disponible en aplicaciones, como ya hemos visto antes.</p>"},{"location":"guias/mblocks/#configuracion-de-la-placa","title":"Configuraci\u00f3n de la placa","text":"<p>El proceso de configuraci\u00f3n de las placas soportadas es muy similar en todas ellas y es seguir el proceso que vamos a ver a continuaci\u00f3n. En este caso particular se toman las im\u00e1genes y animaciones realizando el proceso con una micro:bit V2.21.</p> <p>Conectamos la placa al ordenador y en el men\u00fa de MicroBlocks hacemos clic en el engranaje y seleccionamos la opci\u00f3n 'actualizar firmware de la placa'.</p> <p> <p> Actualizar firmware de la placa</p> <p></p> <p>En el men\u00fa de la ventana emergente tenemos que seleccionar el tipo de placa que hemos conectado.</p> <p> <p> Seleccionar placa</p> <p></p> <p>Si estamos trabajando con MicroBlocks en un navegador, se nos pedir\u00e1 que seleccionemos la placa si a\u00fan no est\u00e1 conectada.</p> <p>Si no hay una placa conectada aparecer\u00e1 el siguiente aviso.</p> <p> <p> No puedo abrir puerto serie</p> <p></p> <p>Si todo est\u00e1 correcto el icono del puerto USB pasa a estar acompa\u00f1ado de un c\u00edrculo verde que indica la conexi\u00f3n.</p> <p> <p> Conexi\u00f3n por puerto serie realizada</p> <p></p> <p>En este video del canal Youtube de MicroBlocks Fun titulado Quick introduction to MicroBlocks for programming a micro:bit (Introducci\u00f3n r\u00e1pida a MicroBlocks para programar un micro:bit) tenemos una introducci\u00f3n r\u00e1pida a MicroBlocks con micro:bit.</p> <p>La informaci\u00f3n en ingl\u00e9s de la guia de usuario y el manual de referencia de bloques tambi\u00e9n pueden resultarnos de gran ayuda.</p>"},{"location":"guias/mblocks/#actualizar-firmware-en-esp32","title":"Actualizar firmware en ESP32","text":"<p>Los dispositivos ESP son una categor\u00eda especial de Espressif que cuentan con capacidad WIFI. En estas placas se borra totalmente el contenido de la memoria flash de la placa y se carga el firmware m\u00e1s reciente. Tras seleccionar ESP32 se inicia la actualizaci\u00f3n del firmware y aparece informaci\u00f3n del progreso en la pantalla.</p> <p> <p> Actualizar firmware en ESP32</p> <p></p>"},{"location":"guias/mblocks/#habilitardeshabilitar-autocarga-de-librerias","title":"Habilitar/deshabilitar autocarga de librerias","text":"<p>Una de las cosas buenas del editor MicroBlocks es que siempre trata de simplificar las cosas a los usuarios. Dado que cada placa con microcontrolador tiene diferentes caracter\u00edsticas, funciones y capacidades, MicroBlocks intenta de forma autom\u00e1tica complementar las funcionalidades b\u00e1sicas cargando las bibliotecas que estime necesarias, siempre que la opci\u00f3n est\u00e9 habilitada, que se distinguir\u00e1 porque la opci\u00f3n disponible es desactivar.</p> <p> <p> Autocarga de librerias activada</p> <p></p> <p>Cuando se selecciona, este elemento se deshabilita esta funcionalidad y depende del usuario cargar las bibliotecas requeridas.</p> <p> <p> Autocarga de librerias desactivada</p> <p></p>"},{"location":"guias/mblocks/#habilitardeshabilitar-plugshare","title":"Habilitar/deshabilitar PlugShare","text":"<p>Otra caracter\u00edstica muy interesante del editor de MicroBlocks es que cargar\u00e1 autom\u00e1ticamente un proyecto desde el microcontrolador conecvtado, si no hay otro proyecto cargado en el editor. La activaci\u00f3n y desactivaci\u00f3n de la opci\u00f3n es id\u00e9ntica a la de la carga de librer\u00edas. Si la opci\u00f3n muestra desactivar es que est\u00e1 habilitada por lo que el editor leer\u00e1 el proyecto desde el dispositivo y luego proceder\u00e1 a cargarlo en el editor. Si la opci\u00f3n muestra activar es que la funcionalidad no est\u00e1 habilitada.</p> <p>Esta funci\u00f3n es muy importante porque permite a los usuarios compartir proyectos simplemente intercambiando sus dispositivos f\u00edsicos y conect\u00e1ndolos a un ordenador. No hay que compartir archivos.</p> <p>Podr\u00edamos denominar a esta funcionalidad como \"conecta y comparte\".</p> <p> <p> PlugShare activado</p> <p></p>"},{"location":"guias/mblocks/#descripcion-general","title":"Descripci\u00f3n general","text":"<p>En la imagen siguiente vemos los nombres de las distintas partes que componen el editor de MicroBlocks.</p> <p> <p> Partes del editor</p> <p></p> <ul> <li>Bloques. Los bloques est\u00e1n organizados por categorias codificadas por colores. Cuando se selecciona una categor\u00eda se despliegan los correspondientes a esa categoria en la zona denominada paleta de bloques. En la wiki de MicroBlocks podemos encontrar una referencia completa a los bloques (Block Reference) con multitud de ejemplos resueltos.</li> <li>Barra de men\u00fas. Contiene, de izquierda a derecha, el icono en forma de globo terraqueo para configurar el idioma, la rueda dentada para entrar en opciones de MicroBlocks, la hoja de papel que muestra el men\u00fa archivo, el gr\u00e1fico es un men\u00fa con opciones de graficar y conectar y el conector USB para el men\u00fa conectar.</li> <li>Nombre del proyecto. Es el nombre del proyecto actual.</li> <li>Botones de inicio/parada. Son dos iconos que sirven para controlar la ejecuci\u00f3n de los programas.</li> <li>Librerias. Aqu\u00ed se muestran las diversas bibliotecas que se cargan seg\u00fan sea requerido.</li> <li>\u00c1rea de bloques de programa. Es donde se crea el programa o script de usuario y las funciones, que en MicroBlocks se conocen como bloques personalizados.</li> <li>Barra de informaci\u00f3n. Si vamos moviendo el rat\u00f3n por los diversos bloques y \u00e1reas del IDE en esta barra se muestra el tipo de bloque y una breve informaci\u00f3n de ayuda sobre los bloques; as\u00ed como la funcionalidad de las distintas \u00e1reas. La informaci\u00f3n detallada del bloque est\u00e1 disponible a trav\u00e9s del men\u00fa contextual de cada bloque.</li> <li>Controles tama\u00f1o bloques. Estos tres controles permiten cambiar el tama\u00f1o de los bloques aumentando (+) o disminuyendo (-), as\u00ed como establecerlos en el tama\u00f1o predeterminado o del 100% de zoom (=).</li> </ul>"},{"location":"guias/mblocks/#idioma","title":"Idioma","text":"<p>En la imagen siguiente vemos el men\u00fa desplegado.</p> <p> <p> Idioma</p> <p></p> <p>Simplemente tenemos que seleccionar el idioma deseado de entre los que est\u00e1 traducido MicroBlocks. Esto configura todos los men\u00fas, mensajes y bloques de c\u00f3digo en ese idioma. La operaci\u00f3n puede demorarse unos segundos dependiendo del equipo en el que se est\u00e9 ejecutando el programa.</p>"},{"location":"guias/mblocks/#microblocks_1","title":"MicroBlocks","text":"<p>En la figura siguiente vemos este men\u00fa desplegado.</p> <p> <p> MicroBlocks</p> <p></p> <ul> <li>La opci\u00f3n 'acerca de...' nos muestra la informaci\u00f3n sobre MicroBlocks que vemos en la imagen siguiente.</li> </ul> <p> <p> acerca de...</p> <p></p> <ul> <li>Actualizar el firmware de la placa es lo que permite al usuario cargar la \u00faltima versi\u00f3n del firmware en la placa conectada. Dependiendo de los dispositivos conectados y de las condiciones se puede desplegar un men\u00fa para seleccionar el dispositivo concreto. Es la opci\u00f3n que utilizaremos para grabar los programas en la placa.</li> <li>Mostrar bloques avanzados modifica el men\u00fa MicroBlocks mostrando mas opciones, como vemos en la imagen siguiente.</li> </ul> <p> <p> Bloques avanzados</p> <p></p> <ul> <li>La opci\u00f3n versi\u00f3n de firmware nos devuelve la versi\u00f3n de firmware de la m\u00e1quina virtual para micro:bit, como vemos en la imagen siguiente.</li> </ul> <p> <p> versi\u00f3n de firmware</p> <p></p> <ul> <li>La opci\u00f3n borra y reparticiona el firmware en placa ESP borra totalmente el contenido de la memoria y carga el programa actual en placas con capacidad EiFi tipo ESP.</li> <li>La opci\u00f3n inicia el servidor HTTP. Activa (o desactiva si est\u00e1 activo) el servidor HTTP de MicroBlocks en el puerto por defecto 6473, aunque este puede ser cambiado.</li> <li>La opci\u00f3n desactiva autocarga de librerias de placa permite desabilitar la funcionalidad de MicroBlocks de que intente autom\u00e1ticamente complementar las funcionalidades b\u00e1sicas del dispositivo conectado cargando varias bibliotecas.</li> <li>La opci\u00f3n activar PlugShare en proyecto en blanco es una funci\u00f3n que si est\u00e1 habilitada hace que el editor de MicroBlocks cargue autom\u00e1ticamente un proyecto desde el microdispositivo conectado, siempre que no haya un proyecto cargado en el editor. Si el \u00edcono de conexi\u00f3n no es verde y est\u00e1 habilitado PlugShare cuando estamos en un proyecto vac\u00edo, tan pronto como se establezca la conexi\u00f3n USB, MicroBlocks leer\u00e1 y cargar\u00e1 el proyecto que contiene el dispositivo conectado.</li> <li>La opci\u00f3n oculta los bloques avanzados devuelve al men\u00fa MicroBlocks a su estado por defecto, que es la opci\u00f3n mas habitual.</li> </ul>"},{"location":"guias/mblocks/#archivo","title":"Archivo","text":"<p>En la figura siguiente vemos este men\u00fa desplegado.</p> <p> <p> Archivo</p> <p></p> <ul> <li>Guarda. Cuando demos por finalizado un proyecto, o tengamos que dejarlo para otro momento sin perder el trabajo realizado, debemos guardarlo en el ordenador. Se nos abrir\u00e1 una ventana como la de la imagen siguiente.</li> </ul> <p> <p> Guarda fichero</p> <p></p> <ul> <li>Nuevo. Para crear nuevos proyectos. Si tenemos un programa cargado en el \u00e1rea de trabajo del editor, mostrar\u00e1 un mensaje solicitando confirmaci\u00f3n para eliminar del editor el proyecto activo. En la imagen siguiente vemos el mensaje.</li> </ul> <p> <p> Confirmacion</p> <p></p> <p>Si la contestaci\u00f3n es 'Si' el \u00e1rea de trabajo queda vac\u00eda y las bibliotecas a\u00f1adidas por el usuario se borran.</p> <ul> <li>Abre. Esta opci\u00f3n permite cargar en el editor proyectos .ubp previamente guardados. Si hay un proyecto cargado en el \u00e1rea de trabajo, se mostrar\u00e1 un mensaje de confirmaci\u00f3n (igual que en Nuevo) y se presenta una ventana de di\u00e1logo que permite localizar y abrir el archivo deseado. En la imagen siguiente vemos esta ventana.</li> </ul> <p> <p> Di\u00e1logo abrir fichero</p> <p></p> <p>En la categor\u00eda Ejemplos es donde se presentan muchos proyectos de MicroBlocks para diferentes microdispositivos y opciones de hardware.</p> <ul> <li>Copia URL del proyecto al portapapeles. Cuando trabajamos online permite compartir el proyecto.</li> </ul>"},{"location":"guias/mblocks/#conectar","title":"Conectar","text":"<p>En la figura siguiente vemos este men\u00fa desplegado. En esta ocasi\u00f3n hay un dispositivo ya conectado y por eso se muestra la opci\u00f3n disconnect (/dev/ttyACM0).</p> <p> <p> Conectar</p> <p></p> <p>Si tenemos varios dispositivos conectados a puertos USB se nos mostrar\u00e1n los mismos para que podamos escoger el dispositivo que nos interesa. Al seleccionar uno y hacer clic en Conectar se establecer\u00e1 una conexi\u00f3n con el dispositivo correspondiente. Si la conexi\u00f3n tiene \u00e9xito, el \u00edcono USB cambiar\u00e1 a uno con un fondo circular verde, como vemos en la imagen siguiente.</p> <p> <p> Conectado</p> <p></p> <p>Es importante prestar atenci\u00f3n al estado de este icono. MicroBlocks ejecuta muchos procesos internos automatizados y la actualizaci\u00f3n y sincronizaci\u00f3n autom\u00e1tica del c\u00f3digo del proyecto en el dispositivo conectado es uno de ellos, pero esto solo es posible cuando el \u00edcono est\u00e1 en modo verde.</p> <p>Existen diversas razones por las que la conexi\u00f3n puede interrumpirse. Cuando esto ocurre el icono dejar\u00e1 de estar verde y debemos buscar el motivo de la desconexi\u00f3n.</p>"},{"location":"guias/mblocks/#botones-de-inicioparada","title":"Botones de inicio/parada","text":"<p>MicroBlocks siempre est\u00e1 en conexi\u00f3n; se puede hacer clic en bloques o secuencias de comandos individuales para ejecutarlos sin hacer clic en el bot\u00f3n de 'Inicio'.</p> <p>La funci\u00f3n principal del bot\u00f3n 'Inicio' es simular el encendido del dispositivo iniciando todas las secuencias de comandos.</p> <p>El bot\u00f3n 'STOP' detiene la ejecuci\u00f3n del proyecto. Todas las variables son desasignadas. Todos los scripts se detienen.</p> <p>El proyecto cargado en el dispositivo estar\u00e1 en el mismo hasta nueva grabaci\u00f3n de firmware. De hecho, podemos desconectarlo, encenderlo desde una fuente externa y ejecutar el proyecto sin el editor.</p>"},{"location":"guias/mblocks/#programando","title":"Programando","text":"<p>Dado que es la parte en la que mas se trabaja, la creaci\u00f3n de programas, la vemos en su propio apartado.</p> <p>Los bloques colocados en el \u00e1rea de trabajo los podemos mover a voluntad con el rat\u00f3n, as\u00ed como con los men\u00fas contextuales que aparecen al pulsar el bot\u00f3n derecho. Existen una serie de atajos asociados a las teclas Ctrl y Shift que se ir\u00e1n viendo.</p>"},{"location":"guias/mblocks/#arrastrar-y-soltar","title":"Arrastrar y soltar","text":"<p>El movimiento de arrastrar y soltar es el habitual de entornos de programaci\u00f3n por bloques y adem\u00e1s resulta muy intuitivo. Lo nuevo en Microblocks es que mientras se arrastra aparece una sombra paralela que pretende crear un efecto 3D de que el bloque en movimiento va flotando sobre el \u00e1rea de trabajo, incluso por encima del resto de bloques.</p> <p> <p> Sombra paralela</p> <p></p>"},{"location":"guias/mblocks/#acoplar-bloques","title":"Acoplar bloques","text":"<p>Cuando nos acercamos con un bloque o un conjunto de bloques a otro u otros bloques, aparecer\u00e1 una l\u00ednea blanca blanca horizontal que designa un punto de acople.</p> <p> <p> L\u00ednea blanca mostrando punto de acople</p> <p></p> <p>Si soltamos el bot\u00f3n del rat\u00f3n cuando se ve esa l\u00ednea blanca el bloque o bloques se acoplar\u00e1n a los del otro lado de la l\u00ednea.</p>"},{"location":"guias/mblocks/#menu-contextual-de-bloques","title":"Men\u00fa contextual de bloques","text":"<p>Si situamos el cursor sobre un bloque que est\u00e1 en un grupo de bloques y hacemos clic con el bot\u00f3n secundario o derecho, nos aparece un men\u00fa contextual.</p> <p> <p> Men\u00fa contextual en bloques</p> <p></p> <p>Este men\u00fa contextual ofrece mas opciones si hemos seleccionado 'Mostrar bloques avanzados'.</p> <p> <p> Men\u00fa contextual en bloques avanzados</p> <p></p> <ul> <li>Copiar en el portapapeles. Es una operaci\u00f3n que crea una copia de los conjuntos de bloques seleccionados en el portapapeles. Estos se pueden pegar dentro del mismo proyecto o en un proyecto diferente. Tambi\u00e9n es posible copiar/pegar entre el editor online y el local.</li> <li>Copiar al Portapapeles como URL. Esta caracter\u00edstica se utiliza principalmente para incorporar programas MicroBlocks en p\u00e1ginas web, ya que el formato est\u00e1 codificado como URL.</li> </ul>"},{"location":"guias/mblocks/#menu-contextual-de-area-de-trabajo","title":"Men\u00fa contextual de \u00e1rea de trabajo","text":"<p>Es el men\u00fa contextual que aparece cuando hacemos un clic derecho sobre cualquier zona vac\u00eda del \u00e1rea de trabajo.</p> <p> <p> Men\u00fa contextual en \u00e1rea de trabajo</p> <p></p> <ul> <li>tama\u00f1o de bloques. Cuando se selecciona nos muestra una lista con porcentajes para escoger est\u00e1ndo tildado el valor actual.</li> <li>deshaz el \u00faltimo movimiento. Invierte el \u00faltimo movimiento de bloque completado.</li> <li>limpia. Organiza los conjuntos y los bloques sueltos en la pantalla en una disposici\u00f3n de arriba hacia abajo y de izquierda a derecha desde el lado izquierdo del \u00e1rea de trabajo. Los bloques se organizan en m\u00faltiples columnas determinadas por el ancho del \u00e1rea IDE. \u00a1Esta operaci\u00f3n no se puede deshacer!</li> <li>copia todos los programas al portapapeles. Es la pareja de copiar al portapapeles. Mientras que el primero solamente copia el bloque o el programa, este copia todos los programas del proyecto.</li> <li>copia todos los programas al portapapeles como URL. Es lo mismo que el visto anteriormente.</li> <li>guarda una imagen de todos los programas visibles. Es la versi\u00f3n complementaria de la vista en el men\u00fa contextual de bloques.</li> <li>fija la escala de la imagen a exportar. Al seleccionarla nos muestra una lista con porcentajes para escoger est\u00e1ndo tildado el valor actual.</li> </ul>"},{"location":"guias/mblocks/#crear-un-programa","title":"Crear un programa","text":"<p>Por defecto, al iniciar Microblocks aunque se haga con la micro:bit conectada, no tendremos disponibles los bloques de manejo de la pantalla de 5x5 LEDs. Estos bloques se encuentran en la libreria 'Pantalla LED' que debemos a\u00f1adir a nuestro programa. Desde 'Control debemos situar los bloques 'al empezar' y 'por siempre'.</p> <p>Repetimos el 'Primer proyecto' en el que vamos a utilizar, adem\u00e1s de los dos nombrados, el 'limpia pantalla' y 'muestra car\u00e1cter'. En la animaci\u00f3n siguiente vemos el proceso y la simulaci\u00f3n.</p> <p> <p> Primer proyecto</p> <p></p> <p>Podemos observar que tras unos instantes el programa comienza a ejecutarse en la micro:bit conectada. En el caso de Microblocks el bloque usado solamente permite un car\u00e1cter y no crea la animaci\u00f3n si ponemos mas de uno. Para hacer esto tenemos disponible otro bloque.</p> <p>Ya tenemos creado el programa y comprobado que funciona, es hora de salvarlo en el ordenador. Esto lo haremos asi principalmente para tener disponibles todos los programas y poder enlazarlos donde convenga en estas notas. En la animaci\u00f3n siguiente vemos el proceso de descarga del archivo.</p> <p> <p> Descarga del archivo Primer-proyecto.ubp</p> <p></p> <p>El Primer proyecto lo podemos descargar desde este enlace.</p> <p>Durante el proceso de cambios en el programa podemos comprobar que el conjunto de bloques esta rodeado de una l\u00ednea verde que indica que el programa se est\u00e1 ejecutando en la micro:bit. Lo apropiado cuando vamos a realizar cambios es detener la ejecuci\u00f3n, hacer los cambios y volver a poner la ejecuci\u00f3n en marcha.</p> <p> <p> Realizando cambios</p> <p></p> <p>En la animaci\u00f3n vemos junto a los botones de inicio/parada el icono indicador de progreso de la sincronizaci\u00f3n entre el IDE y la placa.</p>"},{"location":"guias/mblocks/#enlaces-utiles","title":"Enlaces \u00fatiles","text":"<ul> <li> <p>En la web de Francisco Soldado denominada 'ardutaller' nos vamos a encontrar con una entrada MicroBlocks \u2192&gt; micro:bit donde aparece un video con detalles adicionales sobre el trabajo con esta pareja de software/hardware. En ese mismo enlace tenemos disponibles varias actividades totalmente resueltas tanto en catal\u00e1n como espa\u00f1ol.</p> </li> <li> <p>Este es el video en Youtube integrado en la web titulado Introducion al Software Microblocks. Conexi\u00f3n a Microbit</p> </li> </ul>"},{"location":"guias/mkcode/","title":"Microsoft MakeCode","text":"<p>El editor MakeCode de Microsoft es una buena forma de comenzar a programar la BBC micro:bit seg\u00fan mi criterio. Se utiliza un sistema de bloques codificados por colores que resultan f\u00e1ciles de usar y lo suficientemente potentes como para acceder a todas las funciones de la placa. Tambi\u00e9n se puede cambiar el editor a JavaScript para ver el c\u00f3digo equivalente a los bloques.</p> <p>Se puede encontrar m\u00e1s informaci\u00f3n sobre c\u00f3mo usar el editor MakeCode en las Preguntas m\u00e1s frecuentes de MakeCode.</p> <p>Lo que vamos a mostrar aqu\u00ed es una referencia de MakeCode a trav\u00e9s del editor que podemos encontrar en:</p> <p> <p> Abrir el editor online MakeCode</p> <p></p> <p>Existen versiones descargables de MakeCode, pero no para Linux.</p>"},{"location":"guias/mkcode/#primeros-pasos","title":"Primeros pasos","text":"<p>El aspecto que se nos va a mostrar al entrar en el enlace anterior es el que vemos en la imagen siguiente, que se corresponde con la parte superior de la web. Es posible la primera vez se en ingl\u00e9s pero lo podemos cambiar haciendo clic en la rueda dentada y escogiendo el idioma entrando en la primera opci\u00f3n que se muestra.</p> <p> <p> Pantalla inicial de MakeCode</p> <p></p> <p>La ventana requiere pocas explicaciones y lo primero que vamos a hacer en crear un nuevo proyecto haciendo clic en el bloque de 'Nuevo proyecto'. Para crear proyectos en la nube tendremos que loguearnos mediante una cuenta v\u00e1lida. En la animaci\u00f3n siguiente vemos como crear nuestro primer proyecto.</p> <p> <p> Primer programa en MakeCode</p> <p></p> <p>Al principio nos pide un nombre para el programa y nos ofrece la posibilidad de escoger como queremos trabajar en cuanto a c\u00f3digo se refiere. Posteriormente lanza un peque\u00f1o tutorial, que aunque est\u00e1 en ingl\u00e9s, nos explica muy claramente como trabajar con el programa.</p> <p>En la animaci\u00f3n siguiente se recorren las opciones principales que est\u00e1n disponibles cuando estamos editando un proyecto.</p> <p> <p> Ventana de edici\u00f3n de proyecto en MakeCode</p> <p></p>"},{"location":"guias/mkcode/#descripcion-de-la-ventana-de-proyecto","title":"Descripci\u00f3n de la ventana de proyecto","text":"<ul> <li>En la parte superior izquierda de la pantalla es donde est\u00e1 situado el simulador que se muestra con una imagen de una micro:bit. Se trata de una secci\u00f3n muy importante porque nos permite trabajar con la mayor parte de los programas sin necesidad de tener una placa f\u00edsica conectada, adem\u00e1s resultar \u00fatil para depurar el c\u00f3digo.</li> <li>A la derecha del simulador se sit\u00faa una columna con los bloques de programaci\u00f3n organizados por categorias. Cuando hacemos clic en una categoria se despliegan, a la derecha, los bloques mas utilizados de esa categoria. Muchas veces, debajo del nombre correspondiente a esa categoria aparece un letrero ...mas, que si se pulsa muestra el resto de bloques de la categoria. Para llevar un bloque al \u00e1rea de programaci\u00f3n basta con hacer clic sobre el mismo y arrastrarlo a la misma. En la parte superior de esta columna hay un buscador por si no recordamos muy bien donde est\u00e1 el bloque que buscamos.</li> <li>A la derecha de los bloques de programaci\u00f3n est\u00e1 la zona de programaci\u00f3n, que es donde se arrastran los bloques para crear el programa.</li> <li>Tanto en la parte superior como inferior de la pantalla tenemos enlaces a funcionalidades del programa que quedan resumidas en la imagen siguiente.</li> </ul> <p> <p> Barras de herramientas de MakeCode</p> <p></p>"},{"location":"guias/mkcode/#crear-un-programa","title":"Crear un programa","text":"<p>Por defecto, al crear un proyecto, MakeCode sit\u00faa dos bloques de eventos en el a\u0155ea de programa, 'al iniciar' y 'para siempre'. Otros bloques que permiten iniciar el programa los podemos encontrar en 'Entrada'. Esta ser\u00e1 la primera tarea a realizar en nuestro programa, decidir que evento es el que inicia el c\u00f3digo.</p> <p>El programa lo vamos creando arrastrando bloques al \u00e1rea de programaci\u00f3n y podemos ir probando el funcionamiento en el simulador. Las opciones que permiten interactuar con el simulador son dependientes de los bloques introducidos.</p> <p>Vamos a hacer algo en este 'Primer proyecto' que es el nombre que le dimos al primer programa. Simplemente vamos a utilizar dos bloques, uno va a ser 'Borrar la pantalla' y el otro 'Mostrar n\u00famero', ambos en la secci\u00f3n 'Entrada'. El primero lo vamos a poner en el bloque 'al iniciar' de manera que cada vez que se inicia la micro:bit se apaguen todos los LEDs y el segundo lo pondremos en 'para siempre' y sin modificar nada vemos como el n\u00famero 0 se muestra mientras est\u00e1 alimentada la micro:bit. En la animaci\u00f3n siguiente vemos el proceso y la simulaci\u00f3n.</p> <p> <p> Primer proyecto</p> <p></p> <p>Podemos hacer pruebas cambiando el n\u00famero e incluso entrando n\u00fameros de varias cifras para ver lo que ocurre.</p>"},{"location":"guias/mkcode/#grabar-codigo-en-la-microbit","title":"Grabar c\u00f3digo en la micro:bit","text":"<p>Aunque es posible utilizar el bot\u00f3n 'Descargar' para grabar directamente el programa en la memoria flash, el proceso que nosotros vamos a seguir siempre va a ser descargar el .hex y arrastrarlo a la unidad MICROBIT montada. Esto lo haremos asi principalmente para tener disponibles todos los programas y poder enlazarlos donde convenga en estas notas. En la animaci\u00f3n siguiente vemos el proceso de descarga del archivo.</p> <p> <p> Descarga del archivo Primer-proyecto.hex</p> <p></p> <p>El Primer proyecto lo podemos descargar desde este enlace.</p> <p>Una vez descargado el .hex y conectada la micro:bit a un puerto USB procedemos a grabar el programa en la micro:bit para comprobar que funciona exactamente igual que en la simulaci\u00f3n. El proceso lo vemos en la animaci\u00f3n siguiente.</p> <p> <p> Grabar en la micro:bit el archivo Primer-proyecto.hex</p> <p></p> <p>Durante el proceso de grabaci\u00f3n podemos comprobar el parpadeo del LED amarillo de la cara posterior y como se desmonta y monta la unidad MICROBIT reseteandose la placa.</p>"},{"location":"guias/outofthebox/","title":"Experiencia inmediata","text":"<p>Cuando abrimos y conectamos una micro:bit nueva, se ejecuta un programa de demostraci\u00f3n grabado en f\u00e1brica. Esto es lo que se conoce como \"Out of box experience\" que se traduce como \"experiencia inmediata\" y que nos permite comenzar a ver y disfrutar funcionalidades de la placa sin hacer nada mas que conectarla. Si queremos restablecer de f\u00e1brica la micro:bit podemos descargarnos el archivo .hex listo para usar.</p> <p>El programa es v\u00e1lido para todas las versiones de micro:bit aunque, l\u00f3gicamente, si no disponemos de las funcionalidades que nos da la V2 no podremos disfrutarlas.</p> <p>Una vez descargado el programa lo grabamos en nuestra micro:bit y veremos como la pantalla LED comienza a hacer cosas, nos saluda y a partir de aqu\u00ed podemos ir desbloqueando varios juegos siguiendo las instrucciones en pantalla y lo que vamos a ver aqu\u00ed.</p> <p>Una primera cosa que podemos hacer con la V2 es \"dormir a la micro:bit\" manteniendo presionado el bot\u00f3n de reset de la parte posterior hasta que se apague el LED de encendido. Para \"despertarla\" presionamos de nuevo reset.</p> <ul> <li>Presionar lo botones. Median te una flecha nos indica el bot\u00f3n que debemos pulsar para avanzar. Los botones son las entradas m\u00e1s b\u00e1sicas de que dispone micro:bit</li> <li>Ag\u00edtala (Shake it). Cuanto mas agitemos la micro:bit mas LEDs se enceder\u00e1n. Esta funcionalidad est\u00e1 programada con el sensor de movimiento que integra la placa y que se conoce como aceler\u00f3metro porque mide fuerzas. Puede medir la fuerza de sacudida o en que direcci\u00f3n se realiza esta.</li> <li>Tilt: chase the dot. Se trata de atrapar el punto intermitente inclinando la micro:bit.</li> <li>Aplaude (Clap). La micro:bit V2 dispone de micr\u00f3fono y escucha el sonido.</li> <li>Huevo de pascua. A veces se denominan as\u00ed los juegos secretos. Cuando veamos en pantalla un coraz\u00f3n debemos pulsar simultaneamente los botones A y B y se desbloquer\u00e1 el juego de la serpiente.</li> </ul> <p>Podemos reiniciar la microbit en cualquier momento para iniciar de nuevo la demostraci\u00f3n.</p> <p>El c\u00f3digo que descargamos est\u00e1 escrito en C++ por lo que no se cargar\u00e1 en los editores de MakeCode o Python. Ahora bien, se puede  crear un programa propio para esta 'experiencia lista para usar' tanto en MakeCode como en Python.</p> <p>Tanto para enviar a la micro:bit este programa como otro archivo hexadecimal podemos utilizar la herramienta online micro:bit WebUSB hex file flashing tool o micro:bit WebUSB herramienta de flasheo de archivos hexadecimales.</p> <p>En la animaci\u00f3n siguiente vemos esta herramienta en funcionamiento.</p> <p> <p> Herramienta de flasheo</p> <p></p> <p>En la imagen vemos la ventana de la aplicaci\u00f3n traducida.</p> <p> <p> Herramienta de flasheo traducida</p> <p></p>"},{"location":"guias/pyt/","title":"BBC micro:bit con MicroPython","text":"<p>Practicamente todas las explicaciones sobre este tema van a estar basadas en BBC micro:bit MicroPython documentation que desafortunadamente no est\u00e1 es espa\u00f1ol.</p> <p>Uno de los lenguajes que entiende la micro:bit es el Python y la versi\u00f3n que se ejecuta en BBC micro:bit se llama MicroPython.</p> <p>Aunque en principio toda la informaci\u00f3n se va a referir a la versi\u00f3n V2 de micro:bit casi todo ser\u00e1 v\u00e1lido para versiones anteriores, excepto claro lo no implementado en estas.</p> <p>Fundamentalmente vamos a utilizar, para crear los programas, el editor de MicroPython para micro:bit que es muy similar MakeCode. Tambi\u00e9n se puede trabajar con el edit Mu.</p> <p>Python en BBC micro:bit est\u00e1 pensado para que estudiantes de 11 a 14 a\u00f1os (o edades superiores), aprendan fundamentos de la programaci\u00f3n a trav\u00e9s de la codificaci\u00f3n basada en texto.</p> <p> <p> Editor de MicroPython</p> <p></p> <p>Conectamos la micro:bit al ordenador mediante un cable USB.</p> <p>Escribimos el script (programa) en la ventana del editor y hacemos clic en el bot\u00f3n \"Enviar a micro:bit\" o \"Guardar\" para despu\u00e9s transferirlo al micro:bit.</p>"},{"location":"guias/pyt/#partes-del-editor-de-python-microbit","title":"Partes del editor de Python micro:bit","text":"<p>En la gu\u00eda de usuario User guide tenemos la descripci\u00f3n que vamos a resumir aqu\u00ed de las partes que componen el editor.</p> <p> <p> Apartados del editor de MicroPython</p> <p></p>"},{"location":"guias/pyt/#1-referencia","title":"1. Referencia","text":"<p>La secci\u00f3n facilita descubrir lo que Python y micro:bit pueden hacer, como explorar bloques en MakeCode o Scratch.</p> <p>Tamibi\u00e9n sirve para ver f\u00e1cilmente el potencial del hardware que incorpora la micro:bit y que el software de escritura en Python aumenta la creatividad de los alumnos.</p>"},{"location":"guias/pyt/#2-fragmentos-de-codigo","title":"2. Fragmentos de c\u00f3digo","text":"<p>Son fragmentos de c\u00f3digo listos para arrastrar y soltar en el \u00e1rea de programa. Estos fragmentos son totalmente funcionales, ahorran tiempo y ayudan a superar barreras de falta de habilidad con el teclado y recordar de forma precisa la sintaxis.</p> <p> <p> Arrastrar y soltar un fragmento de c\u00f3digo</p> <p></p> <p>Podemos observar como al arrastrar al \u00e1rea de c\u00f3digo la identation (sangria) se realiza de forma autom\u00e1tica para respetar la sintaxis de Python.</p>"},{"location":"guias/pyt/#3-resaltado-de-la-estructura-del-codigo","title":"3. Resaltado de la estructura del c\u00f3digo","text":"<p>Los distintos colores y la l\u00edneas de sangria que se muestran en los programas Python ayudan en las fases de dise\u00f1o, planificaci\u00f3n y prueba de un proyecto. Es f\u00e1cil seguir y entender el flujo de un programa si se mantiene todo en su lugar.</p> <p>En la animaci\u00f3n siguiente se provocan diversos errores de manera intencionada y se muestra la marca del error y la informaci\u00f3n que nos ofrece.</p> <p> <p> Resaltado de la estructura del c\u00f3digo</p> <p></p>"},{"location":"guias/pyt/#4-resaltado-de-errores","title":"4. Resaltado de errores","text":"<p>Los errores forman parte normal de la codificaci\u00f3n. Los s\u00edmbolos circulares junto al n\u00famero de l\u00ednea ayudan a identificar errores y corregirlos antes de enviar el c\u00f3digo a la micro:bit. Se puede pasar el cursor sobre el c\u00edrculo en el margen para que se muestre una explicaci\u00f3n del error. Repetimos aqu\u00ed la animaci\u00f3n previa donde hemos visto esto.</p> <p> <p> Resaltado de errores</p> <p></p>"},{"location":"guias/pyt/#5-autocompletar","title":"5. Autocompletar","text":"<p>El miedo a una pantalla en blanco y no saber qu\u00e9 escribir son dos de las mayores barreras para comenzar la codificaci\u00f3n basada en texto.</p> <p>Para ayudar con esto, a medida que escribe c\u00f3digo, el editor nos hace sugerencias que permiten elegir haciendo clic o presionando la tecla Intro. Esto ahorra tiempo, evita errores tipogr\u00e1ficos y evita tener que recordar de forma precisa una determinada sintaxis.</p> <p>Tambi\u00e9n es otra forma de descubrir qu\u00e9 pueden hacer Python y micro:bit, por ejemplo, al ver las opciones disponibles para mostrar im\u00e1genes ya definidas. Adem\u00e1s, si nos movemos con las flechas del teclado, por las opciones nos ir\u00e1n apareciendo a la derecha las descripciones de cada una de ellas.</p> <p> <p> Autocompletar</p> <p></p>"},{"location":"guias/pyt/#6-simulador","title":"6. Simulador","text":"<p>Permite probar el c\u00f3digo antes de grabarlo en la micro:bit real. Esto ayuda a desarrollar, probar, depurar y evaluar el c\u00f3digo y permite crear proyectos sin disponer fisicamente de la placa.</p> <p> <p> Simulador</p> <p></p>"},{"location":"guias/pyt/#7-ideas-y-api","title":"7. Ideas y API","text":"<p>En la pesta\u00f1a 'Ideas' hay programas completos listos para usar que se pueden modificar para crear los nuestros propios.</p> <p>El men\u00fa API (abreviatura de \"Application Programming Interfaces\" o \"interfaz de programaci\u00f3n de aplicaciones\") nos proporciona una descripci\u00f3n general m\u00e1s detallada de los comandos de MicroPython que se pueden usar con micro:bit. Esto puede ser \u00fatil cuando deseamos entender mejor lo que estamos haciendo en un trozo de c\u00f3digo en particular y qu\u00e9 opciones o argumentos se pueden usar con una funci\u00f3n.</p> <p> <p> Ideas y API</p> <p></p> <p>En la imagen siguiente tenemos un resumen de estos apartados.</p> <p> <p> Partes del editor explicadas en un gr\u00e1fico</p> <p></p>"},{"location":"guias/pyt/#uso-del-simulador","title":"Uso del simulador","text":"<p>La micro:bit que hay en la barra lateral de la derecha es un simulador. Si hacemos clic en reproducir podemos probar nuestro c\u00f3digo. Si el c\u00f3digo utiliza funciones como el aceler\u00f3metro, el sensor de temperatura, el sensor de luz (o cualquier otra funci\u00f3n de micro:bit), se pueden simular las condiciones necesarias para probar la micro:bit con los controles encontramos debajo. Tambi\u00e9n podemos usar la consola serie simulada para interactuar con la micro:bit simulada.</p> <p>En el video Simulator: micro:bit Python Editor enlazado de la documentaci\u00f3n vemos como se usa el simulador.</p>"},{"location":"guias/pyt/#flasheando-la-microbit","title":"Flasheando la micro:bit","text":"<p>Una vez comprobado el funcionamiento del programa tenemos todo listo para probarlo en la micro:bit real simplemente escogiendo 'Enviar a micro:bit'.</p> <p>El video Direct flashing from Python to micro:bit enlazado de la documentaci\u00f3n muestra los siguientes pasos si tenemos un navegador compatible con WebUSB.</p> <p>Si el navegador no soporta webUSB o no conseguimos una configuraci\u00f3n adecuada, como es mi caso utilizando Chomium tenemos que utilizar un m\u00e9todo alternativo para enviar el programa a la micro:bit.</p> <p> <p> Flasheando la micro:bit</p> <p></p>"},{"location":"guias/pyt/#abriendo-un-programa","title":"Abriendo un programa","text":"<p>Para abrir un programa, ya sea porque lo hemos guardado anteriormente o porque es de un tercero, hacemos clic en el bot\u00f3n 'Abrir'. En la ventana de di\u00e1logo que se amuestra seleccionamos el archivo '.hex' o '.py' que queremos abrir y luego hacemos clic en abrir. Alternativamente, podemos arrastrar y soltar un archivo '.hex' o un script '.py' en el editor.</p> <p> <p> Abriendo un programa</p> <p></p>"},{"location":"guias/pyt/#proyectos-configuracion-y-ayuda","title":"Proyectos, configuraci\u00f3n y ayuda","text":"<p>Las tres pesta\u00f1as de la parte inferior izquierda nos dan acceso a estas funcionalidades.</p> <ul> <li>Proyecto. La secci\u00f3n de proyectos, que se encuentra en el men\u00fa de la izquierda, es particularmente \u00fatil si necesitamos agregar archivos de Python adicionales al proyecto. Esto puede ser, por ejemplo, para agregar un m\u00f3dulo para un accesorio o para agregar un c\u00f3digo proporcionado por un tercero.</li> </ul> <p>Al hacer clic en el bot\u00f3n se enumeran todos los archivos .py del proyecto. Originalmente, solo habr\u00e1 un archivo con el nombre main.py que incluye el c\u00f3digo inicial que hemos tecleado en la parte central del editor.</p> <p>Si necesitamos un segundo archivo en el proyecto, podemos elegir 'Crear archivo' y ponerle un nombre, por ejemplo, lo podemos llamar 'ampliar' y se crear\u00e1 un nuevo archivo Python dentro del proyecto.</p> <p>Si por el contrario lo que queremos es abrir un archivo, procedente de un proveedor de accesorios o un tercero, hacemos clic el bot\u00f3n 'Abrir', localizamos el archivo en nuestro ordenador y lo abrimos. Se nos mostrar\u00e1 una ventana '\u00bfCambiar archivos? con una frase que empieza por \"Sustituir c\u00f3digo principal por ...\" y que finaliza con el nombre del archivo seleccionado. A la derecha de esta frase hay un icono que si lo clicamos nos va a permitir escoger entre las opciones de 'Sustituir c\u00f3digo' o 'A\u00f1adir archivo' para a\u00f1adirlo como archivo adicional. Este archivo adicional, que est\u00e1 dentro del proyecto, puede ser referenciado en main.py utilizando la funci\u00f3n 'import'.</p> <p>Si, por otro lado, queremos volver al c\u00f3digo original en alg\u00fan momento, por ejemplo porque se ha realizado un cambio en el programa existente y queremos restablecerlo, podemos usar el bot\u00f3n 'Restablecer proyecto' que est\u00e1 en la parte inferior. Pero cuidado porque esto reemplaza todo el c\u00f3digo, nos lleva de regreso al c\u00f3digo predeterminado y elimina cualquier archivo adicional a\u00f1adido.</p> <p> <p> Proyecto</p> <p></p> <p>El directorio donde se almacenan los proyectos es 'Descargas'.</p> <ul> <li>Configuraci\u00f3n. Se nos abre un men\u00fa donde podemos escoger entre 'Idioma' y 'Configuraci\u00f3n' que muestra una ventana con unas cuantas opciones de configuraci\u00f3n.</li> </ul> <p> <p> Configuraci\u00f3n</p> <p></p> <ul> <li>Ayuda. En esta pesta\u00f1a tenemos acceso a diferentes opciones como 'Ayuda y asistencia' que nos abre una web para consultas, 'Documentaci\u00f3n de MicroPython' que nos dirige a la wiki de referencia citada al principio del apartado, 'Comentarios' un sitio desde enviar nuestros propios comentarios, 'T\u00e9rminos de uso' que nos dirige a la web donde est\u00e1n definidos y 'Acerca de nosotros' que es el t\u00edpico Acerca de... que vemos en la ventana siguiente.</li> </ul> <p> <p> Acerca de nosotros</p> <p></p> <p>Es importante leer 'T\u00e9rminos de uso' donde est\u00e1 descrito todo lo que debemos tener en cuenta cuando se utiliza micro:bit y todo lo relacionado con la marca en los t\u00e9rminos indicados que adem\u00e1s debemos aceptar. Los t\u00e9rminos de uso se dan en 18 puntos.</p>"},{"location":"guias/pyt/#editando-codigo","title":"Editando c\u00f3digo","text":"<p>Para la creaci\u00f3n y edici\u00f3n de nuestros programas utilizaremos la ventana central del editor micro:bit MicroPython.</p> <p>En esta ventana nos ser\u00e1n de gran utilidad las caracter\u00edsticas de autocompletado, detecci\u00f3n de errores y la funcionalidad de los botones deshacer y rehacer que tambi\u00e9n permiten corregir errores.</p> <p> <p> Editando c\u00f3digo</p> <p></p> <p>En la imagen siguiente tenemos enmarcada con l\u00ednea verde discontinua la zona de edici\u00f3n de c\u00f3digo. Esta zona la podemos ampliar minimizando el men\u00fa de la izquierda (1), el men\u00fa de la derecha (4) o ajustando su anchura (2). Los iconos de zoom (3) permiten ampliar y reducir el tama\u00f1o del texto en la ventana y los controles deshacer/rehacer (5) tienen la funcionalidad habitual y permiten cierto nievel de edici\u00f3n.</p> <p> <p> Manejo del editor</p> <p></p>"},{"location":"guias/pyt/#primer-proyecto","title":"Primer proyecto","text":"<p>Para trabajar con Python en micro:bit necesitamos conocer la API de MicroPython que se trata en otro apartado y cuyo original podemos consultar en la webgrafia. Aqu\u00ed vamos a resumir muy brevemente el significado de las tres l\u00edneas de c\u00f3digo que compoenen el programa.</p> <p>Todo lo necesario para poder interactuar con el hardware lo tenemos en el m\u00f3dulo microbit y para facilitar su uso se recomienda iniciar todos los scripts con: <pre><code>from microbit import *\n</code></pre> La pantalla de LEDs se controla a partir del objeto display y sus m\u00e9todos, dos de los cuales usamos en el programa y que trabajan de la forma siguiente: <pre><code>display.clear() #Apaga todos los LEDs\ndisplay.show(0) #Muestra el n\u00famero entre par\u00e9ntesis\n</code></pre> Los n\u00fameros pueden tener mas de una cifra y si queremos mostrarlos como cadena de texto los encerramos entre comillas simples o dobles. L\u00f3gicamente en este caso podemos utilizar otros caracteres que no sean n\u00fameros.</p> <p>El primer proyecto lo tenemos disponible en los enlaces siguientes:</p> <ul> <li>Primer proyecto .hex</li> <li>Primer proyecto .py</li> </ul>"},{"location":"programas/lista/","title":"Listado de programas","text":"<p>En la tabla siguiente se establecen todos los enlaces de manera individual y al final aparece un archivo zip con todos los programas de cada categoria.</p> <p>  MakeCode  MicroBlocks  Python .hex   Python .py Primer proyecto Primer proyecto Primer proyecto Primer proyecto microbit-A01-Hola_Mundo A01-Hola_Mundo.ubp A01-Hola_Mundo-main A01-Hola_Mundo-main A02-Coraz\u00f3n_latiendo A02-Corazon_latiendo.ubp A02-Corazon_latiendo A02-Corazon_latiendo A03-boton_pulsado A03-boton-pulsado.ubp A03-Boton_pulsado en hexadecimal A03-Boton_pulsado en Python Comprimido de MakeCode Comprimido de MicroBlocks Comprimido de Python <p></p> <p></p>"},{"location":"programas/lista/#t","title":"t","text":""}]}