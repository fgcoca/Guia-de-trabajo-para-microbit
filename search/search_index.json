{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introducci\u00f3n","text":"<p>Se pretende crear una gu\u00eda para trabajar con la tarjeta micro:bit mediante:</p> <ul> <li>Programaci\u00f3n gr\u00e1fica con: Makecode, Microblocks, Scratch, ...</li> <li>Programaci\u00f3n con MicroPython</li> </ul> <p>Comienzo por mostrar las versiones de placas micro:bit de una forma breve indicando sus principales diferencias y tambi\u00e9n introduzco diferenes accesorios y shield interesantes.</p> <p>Hablar\u00e9 de la soluci\u00f3n cuando tenemos problemas de descarga de los programas por el puerto USB y tambi\u00e9n de como actualizar o reponer el firmware en la placa micro:bit</p>"},{"location":"#descripcion-grafica","title":"Descripci\u00f3n gr\u00e1fica","text":"<p>En la imagen siguiente vemos la descripci\u00f3n del hardware de la micro:bit 1.3.</p> <p> <p> Hardware micro:bit 1.3</p> <p></p> <p>En la siguiente imagen tenemos la descripci\u00f3n de hardware para la versi\u00f3n 2 que incluye importantes novedades ya que incorpora un pulsador t\u00e1ctil como sensor en el logo, un micr\u00f3fono con indicador LED, un altavoz, LED indicador de actividad USB y una LED indicador de alimentaci\u00f3n.</p> <p> <p> Hardware micro:bit 2</p> <p></p> <ul> <li>El conector microUSB nos servir\u00e1 para programar mediante la t\u00e9cnica de arrastrar y soltar, depurar mediante CMSIS-DAP y ello gracias a que integra webUSB para permitir que podamos conectar nuestra micro:bit a la web mediante el puerto USB</li> <li>Los pads con agujero permiten la conexi\u00f3n mediante pinzas de cocodrilo o conectores tipo banana.</li> <li>La antena de 2.4 GHz sirve para BLE (Bluetooth Low Energy) y transmisi\u00f3n de radio.</li> </ul>"},{"location":"#novedades-v2-y-diferencia-con-v1","title":"Novedades V2 y diferencia con V1","text":"<p>La novedad mas importante de la nueva tarjeta micro:bit V2 es que incorpora un procesador mas potente que su predecesora. Tambi\u00e9n incorpora indicador de bater\u00eda,  micr\u00f3fono, altavoz y un sensor t\u00e1ctil en el logotipo que aumentan sus posibilidades de utilizaci\u00f3n. En la imagen siguiente se se\u00f1alan los nuevos elementos.</p> <p> <p> Novedades micro:bit 2</p> <p></p> <p>Las principales diferencias con micro:bit V1 quedan descritas a continuaci\u00f3n:</p> <ul> <li> <p>El logo es un bot\u00f3n t\u00e1ctil. Se trata de un bot\u00f3n t\u00e1ctil capacitivo que nos da la posibilidad de pulsar de cuatro maneras diferentes, bot\u00f3n A, bot\u00f3n B, bot\u00f3n A y bot\u00f3n B a la vez y bot\u00f3n t\u00e1ctil.</p> </li> <li> <p>Micr\u00f3fono. Se trata de un micro digital MEMS al que se asocia un indicador LED con el icono de un micr\u00f3fono. El t\u00e9rmino MEMS, del ingl\u00e9s MicroElectroMechanical Systems, se refiere a la tecnolog\u00eda electromec\u00e1nica de dispositivos microsc\u00f3picos o sistemas microelectromec\u00e1nicos.</p> </li> <li> <p>Modo ahorro de energ\u00eda. Esta nueva funci\u00f3n de ahorro o modo de espera detendr\u00e1 el programa que se est\u00e9 ejecutando en la micro:bit hasta que se pulse el bot\u00f3n de reinicio.</p> </li> <li> <p>Altavoz. Permite incorporar sonidos a nuestros proyectos.</p> </li> </ul> <p>La microbit v2 tiene cuatro veces mas posibilidades de procesamiento y ocho veces mas memoria RAM que micro:bit V1, y esto gracias a la incorporaci\u00f3n de un procesador nRF52833 ARM Cortex de 64 MHz.</p> <p>Incorpora 512 KB de memoria Flash y 128 KB de memoria RAM.</p>"},{"location":"#hardware-microbit-v2","title":"Hardware micro:bit V2","text":"<p>En la imagen siguiente tenemos una descripci\u00f3n gr\u00e1fica de todos los elementos que integra la micro:bit v2 en sus vistas frontal y posterior.</p> <p> <p> Hardware micro:bit 2</p> <p></p>"},{"location":"#procesador-nrf52","title":"Procesador nRF52","text":"<p>Es donde se ejecutan los programas de usuario. El nRF52 proporciona todos los pines GPIO accesibles para el usuario. Hay integrado un perif\u00e9rico de radio de 2.4GHz que se utiliza para proporcionar capacidades de radio y de Bluetooth. En la tabla siguiente vemos sus principales caracter\u00edsticas.</p> <p> Item Detalles Modelo Nordic nRF52833 Variante del n\u00facleo Procesador Arm Cortex-M4 de 32 bit con FPU Memoria Flash ROM 512 KB Memoria RAM 128 KB Velocidad 64 MHz <p></p>"},{"location":"#comunicacion-inalambrica-bluetooth","title":"Comunicaci\u00f3n inal\u00e1mbrica Bluetooth","text":"<p>El dispositivo integrado de 2,4 GHz Nordic S113 admite comunicaciones Bluetooth a trav\u00e9s del dispositivo de bajo consumo (BLE), permitiendo comunicar la micro:bit con dispositivos Bluetooth como tel\u00e9fonos inteligentes y tabletas.</p> <p> Item Detalles Pila (stack) Bluetooth 5.1 con Bluetooth de bajo consumo (BLE) Banda 2.4GHz ISM (Industrial, Scientific and Medical) 2.4GHz..2.41GHz Canales 50 de 2MHz. Uitilizados del 0 al 39 Sensibilidad -93 dBm en modo BLE Potencia de transmisi\u00f3n -40 dBm a 4 dBm Perfiles BBC micro:bit profile Mas informaci\u00f3n Bluetooth <p></p>"},{"location":"#radiocomunicaciones-de-bajo-nivel","title":"Radiocomunicaciones de bajo nivel","text":"<p>El transceptor integrado de 2,4 GHz soporta una serie de est\u00e1ndares de comunicaciones por radio sobre los que est\u00e1 construido el protocolo de radio micro:bit. Este protocolo proporciona una interfaz de radio sencilla de transmisi\u00f3n de peque\u00f1os paquetes con otros dispositivos que lo admiten, como por ejemplo, otras micro:bit.</p> <p> Item Detalles Protocolo Radio micro:bit Banda de frecuencia 2.4GHz Velocidad de canal 1 Mbps o 2 Mbps Encriptaci\u00f3n Ninguna Canales 80 (0...80) C\u00f3digos de grupo 255 Potencia de transmisi\u00f3n Ocho valores configurables por el usuario, 0 (-30 dbm) a 7 (+4 dbm) Tama\u00f1o de carga 32 (est\u00e1ndar) o 255 (si se configura) Mas informaci\u00f3n Radio micro:bit <p></p>"},{"location":"#botones","title":"Botones","text":"<p>Los dos botones de la parte frontal y el bot\u00f3n de la parte posterior son botones pulsadores normales. El bot\u00f3n de la parte posterior est\u00e1 conectado al procesador de interfaz KL27 y al procesador NRF52 para reiniciar el sistema. De esta forma se garantiza que la aplicaci\u00f3n se reiniciar\u00e1 independientemente de si se alimenta desde USB o desde una bater\u00eda.</p> <p>Los botones frontales A y B se pueden programar en la aplicaci\u00f3n de usuario con cualquier prop\u00f3sito. Los rebotes de A y B se eliminan por software, y tambi\u00e9n incluyen pulsaci\u00f3n corta, pulsaci\u00f3n larga y detecci\u00f3n de pulsaci\u00f3n simultanea de A y B. Los botones funcionan en modo el\u00e9ctrico invertido t\u00edpico, donde una resistencia pull-up asegura un '1' l\u00f3gico cuando se suelta el bot\u00f3n y un '0' l\u00f3gico cuando se pulsa el bot\u00f3n. Ambos botones est\u00e1n conectados a pines GPIO que tambi\u00e9n son accesibles en el conector de borde.</p> <p> Item Detalles Tipo Dos pulsadores de usuario y un pulsador de sistema Rebotes Se eliminan por software con periodos de 54 ms Pullup Los botones A y B con resistencias externas de 4K7 y el de sistema con 10K <p></p>"},{"location":"#pantalla","title":"Pantalla","text":"<p>La pantalla es una matriz de LED de 5x5. El software en tiempo de ejecuci\u00f3n actualiza repetidamente esta matriz a alta velocidad, de modo que est\u00e1 dentro del rango de persistencia visual del usuario y no se detecta parpadeo. Esta matriz de LED tambi\u00e9n se utiliza para detectar luz ambiental.</p> <p> Item Detalles Tipo LED rojo miniatura de montaje Estructura f\u00edsica Matriz de 5x5 Estructura el\u00e9ctrica 5x5 Control de intensidad Control de hasta 255 pasos por software Sensibilidad Estimaci\u00f3n de luz ambiente por algoritmo de software Rango de sensibilidad 10 niveles, de apagado a luminosidad total Sensibilidad de color centro del rojo (700 nm) <p></p>"},{"location":"#sensor-de-movimiento","title":"Sensor de movimiento","text":"<p>La micro:bit dispone de un chip que combina aceler\u00f3metro y magnet\u00f3metro proporcionando as\u00ed detecci\u00f3n de movimiento en 3 ejes y de campo magn\u00e9tico. Incluye detecci\u00f3n de gestos en el hardware (como por ejemplo de ca\u00eddas) y detecci\u00f3n adicional de gestos (por ejemplo, logotipo arriba, logotipo abajo, agitaci\u00f3n) a trav\u00e9s de software. Un algoritmo de software en tiempo de ejecuci\u00f3n utiliza el aceler\u00f3metro integrado para convertir las lecturas en una br\u00fajula independiente de la orientaci\u00f3n de la placa. La br\u00fajula debe calibrarse antes de su uso, y el software en tiempo de ejecuci\u00f3n inicia autom\u00e1ticamente el proceso de calibraci\u00f3n. Este dispositivo est\u00e1 conectado al procesador a trav\u00e9s del bus I2C.</p> <p> Item Detalles Modelo LSM303AGR Caracter\u00edsticas 3 campos magn\u00e9ticos y aceleraci\u00f3n en e ejes. Rangos 2/4/8/16g Resoluci\u00f3n 8/10/12 bits Gestos \"on board\" Ca\u00edda libre Otros gestos Se implementan por software en tiempo de ejecuci\u00f3n <p></p>"},{"location":"#deteccion-de-temperatura","title":"Detecci\u00f3n de temperatura","text":"<p>El procesador NRF52 tiene un sensor de temperatura integrado. Este se expone por software en tiempo de ejecuci\u00f3n y proporciona una estimaci\u00f3n de la temperatura ambiente.</p> <p> Item Detalles Rango de sensibilidad -40 \u00baC ... 105 \u00baC Resoluci\u00f3n Pasos de 0.25 \u00baC Precisi\u00f3n \u00b1 5 \u00baC (sin calibrar) Mas informaci\u00f3n Term\u00f3metro DAL <p></p>"},{"location":"#altavoz","title":"Altavoz","text":"<p>Adem\u00e1s de poder emitir sonido v\u00eda PWM por los pines, la micro:bit v2 incorpora un altavoz ya montado en la placa donde se puede reproducir sonido.</p> <p> Item Detalles Tipo JIANGSU HUANENG MLT-8530 SPL (Sound Pressure Level) 80dB @ 5V, 10cm Frecuencia de resonancia propia 2700Hz Mas informaci\u00f3n Datasheet <p></p>"},{"location":"#microfono","title":"Micr\u00f3fono","text":"<p>Un micr\u00f3fono MEMS (Micro -o nano- Electrical-Mechanical System) incorporado proporciona una entrada de sonido a la micro:bit y un indicador LED integrado en la parte frontal de la placa muestra al usuario cuando est\u00e1 encendido.</p> <p> Item Detalles Tipo Knowles SPU0410LR5H-QB-7 MEMS Sensibilidad -38dB \u00b13dB @ 94dB SPL Relaci\u00f3n se\u00f1al ruido (SNR) 63dB M\u00e1xima ganancia digital (AOP) 118dB SPL Rango de frecuencia 100Hz ... 80kHz Patr\u00f3n polar Omnidireccional Mas informaci\u00f3n Datasheet <p></p>"},{"location":"#pines-gpio","title":"Pines GPIO","text":"<p>Son pines de prop\u00f3sito general de entrada/salida (General Purpose Input/Output). En el conector de borde est\u00e1n muchos de los circuitos GPIO del procesador. Algunos de estos circuitos se comparten con otras funciones de la micro:bit, pero muchos pueden reasignarse para uso de prop\u00f3sito general si se desactivan algunas funciones del software.</p> <p> Item Detalles Anillos 3 de entrada/salida y 2 de alimentaci\u00f3n compatibles con banana de 4mm y pinza de cocodrilo Funciones GPIO 19 pines asignables GPIO 2 para interfaz I2C externa 6 para la pantalla o detecci\u00f3n de luz 2 para detectar los botones de la placa 1 reservado para interfaz de accesibilidad Los 19 se pueden asignar como entrada o salida digital Los 19 pueden asignarse para hasta 3 canales PWM simult\u00e1neos Los 19 se pueden asignar para transmisi\u00f3n serie y un canal de recepci\u00f3n serie 6 pueden asignarse como entrada anal\u00f3gica 3 pueden asignarse para comunicaci\u00f3n SPI 3 se pueden asignar para hasta 3 entradas de detecci\u00f3n t\u00e1ctil Resoluci\u00f3n conversor A/D 10 bits (0...1023). 2\u00b9\u2070=1024 Distancia entre pines 1.27mm, 80 vias a doble cara <p></p>"},{"location":"#alimentacion","title":"Alimentaci\u00f3n","text":"<p>La alimentaci\u00f3n de la micro:bit puede ser a trav\u00e9s de los 5V del conector USB o mediante una bater\u00eda de 3V enchufada al conector JST. Tambi\u00e9n es posible alimentar a la micro:bit desde los anillos 3V/GND en el conector de borde. Los anillos 3V/GND se pueden usar para suministrar energ\u00eda a circuitos externos. La placa utiliza un regulador de baja ca\u00edda o LDO especificado hasta 300 mA con corte t\u00e9rmico para protecci\u00f3n contra cortocircuitos.</p> <p> Item Detalles Rango de operaci\u00f3n 1.8V ... 3.6V Consumo de corriente 300mA m\u00e1ximo Asignado a perif\u00e9erico \"on board\" 90mA Conector de bater\u00eda JST X2B-PH-SM4-TB M\u00e1xima corriente prevista para el conector de borde 190mA Mas informaci\u00f3n Power Supply <p></p>"},{"location":"#interface","title":"Interface","text":"<p>El chip de interfaz maneja la conexi\u00f3n USB y se usa para actualizar el c\u00f3digo nuevo en la micro:bit, enviar y recibir datos en serie de forma bidireccional.</p> <p> Item Detalles Modelo MKL27Z256VFM4 N\u00facleo Arm Cortex-M0+ Flash ROM 256KB (128KB reservados para uso como almacenamiento) RAM 16KB Velocidad 48MHz Depuraci\u00f3n SWD Mas informaci\u00f3n DAPLinkManual del KL27 datasheet KL27 <p></p>"},{"location":"#comunicaciones-usb","title":"Comunicaciones USB","text":"<p>La placa micro:bit tiene una pila de comunicaciones USB incorporada integrada en el firmware del chip de interface. Esta pila brinda la capacidad de arrastrar y soltar archivos en la unidad MICROBIT para cargar c\u00f3digo en el procesador. Tambi\u00e9n permite que los datos en serie se transmitan desde y hacia el procesador de micro:bit a trav\u00e9s de USB a un ordenador externo, y es compatible con el protocolo CMSIS-DAP para la depuraci\u00f3n de programas de aplicaci\u00f3n en el host.</p> <p> Item Detalles Conector USB micro, MCR-B-S-RA-SMT-CS5-TR Versi\u00f3n USB Dispositivo a velocidad completa 2.0 Velocidad 12Mbit/s Clases USB soportadas Clase de almacenamiento masivo (MSC) Clase dispositivo de comunicaciones (CDC) Mas informaci\u00f3n DAPLink <p></p>"},{"location":"#depuracion","title":"Depuraci\u00f3n","text":"<p>El procesador de interface se puede utilizar con herramientas de host especiales para depurar el c\u00f3digo que se ejecuta en el procesador de la aplicaci\u00f3n. Se conecta al procesador de aplicaciones a trav\u00e9s de 4 cables de se\u00f1al. El c\u00f3digo del procesador de la interfaz KL27 tambi\u00e9n se puede depurar a trav\u00e9s de su interfaz de depuraci\u00f3n del software SWD integral, por ejemplo, para cargar el c\u00f3digo del cargador de arranque inicial en este procesador en el momento de la fabricaci\u00f3n, o para recuperarlo si se ha perdido.</p> <p> Item Detalles Protocolo CMSIS-DAP Opciones JLink/OB (via different firmware) Mas informaci\u00f3n Mbed debugging micro:bit <p></p>"},{"location":"#mecanicos","title":"Mec\u00e1nicos","text":"<p>Hay disponibles algunos dibujos CAD 2D y 3D y modelos de la micro:bit que incluyen todas las dimensiones importantes. Estos modelos se pueden utilizar como base para generar im\u00e1genes de proyecto y marketing de micro:bit, pero tambi\u00e9n como base para la fabricaci\u00f3n precisa de accesorios, por ejemplo, mediante impresi\u00f3n 3D.</p> <p> Item Dimensiones Ancho 51,60 mm Alto 42,00 mm Profundidad 11,65 mm Altura del bot\u00f3n a la placa 4,55 mm Altura del altavoz 3 mm Conector JST 5,50 mm <p></p>"},{"location":"#conector-de-borde","title":"Conector de borde","text":"<p>Hay 25 pistas/patillas que incluyen 5 agujeros para usar con clavijas tipo banana de 4 mm o pinzas de cocodrilo. Tres de estos anillos son para entrada y salida de prop\u00f3sito general (GPIO) y tambi\u00e9n sirven para detecci\u00f3n anal\u00f3gica, PWM y t\u00e1ctil, y dos est\u00e1n conectados a la alimentaci\u00f3n de la micro:bit.</p> <p>Las pistas mas finas est\u00e1n separadas 1,27 mm, algunas son utilizadas por micro:bit y otras est\u00e1n disponibles para su uso mediante cualquiera de los conectores externos existentes.</p> <p>Solamente tienen conexi\u00f3n las pistas frontales, las posteriores est\u00e1n sin conexi\u00f3n y los anillos posteriores est\u00e1n conectados a los delanteros.</p> <p>En la imagen siguiente tenemos la descripci\u00f3n de pines de la micro:bit v2 a la izquierda y de la v1 a la derecha para poder comparar y establecer las diferencias de una forma sencilla.</p> <p> <p> Pinout micro:bit V2 y V1</p> <p></p> <p>En microbit.pinout.xyz tenemos un fant\u00e1stico recurso para obtener m\u00e1s informaci\u00f3n sobre los pines de la micro:bit y de c\u00f3mo los utilizan algunos accesorios.</p> <p>En en enlace tenemos una guia de accesorios para micro:bit</p>"},{"location":"#protectores","title":"Protectores","text":"<p>Existen en el mercado protectores para las micro:bit realizados en metacrilato transparente, silicona de distintos colores y formas y otros materiales. Estos elementos son f\u00e1ciles de encontrar en las tiendas que comercializan la placa.</p> <p>Aqu\u00ed daremos toda la informaci\u00f3n necesaria para personalizar e imprimir en 3D nuestros propios protectores.</p>"},{"location":"#microbit-v1","title":"micro:bit V1","text":"<p>Carcasa de protecci\u00f3n para la versi\u00f3n 1 de la tarjeta micro:bit basada en un dise\u00f1o de tatan.</p> <p>La base tiene el siguiente aspecto en fase de dise\u00f1o y montada:</p> <p> <p> Protector micro:bit V1</p> <p></p> <p>A continuaci\u00f3n se da el listado de ficheros de dise\u00f1o y de impresi\u00f3n 3D listos para descargar.</p> <p> Descripci\u00f3n Archivo Enlace Archivo de dise\u00f1o proteccionV1.FCStd Fuente Base en STL base.stl Base Tapa en STL tapa.stl Tapa Base STEP base.step Base Tapa STEP tapa.step Tapa <p></p>"},{"location":"#microbit-v2","title":"micro:bit V2","text":"<p>El modelo se inspira en el dise\u00f1o para microbit v1 de crozes ga\u00ebtan (tatan) y tiene el aspecto final que vemos en la animaci\u00f3n siguiente:</p> <p> <p> Partes del modelo 3D</p> <p></p> <p>En las im\u00e1genes siguientes vemos el aspecto que tiene la base por sus dos caras.</p> <p> Parte delantera de la base Parte trasera de la base <p></p> <p>En las im\u00e1genes siguientes vemos el aspecto que tiene la tapa por sus dos caras.</p> <p> Parte delantera de la tapa Parte trasera de la tapa <p></p> <p>En la tabla siguiente tenemos los archivos del proyecto listos para descargar.</p> <p> Descripci\u00f3n STL AMF STEP Base baseV2.stl baseV2.amf baseV2.step Tapa tapaV2.stl tapaV2.amf tapaV2.step <p></p> <p>Este es el enlace al archivo de dise\u00f1o en FreeCAD y este a la TTF utilizada para crear los letreros.</p> <p>El aspecto del protector una vez montado lo tenemos en la imagen siguiente.</p> <p> <p> Partes del modelo 3D</p> <p></p>"},{"location":"#enlaces","title":"Enlaces","text":"<p>Antes de poner un listado de enlaces interesantes diremos que BBC micro:bit es una placa programable de 4x5 cm de c\u00f3digo abierto que permite aprender a programar de una forma f\u00e1cil y divertida que est\u00e1 al alcance de todos.</p> <p>Dado que incorpora muchos sensores es posible realizar una cantidad importante de proyectos disponiendo solamente de la placa.</p> <p>BBC micro:bit se puede programar de muchas formas,</p> <ul> <li>De forma visual o por bloques mediante:<ul> <li>MakeCode de Microsoft, un editor gr\u00e1fico online gratuito.</li> <li>MicroBlocks, un lenguaje de programaci\u00f3n por bloques para aprender computaci\u00f3n f\u00edsica.</li> <li>Scratch (a\u00f1adiendo una extensi\u00f3n).</li> <li>Open Roberta Lab, un entorno de programaci\u00f3n en l\u00ednea para robots con el lenguaje de programaci\u00f3n gr\u00e1fico NEPO.</li> </ul> </li> <li>Mediante c\u00f3digo:<ul> <li>JavaScript, un lenguaje de programaci\u00f3n o de secuencias de comandos que permite implementar funciones complejas en p\u00e1ginas web din\u00e1micas.</li> <li>MicroPython, un peque\u00f1o pero eficiente interprete del lenguaje de programaci\u00f3n Python, optimizado para funcionar en microcontroladores.</li> <li>Python, lenguaje de programaci\u00f3n de alto nivel que no se compila, sino que se interpreta.</li> </ul> </li> </ul> <p>El c\u00f3digo interpretado necesita de un interprete, que se define como la capa l\u00f3gica de software que se pone entre el c\u00f3digo y el hardware, es decir, el interprete es el encargado de procesar el c\u00f3digo de programa y hacer posible que el hardware lo ejecute.</p> <p>Aqu\u00ed vamos a usar principalmente MakeCode, MicroBlocks y MicroPython, aunque se dar\u00e1n pinceladas con otros entornos. Tambi\u00e9n abordaremos en su momento el tema IoT utiliando la placa micro:bit.</p> <p>Enlaces muy importantes son:</p> <ul> <li>Web en ingl\u00e9s</li> <li>Web en espa\u00f1ol</li> <li>Comunidad micro:bit en espa\u00f1ol</li> <li>Github de microbit</li> <li>Comunidad de desarrollo de micro:bit. Wiki de la comunidad con informaci\u00f3n t\u00e9cnica de micro:bit.</li> <li>Editor gr\u00e1fico Makecode estable.</li> <li>Web de MicroBlocks</li> <li>Editor online de MicroBlocks</li> <li>Editor Python de micro:bit. Sencillo editor de c\u00f3digo basado en navegador.</li> <li>Mu. Sencillo editor de c\u00f3digo sin conexi\u00f3n.</li> <li>uFlash. Herramienta de l\u00ednea de comandos para mostrar secuencias de comandos de Python sin procesar en un micro:bit.</li> <li>IDLE. Un IDE de c\u00f3digo abierto multiplataforma que se instala por defecto con Python.</li> <li>BBC Micro:bit MicroPython documentation.</li> <li>Instalaci\u00f3n de Mu-editor en Linux, OSX y Window.</li> <li>Bot de programaci\u00f3n Open Roberta Lab.</li> <li>Thonny. Sencillo IDE para Python.</li> </ul>"},{"location":"configura/","title":"Configurar nuestra micro:bit","text":"<p>Para poder continuar le tenemos que decir a la micro:bit lo que queremos que haga. Esto es dar a la micro:bit una serie de instrucciones contenidas en programas. Estos programas, en el caso de micro:bit, se pueden escribir de diferentes maneras y nosotros vamos a ver fundamentalmente como hacerlo en los editores online de bloques MakeCode y MicroBlocks o Python de texto.</p> <p>Debemos disponer de un ordenador, un tel\u00e9fono o una tableta para escribir el c\u00f3digo, conectar la micro:bit a nuestro dispositivo lo que haremos de alguna de estas formas:</p> <ul> <li>Con ordenador. Es la forma mas usual y sencilla y consiste en utilizar un cable microUSB para realizar la conexi\u00f3n de la micro:bit al ordenador. Esta forma la vamos a describir de manera mas extensa a continuaci\u00f3n.</li> <li>Tel\u00e9fono o tableta. En este caso debemos utilizar Bluetooth para conectar ambos dispositivos de manera inal\u00e1mbrica. Podemos consultar mas detalles en Transferir desde la aplicaci\u00f3n m\u00f3vil, web que adem\u00e1s nos va a servir de referencia para el resto de este apartado.</li> </ul>"},{"location":"configura/#transferir-desde-ordenador","title":"Transferir desde ordenador","text":"<p>Los programas de usuario se copian en la memoria flash (no volatil) de la micro:bit por lo que a esta operaci\u00f3n se le suele conocer como flasheo. La V1 tiene 256 KB de memoria flash y la V2 512 KB</p> <p>Cuando se est\u00e1 flasheando un programa la micro:bit pausa la ejecuci\u00f3n del programa que tenga en memoria y el LED amarillo de la cara posterior estar\u00e1 parpadeando mientras se est\u00e9 copiando el nuevo programa. Una vez finalizada la copia, el nuevo programa comienza a ejecutarse en la micro:bit.</p>"},{"location":"configura/#arrastrar-y-soltar","title":"Arrastrar y soltar","text":"<p>El proceso es exactamente igual que cuando transferimos un archivo desde el ordenador a un pendrive o memoria USB y funciona en cualquier ordenador. Lo que tenemos que hacer es:</p> <ul> <li>Descargar el programa como un archivo .hex desde el editor de c\u00f3digo al ordenador, habitualmente al directorio de descargas. Finalmente se arrastra y suelta el archivo .hex en la unidad MICROBIT.</li> <li>Despu\u00e9s de transferir el archivo .hex, la unidad MICROBIT se desconectar\u00e1 y reconectar\u00e1 seg\u00fan la micro:bit se reinicia. El archivo .hex no aparecer\u00e1 en la unidad MICROBIT dado que la micro:bit no es un dispositivo de almacenamiento flash, aunque el ordenador lo muestra como tal para facilitar la transferencia de archivos .hex.</li> </ul> <p>En el enlace Transferir desde la aplicaci\u00f3n m\u00f3vil hay disponibles videos que muestran c\u00f3mo funciona este sistema. Simplemente elegimos nuestro sistema operativo (Windows, Mac, Chromebook o Linux/Raspberry Pi) y vemos el proceso.</p> <p>En la animaci\u00f3n siguiente (descarga de la web citada en el p\u00e1rrafo anterior) vemos el proceso completo en el caso de Linux.</p> <p> <p> Flasheo mediante arrastrar y soltar</p> <p></p>"},{"location":"configura/#flasheo-directo","title":"Flasheo directo","text":"<p>Se pueden enviar programas directamente desde los editores de c\u00f3digo en l\u00ednea a la micro:bit sin necesidad de descargar el archivo .hex y seguir el proceso anterior, lo que resulta f\u00e1cil y r\u00e1pido.</p> <p>El flasheo directo solamente funciona en los navegadores Chrome o Edge que soportan webUSB. Tambi\u00e9n es necesario tener actualizado el firmware de la micro:bit, especialmente si es un modelo que tiene mucho tiempo.</p> <p>IMPORTANTE: EL flasheo directo es r\u00e1pido y f\u00e1cil, y excelente para la depuraci\u00f3n, pero no SE guarda una copia del programa en el ordenador. Si pra nosotros es importante mantener una copia del c\u00f3digo, es preferible utilizar el m\u00e9todo de arrastrar y soltar, o en su defecto tener siempre la precauci\u00f3n de descargar el archivo .hex o .py o .ubp cuando se ha completado exit\u00f3samente el proyecto aunque durante el proceso se relicen pruebas del funcionamiento o depuraci\u00f3n del c\u00f3digo mediante este m\u00e9todo.</p> <p>En la web de referencia tenemos disponibles videos demostrativos de como se realiza el proceso.</p>"},{"location":"plantilla/","title":"Titulo","text":""},{"location":"plantilla/#t","title":"t","text":""},{"location":"plantilla/#t_1","title":"t","text":"<p> <p> xx</p> <p></p> <p>- Consejo: </p>"},{"location":"problemas/","title":"Soluci\u00f3n de problemas","text":"<p>Hay veces que surgen problemas con la descarga webUSB porque no se consigue emparejar la micro:bit y tambi\u00e9n pueden surgir problemas cuando intentamos hacerer drag &amp; drop (arrastrar y soltar) el archivo .hex en la unidad MICROBIT montada, o incluso puede que no se monte dicha unidad.</p> <p>Cuando el intento de conexi\u00f3n nos devuelve un error en el rango 500-599, normalmente se puede corregir reintentsando el envio del .hex nuevamente o borrar enviando el archivo hexadecimal de nuevo, o enviando el software original \"Out of box experience\", traducido literalmente como \"Fuera de la caja\" pero que se traduce como Experiencia inmediata. Al final de este tambi\u00e9n se da informaci\u00f3n sobre la herramienta de flasheo online que tenemos disponible.</p> <p>Despu\u00e9s de cualquier error de transferencia siempre es buena idea desconectar el cable USB y la alimentaci\u00f3n desde bater\u00eda, para volver a conectar el USB y volver a intentarlo.</p> <p>Todas las indicaciones van a estar basadas siempre en Ubuntu 22.04.2 LTS, navegador Google Chrome o Chromium que es la versi\u00f3n open-source de Chrome y que tiene que estar instalado desde la tienda Snap.</p> <p> <p> Chromium instalado desde tienda Snap</p> <p></p> <p>La informaci\u00f3n va a estar basada, adem\u00e1s de las web citadas en webgrafia, fundamentalmente en los siguientes enlaces:</p> <ul> <li>WebUSB Troubleshooting de micro:bit Help &amp; Support.</li> <li>Ticket #64940 error: The transfer timed out. type: transient, user error 504 de micro:bit Help &amp; Support.</li> <li>En este post de Matthew Oppenheim se resuelve el problema con '50-microbit.rules' y los permisos de los directorios afectados, como por ejemplo \"media\" que normalmente es propiedad del superusuario root y no del usuario habitual. En el mismo post hay un enlace a una primera versi\u00f3n donde expone la configuraci\u00f3n de mu-editor en Linux.</li> </ul>"},{"location":"problemas/#paso-a-paso-inicial","title":"Paso a paso inicial","text":""},{"location":"problemas/#paso-1-comprobar-el-cable","title":"Paso 1: Comprobar el cable","text":"<p>Conectamos la placa micro:bit a un puerto USB mediante un cable microUSB. Debemos ver que se monta un dispositivo de nombrre MICROBIT y que est\u00e1 activo, como en la imagen siguiente:</p> <p> <p> Unidad MICROBIT montada</p> <p></p> <p>La forma de ver la unidad montada depender\u00e1 de nuestro sistema operativo.</p> <p>Si podemos ver la unidad MICROBIT montada podemos pasar al paso 2 y si no procedemos a:</p> <ul> <li>Asegurarnos que el cable no est\u00e1 da\u00f1ado. Podemos probarlo en otro ordenador o utilizar un cable diferente. Hay que tener presente que algunos cables comerciales solo conectan alimentaci\u00f3n y no tienen realizadas las conexiones de transmisi\u00f3n de datos.</li> <li>Probar en otro puerto USB del ordenador.</li> </ul> <p>Si podemos asegurar que el cable est\u00e1 bien pero no aparece la unidad MICROBIT, es posible que tengamos un problema con la micro:bit. Hay que probar los pasos adicionales descritos en la p\u00e1gina de b\u00fasqueda de fallos en microbit.org. Si esto tampoco nos ayuda, podemos crear un New support ticket para notificar el problema a la Fundaci\u00f3n Micro:bit y esperar obtener una respuesta. Si estamos en este caso hay que omitir el resto de pasos hasta obtener la respuesta.</p>"},{"location":"problemas/#paso-2-verificar-la-version-de-firmware","title":"Paso 2: Verificar la versi\u00f3n de firmware","text":"<p>Es posible que el firmware de la micro:bit necesite una actualizaci\u00f3n. Vamos a comprobarlo:</p> <ul> <li>Accedemos a la unidad MICROBIT montada.</li> <li>Abrimos con un editor de texto el archivo de solo lectura DETAILS.TXT.</li> <li>Comprobamos el n\u00famero que pone junto a Interface Version.</li> </ul> <p> <p> Comprobaci\u00f3n de la versi\u00f3n de firmware</p> <p></p> <p>Si la versi\u00f3n 0234, 0241 o 0243 es necesario actualizar el fimware de esa micro:.bit siguiendo el proceso que vamos a indicar en el paso 3. En la imagen anterior observamos que la versi\u00f3n del firmware es Interface Version: 0249.</p> <p>Si tenemos la versi\u00f3n 0249, 0250 o mayor trabajamos con el firmaware correcto y podemos saltar al paso 4.</p>"},{"location":"problemas/#paso-3-actualizar-firmware","title":"Paso 3: Actualizar firmware","text":"<p>Si se requiere una actualizaci\u00f3n del firmware para acceder a nuevas caracter\u00edsticas o para solucionar alg\u00fan problema, debemos proceder as\u00ed:</p> <ul> <li>Desconectar la micro:bit de cualquier tipo de alimentaci\u00f3n, ya sea por USB o por bateria.</li> <li>Con el pulsador de reset de la parte posterior accionado conectamos la micro:bit a un puerto USB y esperamos a que se monte una unidad llamada MAINTENANCE (en lugar de MICROBIT) como observamos en la figura siguiente.</li> </ul> <p> <p> Micro:bit en modo MAINTENANCE</p> <p></p> <p>La forma de ver la unidad montada depender\u00e1 de nuestro sistema operativo.</p> <ul> <li>Descargamos el archivo .hex apropiado para nuestra versi\u00f3n de micro:bit. El n\u00famero de versi\u00f3n est\u00e1 impreso en la parte inferior derecha de la cara trasera del dispositivo. Existen unas cuantas formas de distinguir que versi\u00f3n de placa tenemos.</li> </ul>"},{"location":"problemas/#identificar-el-numero-de-version","title":"Identificar el n\u00famero de versi\u00f3n","text":"<p>Actualmente hay dos versiones oficiales de BBC micro:bit, la V1 y la V2.</p> <p>Ambas versiones trabajan de la misma forma por lo que podemos continuar utilizando las versiones previas de la forma habitual.</p> <p>La primera forma de saber el n\u00famero de versi\u00f3n (V2.20, V2, V1.5, V1.3B) es mirar en la esquina inferior derecha de la cara posterior (figura siguiente). Si no podemos ver el n\u00famero es muy probable que tengamos una micro:bit 1.3 en la que el n\u00famero de versi\u00f3n serigrafiado se quedaba debajo de la pintura negra.</p> <p> <p> N\u00famero de versi\u00f3n serigrafiado</p> <p></p> <p>Como segunda forma, si en la parte posterior del dispositivo en versiones V2, veremos una etiquetara identifica MICROPHONE (MICR\u00d3FONO) y otra otra para el SPEAKER (ALTAVOZ), y adem\u00e1s la ANTENA BLE es de color dorado.</p> <p> <p> N\u00famero de versi\u00f3n seg\u00fan la antena</p> <p></p> <p>Para la tercer forma nos fijaremos en si el conector de borde tiene muescas que ser\u00e1n \u00fatiles para facilitar el uso de pinzas de cocodrilo o no dispone de dichas muescas. En la figura siguiente vemos la diferencia.</p> <p> <p> N\u00famero de versi\u00f3n seg\u00fan el conector de borde</p> <p></p> <p>y la cuarta forma es el logototipo de micro:bit en la parte frontal del dispositivo, que en la versi\u00f3n V2 es dorado como el conector de borde y adem\u00e1s es un pulsador t\u00e1ctil que se puede usar como un pin de entrada. En la figura vemos las diferencias.</p> <p> <p> N\u00famero de versi\u00f3n seg\u00fan el logotipo de micro:bit</p> <p></p>"},{"location":"problemas/#microbit-v1","title":"Micro:bit V1","text":"<p>Si tenemos una micro:bit V1 (sin altavoz ni micr\u00f3fono), todas las placas usan el mismo firmware.</p> <p> <p>Firmware para V1</p> <p></p>"},{"location":"problemas/#microbit-v2","title":"Micro:bit V2","text":"<p>Si tenemos una micro:bit V2 (con altavoz y micr\u00f3fono), existen dos posibles versiones de firmware; la V2.00 y la V2.20/2.21. Debemos seleccionar el firmware apropiado para nuestra placa.</p> <p> <p>Firmware para V2.00 --- Firmware para V2.20/2.21</p> <p></p> <ul> <li>Arrastramos y soltamos el fichero .hex que hemos descargado en la unidad montada como MAINTENANCE y esperamos a que el LED amarillo de la cara posterior deje de parpadear. Cuando la actualizaci\u00f3n se ha completado la micro:bit se resetear\u00e1, se expulsar\u00e1 del ordenador y volver\u00e1 a aparecer en modo MICROBIT.</li> <li>Finalmente debemos comprobar el archivo DETAILS.TXT para asegurarnos que la versi\u00f3n de firmware descargada se ha flsheado en el chip de interface.</li> <li>Si tenemos cualquier problema con el proceso de actualizaci\u00f3n del firmware debemos contactar con micro:bit support que es la p\u00e1gina de soporte en ingl\u00e9s.</li> <li>Todas las versiones de firmware, actuales, anteriores y beta est\u00e1n disponibles en previous firmware versions.</li> </ul>"},{"location":"problemas/#paso-4-comprobar-la-version-del-navegador","title":"Paso 4: Comprobar la versi\u00f3n del navegador","text":"<p>WebUSB es una caracter\u00edstica muy actual y puede requerir que el navegador est\u00e9 actualizado. Verifiquemos que el navegador coincida con los descritos navegadores soportados. Est\u00e1n soportados diferentes navegadores como Microsoft Edge, Google Chrome o Chromium, Mozilla Firefox y Safari para los distintos sistemas operativos y versiones.</p>"},{"location":"problemas/#paso-5-emparejar-dispositivo","title":"Paso 5: Emparejar dispositivo","text":"<p>Una vez que hemos actualizado el firmware, abrimos nuestro navegador compatible, vamos al editor que estemos utilizando para programar y procedemos a Emparejar dispositivo. Ya estamos preparados para comenzar a trabajar siguiendo los pasos iniciales que se describen en Configurar nuestra micro:bit.</p>"},{"location":"problemas/#flasheo-directo","title":"Flasheo directo","text":"<p>Vamos a ver que necesitamos para poder grabar firmware en la micro:bit desde la p\u00e1gina web del editor que estemos utilizando mediante webUSB para posteriormente atajar los posibles problemas. Comenzamos por un resumen de las condiciones en las que se documenta esto, que son:</p> <ul> <li>Sistema operativo Ubuntu 22.04.2 LTS de 64 bits.</li> <li>Inicialmente el navegador utilizado ha sido Chromium Versi\u00f3n 114.0.5735.198 (Build oficial) snap (64 bits). Tambi\u00e9n se realizan pruebas con el navegador Google Chrome Versi\u00f3n 115.0.5790.110 (Build oficial) (64 bits).</li> <li>El flasheo directo solamente funciona en los navegadores Chrome o Edge que soportan webUSB.</li> <li>Recordemos que tambi\u00e9n es necesario tener actualizado el firmware de la micro:bit.</li> </ul> <p>La micro:bit nos debe aparecer en el navegador como BBC micro:bit CMSIS-DAP aunque es posible que la primera vez nos aparezca como LPC1768.</p> <p>Si nos estamos cambiando entre editores, por ejemplo MakeCode y Python, seguramente la actualizaci\u00f3n de programas mediante webUSB requiere mas tiempo del habitual ya que la micro:bit contiene un programa creado con un editor diferente.</p> <p>Si tenemos problemas cuando tenemos conectada alimentaci\u00f3n externa, procedemos a desconectar esta alimentaci\u00f3n y el cable microUSB garantizando asi el total apagado de la placa. Conectamos solamente el cable microUSB tanto a la micro:bit como al ordenador e intentamos de nuevo el flasheo. Es indiferente para esto conectar la bateria tras conectar el cable microUSB o hacerlo en otro momento.</p> <p>Si estamos en un sistema Linux y se ha instalado Chromium desde snap store, que es la tienda oficial de software de Ubuntu, no podremos acceder a dispositivos webUSB. En distribuciones como Ubuntu suele solucionar el problema declarar una regla udev. A continuaci\u00f3n se indica como hacerlo.</p> <p>Cuando trabajamos con distribuciones Linux en general o Ubuntu en particular hay que declarar una regla 'udev' y para hacerlo debemos seguir una serie de pasos que describimos a continuaci\u00f3n:</p> <ul> <li>Cerramos el navegador Chrome o Chromium.</li> <li>Abrimos una terminal de comandos</li> <li>Comprobamos si existe un grupo de usuaraios llamado 'plugdev' utilizando el comando 'getent', que nos devuelve las entradas de la base de datos administrativa del sistema. Se puede solicitar de 'passwd, group, hosts, services, protocols, o networks'. En nuestro caso nos interesa de 'gropu', por lo que hacemos:</li> </ul> <pre><code>getent group\n</code></pre> <p>En el resultado debemos buscar el grupo y si existe aparecer\u00e1 listado. En caso de que no exista lo creamos con:</p> <pre><code>getent group plugdev &gt;/dev/null || sudo groupadd -r plugdev\n</code></pre> <p>Si resulta necesario porque el grupo lo cre\u00f3 un usuario distinto a nosotros, deberemos agregar nuestro usuario al grupo 'plugdev' seg\u00fan vemos a continuaci\u00f3n. Debemos reemplazar  con el nombre real de nuestro usuario. <pre><code>sudo usermod -a -G plugdev &lt;tu-nombre-de-usuario&gt;\n</code></pre> <ul> <li>Creamos un archivo en el directorio '/etc/udev/rules.d' que llamaremos '50-microbit.rules' haciendo:</li> </ul> <pre><code>sudo nano/etc/udev/rules.d/50-microbit.rules\n</code></pre> <p>En el editor escribimos:</p> <p>'SUBSYSTEM==\"usb\", ATTR{idVendor}==\"0d28\", MODE=\"0664\", GROUP=\"plugdev\"'</p> <p>y ya podemos guardar el archivo en el directorio indicado y con el nombre citado.</p> <p>Salimos del editor y podemos continuar. El siguiente comando nos ayuda a mostrar si hemos creado bien la regla ya que nos muestra el contenido del archivo creado.</p> <pre><code>cat /etc/udev/rules.d/50-microbit.rules\n</code></pre> <p> <p> Comando Cat</p> <p></p> <p>El comando 'Cat' toma su nombre de concatenar y permite crear, unir y consultar el contenido del archivo que le indiquemos.</p> <p>Es IMPORTANTE saber que el archivo de reglas de estar creado por un usuario root, o incluso el propio root del sistema. No voy a entrar en detalles sobre el tema del superusuario en Linux debido a los peligros que conlleva trabajar con este nivel de permisos sin ser un experto. Algunas de sentencias que hemos puesto van precedidas de 'sudo', que indica que lo que se va a hacer se har\u00e1 como usuario con privilegios de root, pero este no es exactamente el superusuario. En la entrada Tipos de permisos en Linux de la introducci\u00f3n a Python hay mas informaci\u00f3n sobre el tema. Se advierte que trabajar con estos temas sin ser experto puede crear da\u00f1os irreversibles en el sistema. Para asegurar estos cambios, si se han realizado, es conveniente reiniciar siempre el sistema.</p> <ul> <li>Cerramos o reiniciamos el ordenador.</li> <li>Abrimos el navegador.</li> <li>Comprobamos si se ha establecido la conexi\u00f3n mediante los comandos siguientes:</li> </ul> <pre><code>snap connections  | grep -v \".*-$\nmount | grep MICROBIT\n</code></pre> <p>El comando 'snap' permite instalar, configurar, actualizar y eliminar paquetes y mediante 'grep' buscamos si dentro del fichero connections el navegador ha establecido la conexi\u00f3n y si la misma est\u00e1 realizada. Si todo es correcto devolver\u00e1 Plug = chromium:raw-usb y connector = raw-usb. El segundo nos ayuda a montar la unidad \"MICROBIT\" si no se monta al conectar una placa micro:bit. En la figura siguiente vemos un posible resultado.</p> <p> <p> Comandos snap connections y mount</p> <p></p> <p>En el bug de Chromium citado en la parte de Linux indica, antes de entrar en la creaci\u00f3n de reglas lo siguiente:</p> <ul> <li>Si Chromium se ha instalado desde la tienda snap no se podr\u00e1 acceder a los dispositivos WebUSB. En este caso, WebUSB se puede habilitar utilizando la interfaz 'raw-usb', que permite el acceso a todos los dispositivos USB conectados a trav\u00e9s de una interfaz sin formato que no tiene una conexi\u00f3n autom\u00e1tica. Se habilita desde la l\u00ednea de comandos as\u00ed:</li> </ul> <pre><code> snap connect chromium:raw-usb\n</code></pre> <p>que deber\u00eda servir para versiones de Chromium posteriores a julio de 2020.</p> <ul> <li>Si en alg\u00fan momento dudamos si se est\u00e1 aplicando la nueva regla tras alg\u00fan cambio realizado podemos reiniciar las mismas haciendo:</li> </ul> <pre><code>sudo udevadm control --reload-rules\n</code></pre> <p>Si al hacer clic en los tres puntos para realizar la conexi\u00f3n se genera un error como el que vemos en la imagen siguiente es evidente que no vamos a poder flashear el firmware en esas condiciones.</p> <p> <p> Errores de conexi\u00f3n en MakeCode y Python</p> <p></p> <p>Si hemos dado todos los pasos anteriores y no funciona puede deberse a diversas causas y una muy probable es que los permisos dados en el navegador para el dispositivo est\u00e9n emparejados para otra aplicaci\u00f3n o dispositivo y esto no permite continuar. A la izquierda en la barra de navegaci\u00f3n podemos ver un peque\u00f1o candado que es un bot\u00f3n que nos da informaci\u00f3n del sitio y que permite borrar los emparejamientos. En la imagen vemos la situaci\u00f3n.</p> <p> <p> Borrar emparejamiento</p> <p></p> <p>Si seguimos el orden num\u00e9rico indicado, tras borrar el emparejamiento debemos cerrar la ventana abierta al clicar el candado y veremos la siguiente situaci\u00f3n:</p> <p> <p> Recargar la p\u00e1gina</p> <p></p> <p>Esta acci\u00f3n restablece el estado del navegador. Si esto no nos funciona a la primera debemos probar a repetirlo un par de veces mas dado que a veces webUSB se desincroniza. Tambi\u00e9n es conveniente combinarlo con desconectar y conectar el USB.</p>"},{"location":"problemas/#pruebas-finales","title":"Pruebas finales","text":"<p>Para comprobar que todos los cambios propuestos anteriormente se han realizado correctamente vamos a ejecutar desde una terminal los comandos siguientes:</p> <pre><code>groups\ncat /etc/udev/rules.d/50-microbit.rules\nls -l /etc/udev/rules.d\n</code></pre> <p>Como vemos en la imagen siguiente, el primer comando nos indica que el usuario est\u00e1 en el grupo requerido, el segundo nos muestra la sintaxis de la regla creada y con el tercero simplemente comprobamos que el fichero creado efectivamente est\u00e1 y adem\u00e1s en el directorio correspondiente.</p> <p> <p> Creaci\u00f3n regla udev</p> <p></p> <p>En la imagen se ha indicado la existencia del archivo de reglas udev creado con la instalaci\u00f3n del navegador Chromium, pero en este no existe ninguna regla para micro:bit y personalmente no he querido tocar el mismo.</p>"},{"location":"problemas/#makecode","title":"MakeCode","text":"<p>Iniciamos el navegador Chromium o Google Chrome, este \u00faltimo preferiblemente desde un perfil sin cuenta o con una cuenta que tenga poca actividad.</p> <p>Conectamos nuestra micro:bit a un puerto USB y procedemos a emparejarla con el navegador. Si nos da alg\u00fan tipo de error debemos probar a desconectar y volver a conectar la micro:bit del USB y repetir la operaci\u00f3n.</p> <p>Para el caso de Chromium ser\u00e1 algo similar a lo siguiente:</p> <p> <p> Flasheo directo en Chromium</p> <p></p> <p>Para el caso de Chrome ser\u00e1 algo similar a lo siguiente:</p> <p> <p> Flasheo directo en Chrome</p> <p></p>"},{"location":"problemas/#python","title":"Python","text":"<p>Para el caso de Chromium ser\u00e1 algo similar a lo siguiente:</p> <p> <p> Flasheo directo en Chromium</p> <p></p> <p>Para el caso de Chrome ser\u00e1 algo similar a lo siguiente:</p> <p> <p> Flasheo directo en Chrome</p> <p></p> <p>Tenemos que recordar siempre archivar nuestro trabajo.</p>"},{"location":"problemas/#mas-reglas-udev","title":"Mas reglas udev","text":"<p>Vamos a instalar en el sistema una nueva regla propuesta por Martin Williams en el ticket Ticket #64940 error: The transfer timed out. type: transient, user error 504. En este caso enfocado al sistema de grabaci\u00f3n de firmware drag &amp; drop. Si seguimos viendo el error 504, vamos a trabajar con otra regla udev que podemos eliminar si nos ocasiona problemas secundarios.</p> <p>Ser\u00eda conveniente tener un historial de pruebsas anterior a la instalaci\u00f3n de la nueva regla para poder comparalas con las que hagamos despu\u00e9s de instalarla. Con una micro:bit conectada ejecutamos el comando:</p> <pre><code>mount | grep MICROBIT\n</code></pre> <p>En mi caso devuelve lo siguiente:</p> <p> <p> Antes de la nueva regla udev</p> <p></p> <p>Para los siguientes pasos desconectamos la micro:bit del ordenador y reiniciamos las reglas udev.</p> <p>Nos descargamos el archivo 99-microbit-udisks.zip y lo descomprimimos en un directorio aparte. Hacemos una copia del archivo descomprimido en el directorio de reglas '/etc/udev/rules.d'. Para ello hacemos:</p> <pre><code>sudo cp 99-microbit-udisks.rules /etc/udev/rules.d\n</code></pre> <p>Hacemos la comprobaci\u00f3n de quien es el propietario, los permisos y el grupo al que pertenece el nuevo archivo. Esto lo podemos hacer con el comando:</p> <pre><code>ls -l /etc/udev/rules.d\n</code></pre> <p>Reiniciamos udev:</p> <pre><code>sudo udevadm control --reload-rules\nsudo udevadm trigger\n</code></pre> <p>Volvemos a conectar la micro:bit y comprobamos de nuevo con:</p> <pre><code>mount | grep MICROBIT\n</code></pre> <p> <p> Despu\u00e9s de la nueva regla udev</p> <p></p> <p>La \u00fanica diferencia deber\u00eda ser que se ha a\u00f1adido \"sync\".</p>"},{"location":"problemas/#sistema-de-prueba","title":"Sistema de prueba","text":"<p>Mediante el hilo indicado en la webgrafia y utilizando la informaci\u00f3n obtenida de WebUSB Troubleshooting ha quedado resuelto el tema de utilizar webUSB con Chromium y se propone un m\u00e9todo de prueba de errores que a mi entender nos puede resultar bastante \u00fatil en un momento determinado.</p> <p>Cuando estamos teniendo problemas para grabar firmware mediante la t\u00e9cnica de arrastrar y soltar (drag &amp; drop) y/o flasheando desde la web del editor, nos resultar\u00e1 \u00fatil disponer de una colecci\u00f3n de archivos que permitan ir realizando pruebas al tiempo que llevamos la cuenta de las pruebas realizadas.</p> <p>Es Martin Williams de Micro:bit Educational Foundation quien propone el sistema y el procedimiento a seguir.</p> <ul> <li>Siempre que tengamos un error tenemos que desconectar y volver a conectar el USB antes de probar de nuevo con el mismo archivo.</li> <li>Crear un script de Python en el que podamos ir cambiando el n\u00famero de intento cuando el programa se flashea o graba correctamente.</li> </ul> <p>El script de Python propuesto lo he modificado y queda as\u00ed:</p> <pre><code># Las importaciones al principio\n\"\"\"En Python, se utiliza la palabra clave import \npara hacer que el c\u00f3digo de un m\u00f3dulo est\u00e9 \ndisponible en otro.\"\"\"\nfrom microbit import *\n\ndisplay.show(Image.HEART)\nsleep(1000)\n\n# El c\u00f3digo en'while True:' se repite indefinidamente\nwhile True:\n    display.show(0) #Contamos cambiando el valor aqu\u00ed\n    sleep(1000)\n</code></pre> <p>En el fichero 10_archivos_hex_python.zip tenemos los 10 archivos hexadecimal generados y probados. El primero de los cuales (python0-main.py) tambi\u00e9n lo tenemos en formato texto.</p> <p>Probamos arrastrando cada archivo de manera sucesiva. Si se produce alg\u00fan fallo volvemos a desconectar y conectar el USB y probamos de nuevo el mismo archivo. Podemos ir anotando el n\u00famero de fallos que se producen al transferir los 10 archivos.</p> <p>Tambi\u00e9n probamos a cargar el archivo '0' en el Editor Python, y lo flasheamos directamente desde el editor a la unidad micro:bit y hacemos el procerso de reconectar si es necesario. Vamos cambiando el n\u00famero cuando tenemos \u00e9xito, hasta que he lleguemos al n\u00famero 9. Cambiando el n\u00famero se comprueba que el archivo se est\u00e1 transfiriendo realmente, \u00a1y ayuda a no perder la cuenta!</p>"},{"location":"Miscelanea/about/","title":"Autor","text":"<p>Federico Coca</p> <ul> <li> <p>GitHub</p> </li> <li> <p>Twitter</p> </li> <li> <p>Instagram</p> </li> <li> <p>Mas informaci\u00f3n</p> </li> </ul>"},{"location":"Miscelanea/lic/","title":"Licencias","text":"<ul> <li> <p>Licencia MIT incluida en la creaci\u00f3n del repositorio.</p> </li> <li> <p>Creative Commons Atribuci\u00f3n-CompartirIgual 4.0 International (\"CC BY-SA\"). CC BY-SA 4.0 </p> </li> </ul> <p> <p> </p> <p></p>"},{"location":"Miscelanea/soft/","title":"Software utilizado","text":"<ul> <li> <p>Sistema operativo: Ubuntu 22.04</p> </li> <li> <p>Paquete ofim\u00e1tico de referencia: LibreOffice</p> </li> <li> <p>Libreria Material para MkDocs</p> </li> <li> <p>Visual Studio Code</p> </li> <li> <p>Creaci\u00f3n de GIF animados para Ubuntu Peek</p> </li> <li> <p>Sistema principal de capturas de pantalla: Shutter</p> </li> <li> <p>Dibujo 2D vectorial Inkscape</p> </li> <li> <p>Retoque de im\u00e1genes GIMP</p> </li> <li> <p>Editor gr\u00e1fico Makecode estable.</p> </li> <li> <p>Editor de MicroBlocks</p> </li> <li> <p>Editor Python de micro:bit.</p> </li> <li> <p>Mu.</p> </li> <li> <p>IDLE.</p> </li> <li> <p>Thonny. Sencillo IDE para Python.</p> </li> </ul>"},{"location":"Miscelanea/webgrafia/","title":"Webgraf\u00eda y bibliograf\u00eda","text":"<ul> <li> <p>Wikipedia</p> </li> <li> <p>Web en ingl\u00e9s</p> </li> <li>Web en espa\u00f1ol</li> <li>Comunidad micro:bit en espa\u00f1ol</li> <li>Github de microbit</li> <li>Comunidad de desarrollo de micro:bit. Wiki de la comunidad con informaci\u00f3n t\u00e9cnica de micro:bit.</li> <li>Editor gr\u00e1fico Makecode estable.</li> <li>Web de MicroBlocks</li> <li>Editor online de MicroBlocks</li> <li>Editor Python de micro:bit. Sencillo editor de c\u00f3digo basado en navegador.</li> <li>Mu. Sencillo editor de c\u00f3digo sin conexi\u00f3n.</li> <li>uFlash. Herramienta de l\u00ednea de comandos para mostrar secuencias de comandos de Python sin procesar en un micro:bit.</li> <li>IDLE. Un IDE de c\u00f3digo abierto multiplataforma que se instala por defecto con Python.</li> <li>BBC Micro:bit MicroPython documentation.</li> <li>Instalaci\u00f3n de Mu-editor en Linux, OSX y Window.</li> <li>Bot de programaci\u00f3n Open Roberta Lab.</li> <li> <p>Thonny. Sencillo IDE para Python.</p> </li> <li> <p>Gu\u00eda Programiz para aprender Python programando. Incluye un interesante compilador online y otros muchos recursos.</p> </li> <li> <p>Web Ardutaller de Francisco Soldado.</p> </li> <li> <p>MicroBlocks Wiki</p> </li> <li> <p>micro:bit Micropython API</p> </li> <li>Gu\u00eda de micro:bit paso a paso para principiantes de Bricogeek.</li> <li>Recursos sobre micro:bit de Pedro Ruiz.</li> <li> <p>Retos de Micro:bit con Python por Pedro Ruiz</p> </li> <li> <p>Consulta realizada en \u00bfC\u00f3mo podemos ayudarte? de micro:bit Help &amp; Support con el ticket 64940 referente a un error 504 con una BBC micro:bit V2.00 sobre Ubuntu 22.04.2 LTS con navegador Chromium 114.0.5735.198 version.</p> </li> </ul>"},{"location":"actividades/A01/","title":"A01. Hola mundo","text":"<p>La manera habitual de comenzar a programar en un nuevo lenguaje es hacer que el ordenador o dispositivo programable nos salude con un \"\u00a1Hola, mundo!\". Pues hagamos esto en los tres sistemas elegidos: MicroPython, MakeCode y MicroBlocks. Animamos a probar otros programas de los citados en la webgraf\u00eda.</p>"},{"location":"actividades/A01/#micropython","title":"MicroPython","text":"<p>El programa de la actividad lo vamos a hacer utilizando algunas de las cosas descritas y comentando las l\u00edneas para que se entienda mejor. El c\u00f3digo del programa es el siguiente:</p> <pre><code># Las importaciones van a la cabeza\nfrom microbit import * #Usar todo de la biblioteca microbit\ndisplay.clear() #Borra pantalla\ndisplay.scroll('\u00a1Hola Mundo!', delay=100) #Desplaza el texto por pantalla\nsleep(1000) #Espera 1s\ndisplay.show(Image.HAPPY) #Muestra carita alegre\nsleep(1000)\ndisplay.clear()\ndisplay.set_pixel(0,0,3) #Encendemos pixel al brillo establecido\ndisplay.set_pixel(2,2,9)\ndisplay.set_pixel(4,0,3)\n</code></pre> <p>En la animaci\u00f3n vemos el funcionamiento en el simulador y el efecto de cambiar el valor del delay y del valor del brillo de uno de los LED.</p> <p> <p> Funcionamiento del programa</p> <p></p> <p>Si observamos bien, al principio del texto aparecen unas interrogaciones en lugar de el signo de abrir admiraci\u00f3n. Esto es debido a que micro:bit no muestra caracteres especiales como \u00a1, \u00bf, \u00f1, acentos, etc.</p> <p>El programa lo podemos descargar de:</p> <ul> <li>A01-Hola_Mundo-main en hexadecimal</li> <li>A01-Hola_Mundo-main en Python</li> </ul>"},{"location":"actividades/A01/#makecode","title":"MakeCode","text":"<p>El programa de la actividad lo vamos a hacer utilizando los bloques descritos y comentando algunas de las l\u00edneas para que se entienda mejor. El programa es el siguiente:</p> <p> <p> Programa de la actividad A01 en MakeCode</p> <p></p> <p>En la animaci\u00f3n vemos el funcionamiento en el simulador.</p> <p> <p> Funcionamiento del programa</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>microbit-A01-Hola_Mundo</li> </ul>"},{"location":"actividades/A01/#microblocks","title":"MicroBlocks","text":"<p>Se explican los bloques utilizados de los men\u00fas de bloques por defecto y de la libreria a\u00f1adida. Referencia a Blocks Reference.</p> <p>El programa de la actividad lo vamos a hacer utilizando los bloques descritos. El programa es el siguiente:</p> <p> <p> Programa de la actividad A01 en MicroBlocks</p> <p></p> <p>En el caso de MicroBlocks no disponemos de simulador pero los botones Iniciar/parar nos permiten estar viendo en la placa real todo lo que ocurre mientra elaboramos nuestro programa.</p> <p>El programa lo podemos descargar de:</p> <ul> <li>A01-Hola_Mundo.ubp</li> </ul>"},{"location":"actividades/A02/","title":"A02. Im\u00e1genes","text":"<p>Vamos a entrar en las posibilidades art\u00edsticas que nos puede ofrecer una matriz cuadrada de 5x5 LEDs.</p>"},{"location":"actividades/A02/#micropython","title":"MicroPython","text":"<p>Vamos a hacer el ejemplo del coraz\u00f3n que late. Resulta muy f\u00e1cil de resolver pues ya est\u00e1n predise\u00f1adas las im\u00e1genes de un coraz\u00f3n grande y peque\u00f1o.</p> <pre><code>from microbit import *\ndisplay.clear()\nwhile True:\n    display.show(Image.HEART_SMALL)\n    sleep(300)\n    display.show(Image.HEART)\n    sleep(300)\n</code></pre> <p>En la animaci\u00f3n vemos su funcionamiento.</p> <p> <p> Coraz\u00f3n latiendo</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>A02-Corazon_latiendo en hexadecimal</li> <li>A02-Corazon_latiendo en Python</li> </ul>"},{"location":"actividades/A02/#makecode","title":"MakeCode","text":"<p>El programa de corazon latiendo es el siguiente:</p> <p> <p> Programa de la actividad A02 en MakeCode</p> <p></p> <p>En la animaci\u00f3n vemos el funcionamiento en el simulador.</p> <p> <p> Funcionamiento del programa</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>A02-Coraz\u00f3n_latiendo</li> </ul>"},{"location":"actividades/A02/#microblocks","title":"MicroBlocks","text":"<p>Todos los bloques que se requieren para resolver el problema del coraz\u00f3n latiendo se han explicado y no se requiere nada nuevo. Pero en MicroBlocks no tenemos una definici\u00f3n previa de los corazones por lo que tendremos que crearla nosotros a partir del bloque \"pantalla\", tal y como vemos en la imagen siguiente.</p> <p> <p> Dibujos de los corazones en el bloque pantalla</p> <p></p> <p>El programa de la actividad lo vamos a hacer utilizando los bloques descritos. El programa es el siguiente:</p> <p> <p> Programa de la actividad A02 en MicroBlocks</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>A02-Corazon_latiendo.ubp</li> </ul>"},{"location":"actividades/A03/","title":"A03. Botones on board","text":"<p>Los ejemplos vistos hasta ahora han permitido que la micro:bit nos muestre algo. Esto es lo que se conoce como salida. Ahora bien, es evidente que necesitamos tambi\u00e9n que la micro:bit reaccione a cosas externas, y estas cosas se denominan entradas. Para que sea f\u00e1cil de recordar:</p> <ul> <li>Salida es lo que micro:bit nos muestra</li> <li>Entrada es lo que recibe la micro:bit para procesarlo</li> </ul> <p>Aunque existen otros sistemas, por ahora nos vamos a centrar en los botones de la micro:bit. Si trabajamos con versiones anteriores a la V2 disponemos de dos botones etiquetados como A y B. Si trabajamos con alguna versi\u00f3n V2 disponemos adem\u00e1s de un tercer bot\u00f3n, en este caso tactil, que est\u00e1 en el logo de la placa. En la imagen vemos estos botones.</p> <p> <p> Botones en las micro:bit V1 y V2</p> <p></p>"},{"location":"actividades/A03/#micropython","title":"MicroPython","text":"<p>El programa que vamos a crear como ejemplo nos va a mostrar en la pantalla el bot\u00f3n que estamos pulsando mientras lo mantengamos accionado.</p> <p>El c\u00f3digo del programa 'Boton_pulsado' es el siguiente:</p> <pre><code>from microbit import *\n\nwhile True:\n    if button_a.is_pressed():\n        display.scroll('A')\n    elif button_b.is_pressed():\n        display.scroll('B')\n</code></pre> <p>El funcionamiento lo vemos en la animaci\u00f3n siguiente:</p> <p> <p> Muestra 'Boton_pulsado' funcionando</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>A03-Boton_pulsado en hexadecimal</li> <li>A03-Boton_pulsado en Python</li> </ul>"},{"location":"actividades/A03/#makecode","title":"MakeCode","text":"<p>El programa que vamos a crear como ejemplo nos va a mostrar en la pantalla el bot\u00f3n que estamos pulsando mientras lo mantengamos accionado. El programa es el siguiente:</p> <p> <p> </p> <p></p> <p>En la animaci\u00f3n vemos el funcionamiento en el simulador.</p> <p> <p> </p> <p>Funcionamiento del programa</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>A03-boton_pulsado</li> </ul>"},{"location":"actividades/A03/#microblocks","title":"MicroBlocks","text":"<p>El programa que vamos a crear como ejemplo nos va a mostrar en la pantalla el bot\u00f3n que estamos pulsando mientras lo mantengamos accionado. El programa es el siguiente:</p> <p> <p> Programa de la actividad A03 en MicroBlocks</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>A03-boton-pulsado.ubp</li> </ul>"},{"location":"actividades/A04/","title":"Pines de entrada/salida","text":"<p>En el borde inferior de la BBC micro:bit hay unos pads (tiras o pines) de color dorado, met\u00e1licos que constituyen los pines de entrada/salida (E/S para abreviar).</p> <p> <p> Pines de E/S para las micro:bit versiones V1 y V2</p> <p></p> <p>Como podemos observar, las patillas serigrafiadas (0, 1, 2, 3V y GND) son m\u00e1s grandes que las otras. Esto se hace as\u00ed para poder sujetar en las mismas cables con pinzas de cocodrilo. Para poder acceder al resto de patillas ser\u00e1 necesario conectar una placa de extensi\u00f3n de conectores al dispositivo micro:bit, y as\u00ed hacer posible la conexi\u00f3n de cables a esos pines m\u00e1s peque\u00f1os. Describiremos estas placas mas adelante en este apartado</p> <p>En la micro:bit V2 el logo tambi\u00e9n se puede utilizar como entrada t\u00e1ctil, es decir, es un pin de entrada, en concreto el 26.</p>"},{"location":"actividades/A04/#informacion-tecnica","title":"Informaci\u00f3n t\u00e9cnica","text":"<p>Fuente: Edge Connector &amp; micro:bit pinout.</p> <p>El conector de borde del micro:bit se utiliza para conectar circuitos y componentes externos.</p> <p>Hay en total 25 pads o pines que incluyen 5 orificios para usar con conectores tipo banana de 4mm o pinzas de cocodrilo. Tres de estos pines son para E/S de prop\u00f3sito general y tambi\u00e9n pueden ser entradas anal\u00f3gicas, PWM y sensores t\u00e1ctiles, est\u00e1ndo dos de ellas conectadas a la fuente de alimentaci\u00f3n de micro:bit.</p> <p>Las tiras m\u00e1s peque\u00f1as est\u00e1n distanciadas a 1,27 mm (50 mils) en el conector de borde y algunas est\u00e1n utilizadas por la micro:bit, mientras que otras quedan libres para su utilizaci\u00f3n.</p> <p>Aunque los pines est\u00e1n en ambas caras realmente s\u00f3lo los de la cara frontal est\u00e1n conectados a se\u00f1ales. Los agujeros si conectan ambas caras entre si pero no as\u00ed los pines mas delgados.</p>"},{"location":"actividades/A04/#pines-del-conector-de-borde","title":"Pines del conector de borde","text":"<p>La imagen siguiente muestra la asignaci\u00f3n de los pines de la micro:bit para ambas versiones de placa. En las placas V2, el pin 9 ya no se comparte con la pantalla LED. Aunque la caracter\u00edstica est\u00e1 dfesactivada por defecto, los pines 8 y 9 pueden configurarse para NFC (Near-field communication) o comunicaci\u00f3n de campo cercano, que es una tecnolog\u00eda de comunicaci\u00f3n inal\u00e1mbrica, de corto alcance y alta frecuencia que permite el intercambio de datos entre dispositivos. Esto es lo que se conoce como comunicaciones por radio en placas micro:bit.</p> <p> <p> Pinout micro:bit V2 y V1</p> <p></p> <p>Hay disponible un recurso externo fant\u00e1stico para obtener m\u00e1s informaci\u00f3n sobre los pines de la micro:bit y c\u00f3mo los utilizan algunos accesorios, se trata de microbit.pinout.xyz.</p> <p>En la imagen siguiente se muestran mas datos sobre cada uno de los pines del conector de borde de la micro:bit V1.</p> <p> <p> Informaci\u00f3n de pines micro:bit V1</p> <p></p> <p>En la imagen siguiente se muestran mas datos sobre cada uno de los pines del conector de borde de la micro:bit V2.</p> <p> <p> Informaci\u00f3n de pines micro:bit V2</p> <p></p> <p>Las siguientes notas est\u00e1n referidas a las dos figuras anteriores:</p> <ul> <li>Las resistencias de pull-up o pull-down se especifican, por ejemplo como e10Mu que significa: externa de 10Mohm en pullup o bien i12Kd, que significa: interna de 12K en pulldown.</li> </ul> <p>En las figuras del borde de placa se espcifican los valores y tipos de resistencia disponibles en el caso de micro:bit.</p> <ul> <li>Los anillos para 0, 1, 2, 3V y GND tambi\u00e9n est\u00e1n conectados a los respectivos anillos de la parte posterior del conector de borde.</li> <li>Los anillos de 3V y GND tienen unos pines protectores a ambos lados de los mas grandes, para evitar cualquier degradaci\u00f3n del rendimiento del dispositivo debido al deslizamiento de las conexiones de las pinzas de cocodrilo. Se debe tener precauci\u00f3n en los anillos 0, 1 y 2 para evitar cortocircuitar las pinzas de cocodrilo con los pines adyacentes.</li> <li>Los pines de entrada digital est\u00e1n configurados por defecto con resistencias pull down internas.</li> <li>El pin marcado como Accesibilidad se utiliza para activar/desactivar el modo de acceso a configuraciones de f\u00e1brica y no debe ser utilizado para otra cosa, a pesar de que puede ser utilizado como un GPIO para pruebas.</li> <li>En cuanto a la alimentaci\u00f3n de la placa existe un punto clave a tener en cuenta, que son los dos diodos BAT60A que hay, uno de la alimentaci\u00f3n de 3,3V del chip de interface y otro del conector de la bater\u00eda externa. Hay que tener en cuenta que el anillo de 3V en el conector de borde es V_TGT, que significa que est\u00e1 conectado al suministro en bruto proporcionado a todos los chips de la placa.</li> </ul>"},{"location":"actividades/A04/#cambiar-la-funcionalidad-por-defecto","title":"Cambiar la funcionalidad por defecto","text":"<ul> <li>pines P3, P4, P6, P7, P9, P10</li> </ul> <p>Estos pines est\u00e1n dedicados a la pantalla matriz de LEDs, y tambi\u00e9n a su modo asociado de detecci\u00f3n de luz ambiental. Para desactivar la funci\u00f3n de controlador de pantalla (que autom\u00e1ticamente desactivar\u00e1 la funci\u00f3n de detecci\u00f3n de luz) se invoca a la funci\u00f3n 'display.enable(false)'. Para volver a activar el controlador de pantalla, se invoca a la funci\u00f3n 'display.enable(true)'.</p> <ul> <li>pines P5, P11</li> </ul> <p>Estos pines est\u00e1n asignados a los dos botones A y B de la placa. En su configuraci\u00f3n por defecto con todos los lenguajes de alto nivel est\u00e1ndar, hay una instancia uBit global que contiene: uBit.buttonA, uBit.buttonB y uBit.buttonAB.</p> <p>Los botones est\u00e1n conectados con al temporizador del sistema en su construcci\u00f3n. Sin embargo, si necesitamos eliminar completamente esta caracter\u00edstica y utilizar los pines f\u00edsicos para otros fines, se pueden eliminar uBit.buttonA llamando al destructor de C++. Hay que tener en cuenta, sin embargo, que hay resistencias pull-up externas de 10K instaladas en la placa micro:bit.</p> <ul> <li>pines P19, P20</li> </ul> <p>Estos pines est\u00e1n asignados al bus I2C, que es utilizado tanto por el sensor de movimiento integrado. Se recomienda evitar el uso de estos pines para cualquier funci\u00f3n que no sea I2C.</p>"},{"location":"actividades/A04/#alimentacion","title":"Alimentaci\u00f3n","text":"<p>A la micro:bit se le puede suministrar alimentaci\u00f3n por:</p> <ul> <li>USB a trav\u00e9s del chip de interface que incorpora su propio regulador en la placa.</li> <li>Una bater\u00eda conectada al conector tipo JST que est\u00e1 junto al bot\u00f3n de reset.</li> <li>Los pines de 3V y GND en el conector de borde.</li> <li>Los dos pads ovalados (rectangulares redondeados) en la parte posterior derecha de la placa.</li> <li>La micro:bit puede suministrar alimentaci\u00f3n desde los pines 3V y GND a peque\u00f1os circuitos externos.</li> </ul> <p>Es importante respetar los par\u00e1metros m\u00e1ximos para los que est\u00e1 dise\u00f1ada la placa:</p> <ul> <li>Cuando se alimenta desde USB, el chip de interface de la placa, en V1 la versi\u00f3n (KL26) utiliza su regulador para proporcionar la energ\u00eda, y este chip puede entregar como m\u00e1ximo 120mA.</li> <li>El consumo de corriente de la placa variar\u00e1 en funci\u00f3n del uso de la pantalla, el Bluetooth, el micr\u00f3fono, el altavoz y otros perif\u00e9ricos. En el peor de los casos, tenemos que prever una demanda de 30 mA cuando se utilizan todos los perif\u00e9ricos integrados, dejando para el conector de borde 90 mA en el caso de V1 y 270 mA en el de V2.</li> <li>Cuando se alimenta desde una bater\u00eda, el chip KL no interviene y el LED indicador de USB no se ilumina.</li> <li>Se utiliza un diodo de baja tensi\u00f3n directa o Vf para conmutar entre fuentes. El diodo evita la retroalimentaci\u00f3n de cualquier fuente desde otra fuente, lo que significa que se puede tener un cable USB y un pack de bater\u00edas conectados simult\u00e1neamente.</li> </ul> <p>El rango de tensiones de alimentaci\u00f3n depende de la versi\u00f3n concreta, vienen impuestas por la circuiter\u00eda que utilizan, y son:</p> <ul> <li>Variantes de V1.3: 1.95V min y 3.6V max</li> <li>Variantes de V1.5: 1.8V min y 3.6V max</li> <li>Revisi\u00f3n V2.00: 1.7V min y 3.6V max</li> <li>Revisi\u00f3n V2.2x: 1.7V min y 3.6V max</li> </ul> <p>A continuaci\u00f3n se dan algunos detalles pr\u00e1cticos sobre alimentaci\u00f3n por USB:</p> <ul> <li>Cuando alimentamos desde USB V1 entrega los 3.3V a trav\u00e9s de un regulador integrado en la interface. La \u00faltima revisi\u00f3n de V2 utiliza un regulador separado.</li> <li>Para tener un margen de seguridad adecuado, en placas V1 no debemos superar los 90 mA de consumo mientras que en V2, al tener su propio regulador, podemos alcanzar los 190 mA. Si necesitamos corriente mayores podemos retroalimentar la micro:bit a partir de los pads 3V y GND, pero asegurando que la alimentaci\u00f3n es regulada y utilizando un diodo de protecci\u00f3n. Para esto no se recomienda el uso de baterias USB ya que pueden generar tensiones fuera del rango permitido y da\u00f1ar a la micro:bit.</li> </ul> <p>En el caso de alimentaci\u00f3n con baterias:</p> <ul> <li>Cuando se alimenta desde una bater\u00eda conectada al JST, el chip de interface y el de sistema en la versi\u00f3n V1 no se encienden. En la micro:bit V2 la energ\u00eda de la bater\u00eda pasa a trav\u00e9s del regulador y alimenta tambi\u00e9n el chip de interface. Si la placa micro:bit no est\u00e1 en modo reposo, el LED rojo (a la izquierda del conector USB) deber\u00eda estar encendido.</li> <li>Una bater\u00eda LiPo de una celda completamente cargada est\u00e1 especificada para entregar 4,2V Esto es m\u00e1s de los 3,6V m\u00e1ximos indicados.</li> </ul> <p>La micro:bit puede ser alimentada desde los pads 3V/GND del conector de borde. Tambi\u00e9n hay dos pads en la parte derecha de la cara posterior de la PCB que se pueden utilizar para suministrar energ\u00eda, por ejemplo, desde un soporte con pilas 2xAAA o 2XAA que podemos soldar en esos pads. En la imagen se destacan estos pads.</p> <p> <p> Extension board de Freenove</p> <p></p>"},{"location":"actividades/A04/#micropython","title":"MicroPython","text":"<p>En MicroPython, cada pin en la BBC micro:bit est\u00e1 representado por un objeto llamado pinN, donde N es el n\u00famero del pin.</p> <p>Por ejemplo, para usar el pin etiquetado 0 (cero), puedes usar el objeto llamado pin0 en tu script. El pin del logo V2 utiliza pin_logo.</p> <p>Estos objetos tienen varios m\u00e9todos asociados dependiendo de lo que el pin espec\u00edfico es capaz de hacer, por ejemplo, leer, escribir o tocar.</p> <p>Quiz\u00e1 lo mas sencillo que podemos hacer es comprobar que los pines 0, 1 y 2 del borde de placa son t\u00e1ctiles. Haremos como ejemplo que al tocar cualquiera de ellos la micro:bit sonria y si no se toca ning\u00fano que est\u00e9 triste. Le hacemos cosquillas a la micro:bit. El programa es:</p> <pre><code>from microbit import *\n\"\"\"\npin0.set_touch_mode(pin0.CAPACITIVE)\npin1.set_touch_mode(pin0.CAPACITIVE)\npin2.set_touch_mode(pin0.CAPACITIVE)\n\"\"\"\nwhile True:\n    if (pin0.is_touched() or pin1.is_touched() or pin2.is_touched()):\n        display.show(Image.HAPPY)\n    else:\n        display.show(Image.SAD)\n</code></pre> <p>En la animaci\u00f3n vemos el funcionamiento del programa.</p> <p> <p> Pines t\u00e1ctiles en el borde de placa</p> <p></p> <p>Si descargamos firmware en una placa para probar el programa debemos saber que no basta con tocar alguno de los pines con una mano, hay que tocarlo simultaneamente con la otra mano en GND para cerrar el circuito el\u00e9ctrico.</p> <p>En la \u00faltima versi\u00f3n de micro:bit V2 es posible cambiar el comportamiento predeterminado de la patilla, de modo que no sea necesario tocar GND. En los programas siguientes el c\u00f3digo que hace esto est\u00e1 comentado por lo que si queremos probarlo debemos eliminar esos comentarios. Recordemos que por defecto los pines del conector de borde son sensores t\u00e1ctiles resistivos mientras que el pin logo V2 es capacitivo.</p> <ul> <li>Descargar el programa .hex</li> <li>Descargar el programa .py</li> </ul>"},{"location":"actividades/A04/#circuito","title":"Circuito","text":"<p>Los diodos LEDs no deben conectarse directamente a la fuente de alimentaci\u00f3n, sino con una resistencia en serie que se calcula como hemos visto. No hacerlo suele acabar con el componente da\u00f1ado de manera irreversible.</p> <p>Al realizar el conexionado, es conveniente desconectar todas las fuentes de alimentaci\u00f3n y, a continuaci\u00f3n, montar el circuito seg\u00fan el esquema concreto. La placa micro:bit no se puede insertar al rev\u00e9s.</p> <p>El positivo del LED o \u00e1nodo (patilla larga) debe conectarse a la resistencia (el otro extremo va al positivo de alimentaci\u00f3n), mientras que su polo negativo o c\u00e1todo (patilla corta) debe ir a GND. Una vez construido el circuito y verificado que es correcto, utilizamos el cable USB para conectar la micro:bit al ordenador y as\u00ed alimentar el circuito.</p> <p>El esquema del circuito a montar lo vemos a continuaci\u00f3n.</p> <p> <p> Esquema de montaje de una LED</p> <p></p> <p>Un sencillo c\u00e1culo del valor de la resistencia es el siguiente:</p> <p> <p>R_{red} = \\dfrac{3.3 - 1.5}{15mA} = \\dfrac{1.8V}{15mA}=0.12K = 120 \\Omega \\sim 220 \\Omega</p> <p></p> <p>Se adopta un valor de resitencia de 220 ohmios para mayor seguridad.</p> <p>El conexionado deber\u00e1 parecerse al siguiente:</p> <p> <p> Conexionado real del esquema de montaje de una LED</p> <p></p>"},{"location":"actividades/A04/#programa","title":"Programa","text":"<p>El programa para el circuito anterior va a consistir en hacer parpadear al LED a intervalos de un segundo.</p> <p>Se trata de un programa muy simple pero que requiere un montaje externo que ya no podremos ver como funciona en el simulador del programa. As\u00ed que toca realizar montaje, conectar la micro:bit a una extension board y probar en la pr\u00e1ctica. El programa es:</p> <pre><code>from microbit import *\n\nwhile True:\n    pin0.write_digital(1)\n    sleep(1000)\n    pin0.write_digital(0)\n    sleep(1000)\n</code></pre> <p>El programa lo podemos descargar de:</p> <ul> <li>A04-parpadeo .hex</li> <li>A04-parpadeo .py</li> </ul> <p>Vamos a realizar una ampliaci\u00f3n del programa aplicando los conocimientos de PWM y de bucles. Se trata de hacer que el diodo LED se encienda y se apague de manera progresiva realizando una escritura anal\u00f3gica del valor PWM del pin P0 (0 a 255). Para ello utilizaremos dos bucles for, uno con cuenta ascendente de 0 a 255 y otro con cuenta descendente tambi\u00e9n de 0 a 255. El programa es:</p> <pre><code>from microbit import *\n\nwhile True:\n    for i in range(255):\n        pin0.write_analog(i)\n        sleep(10)\n    #bucle decreciente: \n        #se antepone al rango reversed\n    for j in reversed(range(255)):\n        pin0.write_analog(j)\n        sleep(10)\n</code></pre> <p>El programa lo podemos descargar de:</p> <ul> <li>A04-Encendido y apagado por PWM .hex</li> <li>A04-Encendido y apagado por PWM .py</li> </ul>"},{"location":"actividades/A04/#makecode","title":"MakeCode","text":"<p>Para hacer el ejemplo de parpadeo de un LED externo utilizamos el mismo circuito que el visto en Python. El programa es el siguiente:</p> <p> <p> Programa pardeo de LED externo</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>A04-parpadeo</li> </ul> <p>Realizamos la ampliaci\u00f3n del programa controlando el encendido y apagado progresivo por PWM.</p> <p> <p> Programa pardeo de LED externo</p> <p></p> <p>Dos cosas a observar:</p> <ol> <li>El contador hacia atr\u00e1s se realiza restando al valor inicial de cuenta la variable en un bucle de 0 a xx</li> <li>Como hemos establecido el valor m\u00e1ximo posible anal\u00f3gico como l\u00edmite, el retardo lo hemos puesto de 3ms para que tarde aproximadamente 3 segundos (3ms x 1023 = 3069ms = 3,069s) en realizar la cuenta (o decontaje) completo.</li> </ol> <p>El programa lo podemos descargar de:</p> <ul> <li>A04-parpadeo PWM</li> </ul> <p>Resulta interesante observar el funcionamiento del programa en el simulador, donde se aprecia a la perfecci\u00f3n tanto la cuenta ascendente como la descendente. En la animaci\u00f3n lo vemos.</p> <p> <p> Simulaci\u00f3n del programa pardeo de LED externo</p> <p></p>"},{"location":"actividades/A04/#microblocks","title":"MicroBlocks","text":"<p>SPara hacer el ejemplo de parpadeo de un LED externo utilizamos el mismo circuito que el visto en Python. El programa es el siguiente:</p> <p> <p> Programa pardeo de LED externo</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>A04-parpadeo</li> </ul> <p>Realizamos la ampliaci\u00f3n del programa de la misma forma que en MakeCode.</p> <p> <p> Programa pardeo de LED externo</p> <p></p> <p>En este caso tambi\u00e9n tenemos dos cosas a observar:</p> <ol> <li>El contador hacia atr\u00e1s se realiza restando al valor inicial de cuenta la variable en un bucle de 0 a xx</li> <li>Como hemos establecido el valor m\u00e1ximo posible anal\u00f3gico como l\u00edmite, el retardo lo hemos puesto de 3ms para que tarde aproximadamente 3 segundos (3ms x 1023 = 3069ms = 3,069s) en realizar la cuenta (o decontaje) completo.</li> </ol> <p>El programa lo podemos descargar de:</p> <ul> <li>A04-parpadeo PWM</li> </ul>"},{"location":"conceptos/avanzados/","title":"Componentes avanzados","text":"<p>En este apartado iremos describiendo algunos componentes, sensores, actuadores, etc, que se utilizar\u00e1n en los montajes.</p>"},{"location":"conceptos/avanzados/#lcd-1602-i2c","title":"LCD 1602 I2C","text":"<p>Una pantalla LCD (del ing\u00e9s, Liquid Cristal Display) I2C de 2 l\u00edneas de 16 caracteres por l\u00ednea tiene el aspecto que vemos en la imagen siguiente.</p> <p> <p> LCD 2x16 con m\u00f3dulo I2C</p> <p></p> <p>En realidad el conjunto que vemos en la imagen anterior no es mas que una LCD 2x16 a la que se ha incorporado un m\u00f3dulo adaptador de LCD a I2C. Este modulo est\u00e1 especialmente dise\u00f1ado para poder soldarlo directamente a la LCD y convertirla as\u00ed en un dispositivo I2C que adem\u00e1s ya lleva incorporado el potenci\u00f3metro de ajuste de contraste en alguno de los casos.</p> <p>Este tipo de pantalla requiere cuatro cables para establecer las conexiones, dos cables SDA (datos) y SCL (reloj) para el bus de comunicaciones I2C y los dos cables de alimentaci\u00f3n VCC y GND.</p> <p>La direcci\u00f3n I2C por defecto de este tipo de m\u00f3dulos puede ser 0x3F o en otros casos 0x27, e incluso hay modelos en los que se puede cambiar. Para un correcto control es muy importante identificar correctamente la direcci\u00f3n I2C de nuestro modulo pues de otra forma nuestro programa no funcionar\u00e1 correctamente.</p> <p>En la siguiente figura se muestra el sistema de distribuci\u00f3n de filas y columnas.</p> <p> <p> Sistema de coordenadas en una LCD 1602</p> <p></p> <p>Es posible, y puede resultar necesario, cambiar la direcci\u00f3n f\u00edsica del dispositivo I2C. Esta tarea nos va a resultar especialmente \u00fatil si disponemos de LCDs I2C con una direcci\u00f3n fijada de f\u00e1brica y queremos conectar varias de ellas en nuestro proyecto.</p>"},{"location":"conceptos/avanzados/#cambiar-direccion-lcd-sin-micro-interruptores","title":"Cambiar direcci\u00f3n LCD SIN micro interruptores","text":"<p>La parte posterior de la LCD 1602 de Keyestudio tiene el aspecto de la imagen siguiente. Nos fijaremos especialmente en los tres grupos de agujeros enmarcados en rojo. Aunque en este caso no vienen nombrados los vamos a denominar A0, A1 y A2 de izquierda a derecha. En LCDs de otras marcas esto puede variar ligeramente.</p> <p> <p> Pads configuraci\u00f3n direcci\u00f3n f\u00edsica en la parte posterior LCD I2C</p> <p></p> <p>La direcci\u00f3n por defecto de f\u00e1brica en este caso es la 0x27, pero se puede cambiar alterando la situaci\u00f3n de conexionado de estos agujeros entre si seg\u00fan la tabla siguiente:</p> <p> A2 A1 A0 Direcci\u00f3n 0 0 0 0x27 0 0 1 0x26 0 1 0 0x25 0 1 1 0x24 1 0 0 0x23 1 0 1 0x22 1 1 0 0x21 1 1 1 0x20 <p></p> <p>Para establecer los unos de la tabla anterior basta con cortocircuitar los dos pads correspondientes. En la imagen siguiente se ha establecido la direcci\u00f3n f\u00edsica como 0x26.</p> <p> <p> Direcci\u00f3n 0x26 establecida</p> <p></p>"},{"location":"conceptos/avanzados/#cambiar-direccion-lcd-con-micro-interruptores","title":"Cambiar direcci\u00f3n LCD CON micro interruptores","text":"<p>La parte posterior de la LCD 1602 de Keyestudio con micro interruptores para cambiar su direcci\u00f3n f\u00edsica tiene el aspecto de la imagen siguiente. Nos fijaremos especialmente en el recuadro azul donde est\u00e1n los microinterruptores que permiten cambiar el estado del bit y encima de los mismo est\u00e1 la informaci\u00f3n de la direcci\u00f3n f\u00edsica que se asigna a cada combinaci\u00f3n. La tabla es exactamente la misma que en el caso anterior.</p> <p> <p> Configuraci\u00f3n direcci\u00f3n f\u00edsica con microinterruptores</p> <p></p>"},{"location":"conceptos/avanzados/#motores","title":"Motores","text":"<p>Apartado para describir los tipos de motores que habitualmente se utilizan en proyectos con micro:bit, como son los motores de corriente continua o motores DC y los servomotores.</p>"},{"location":"conceptos/avanzados/#el-motor-de-corriente-continua","title":"El motor de corriente continua","text":"<p>Se suelen denominar como motores DC (del ingl\u00e9s Direct Current) o motores CC como que son m\u00e1quinas que convierten la energ\u00eda el\u00e9ctrica en mec\u00e1nica en base a un campo magn\u00e9tico que provoca un movimiento de rotaci\u00f3n en el eje del motor.</p> <p>Un motor de corriente continua tiene dos partes bien diferenciadas:</p> <ul> <li>Estator. Es la parte fija del motor y son bobinas de hilo de cobre devanadas en n\u00facleos magn\u00e9ticos.</li> <li>Rotor. Es la parte movil del motor y suele tener forma de cilindro, tambi\u00e9n es un devanado con n\u00facleo que se alimenta con corriente continua a trav\u00e9s de las delgas.</li> </ul> <p>En la animaci\u00f3n de la figura siguiente vemos el principio de funcionamiento de un motor DC explicado a partir del caso de una espira conductora dentro de un campo magn\u00e9tico a la que se aplica una tensi\u00f3n entre sus extremos que hace circular por la misma una corriente el\u00e9ctrica.</p> <p> <p> Base de funcionamiento de un motor DC Fuente: Wikipedia</p> <p></p> <p>En esta imagen existe un campo magn\u00e9tico permanente producido por imanes en el estator. El flujo de corriente en el devanado del rotor produce una fuerza de Lorentz sobre el devanado, representada por las flechas verdes. Debido a que en este caso el motor tiene dos polos, la conmutaci\u00f3n se hace por medio de un anillo partido a la mitad, donde el flujo de corriente se invierte cada media vuelta (180 grados).</p> <p>En la figura siguiente vemos el esquema del funcionamiento de un motor de c.c. elemental de dos polos con una sola bobina y dos delgas en el rotor. Se muestra el motor en tres posiciones del rotor desfasadas 90\u00b0 entre s\u00ed.</p> <ul> <li>1, 2: Escobillas</li> <li>A, B: Delgas</li> <li>a, b: Lados de la bobina conectados respectivamente a las delgas A y B</li> </ul> <p> <p> Esquema de funcionamiento de un motor DC Fuente: Wikipedia</p> <p></p> <p>En la figura siguiente vemos el aspecto de dos motores t\u00edpicos.</p> <p> <p> Aspecto de motores DC</p> <p></p>"},{"location":"conceptos/avanzados/#control-de-motores-dc","title":"Control de motores DC","text":"<p>Las salidas de la micro:bit no van a servir por si solas para el control de un motor DC que tendr\u00e1 un consumo de hasta 1A. La soluci\u00f3n est\u00e1 en realizar el control del motor a trav\u00e9s de un controlador o driver que es gobernado por la placa de control, se alimenta de forma externa y excita al motor. En la figura siguiente vemos esquematizado el concepto.</p> <p> <p> Concepto de control por driver</p> <p></p> <p>El sistema mas sencillo de control todo o nada de un motor DC lo conseguimos a trav\u00e9s de un transistor, tal y como vemos en la figura siguiente.</p> <p> <p> Control de motor DC con transistor</p> <p></p> <p>Pero es evidente que necesitamos un control mas completo del motor en el que se permita:</p> <ul> <li>Invertir el sentido de giro.</li> <li>Controlar la velocidad de giro.</li> </ul> <p>Existen muchos drivers diferentes que consiguen estos objetivos y casi todos basan su funcionamiento en el denominado puente en H estando su principal diferencia en el circuito integrado que utilizan y la corriente m\u00e1xima que es capaz de entregar.</p>"},{"location":"conceptos/avanzados/#puente-en-h-con-interruptores","title":"Puente en H con interruptores","text":"<p>Vamos a explicar el funcionamiento de un puente en H utilizando para ello un circuito creado con interruptores y el principio b\u00e1sico de que en los motores DC el sentido de giro depende de la polaridad de alimentaci\u00f3n. En la figura siguiente tratamos de expresar el hecho de que cambiando la polaridad de la bater\u00eda cambia el sentido de giro del motor.</p> <p> <p> Cambio de polaridad para cambiar sentido de giro</p> <p></p> <p>El puente en H m\u00e1s b\u00e1sico que podemos construir lo vemos en la figura siguiente, donde observamos que su nombre se debe a la similitud que tiene el esquema con la letra H.</p> <p> <p> Puente en H con interruptores</p> <p></p> <p>Veamos las posibles combinaciones que podemos realizar accionando dos interruptores:</p> <ul> <li>Cerramos SW1 y SW4. Las conexiones son: positivo motor a positivo bater\u00eda y negativo motor a negativo bater\u00eda. Sentido de giro: horario.</li> <li>Cerramos SW2 y SW3. Las conexiones son: positivo motor a negativo bater\u00eda y negativo motor a positivo bater\u00eda. Sentido de giro: antihorario.</li> <li>Cerramos SW1 y SW2 o SW3 y SW4. Se provoca un CORTOCIRCUITO en la alimentaci\u00f3n.</li> <li>Cerramos SW1 y SW3 o SW2 y SW4. Se cortocircuitan los terminales del motor lo que mantiene al motor frenado.</li> </ul> <p>Es evidente que un puente en H as\u00ed construido no nos va a servir para mucho mas que para explicar el funcionamiento del sistema, pero si reemplazamos los interruptores por un sistema de control que abra y cierre el circuito de cada interruptor es evidente que si tendremos un sistema de control del sentido de giro muy vers\u00e1til.</p>"},{"location":"conceptos/avanzados/#puente-en-h-con-transistores","title":"Puente en H con transistores","text":"<p>Si a un transistor lo hacemos trabajar en conmutaci\u00f3n su comportamiento es muy similar al de un interruptor asimilando el estado de corte del transistor al de interruptor abierto y el de saturaci\u00f3n al de cerrado. Es entonces posible sustituir los interruptores por transistores y tendremos una configuraci\u00f3n de puente en H como la de la figura siguiente. Este es un circuito simplificado donde adem\u00e1s se ha a\u00f1adido una l\u00f3gica de control b\u00e1sica que permite explicar el funcionamiento.</p> <p> <p> Puente en H con transistores</p> <p></p> <p>Los transistores pueden ser NPN (el caso expuesto), PNP o pares complementarios y pueden ser de uni\u00f3n o MOSFET de potencia variando as\u00ed la m\u00e1xima corriente que son capaces de entregar y por lo tanto el tama\u00f1o del motor.</p> <p>El funcionamiento del circuito es el siguiente:</p> <ul> <li>Pin enable. Si es 0 todas las puertas AND tendr\u00e1n un cero en la salida un 0 con lo que los transistores est\u00e1n en corte y al motor no le llega alimentaci\u00f3n. El pin enable a 1 habilita la otra entrada de las 4 puertas AND para que en la misma aparezca la otra entrada.</li> <li>Enable = 1, IN1 = 1 e IN2 = 0. Los transistores Q1 y Q4 se saturan por lo que el motor queda polarizado directamente tal y como se muestra en la imagen y por lo tanto girar\u00e1 en sentido horario.</li> <li>Enable = 1, IN1 = 0 e IN2 = 1. Los transistores Q2 y Q3 se saturan por lo que el motor queda polarizado inversamente y por lo tanto girar\u00e1 en sentido antihorario.</li> <li>Enable = 1, IN1 = 1 e IN2 = 1. Se saturan los transistores Q1 y Q3 y al motor solamente le llega el positivo de alimentaci\u00f3n por lo que permanecer\u00e1 parado.</li> <li>Enable = 1, IN1 = 0 e IN2 = 0. Se saturan los transistores Q2 y Q4 y el motor permanecer\u00e1 frenado.</li> </ul>"},{"location":"conceptos/avanzados/#el-servomotor","title":"El servomotor","text":"<p>Un servomotor o abreviado servo es un motor especial que puede posicionar su eje en un \u00e1ngulo determinado y lo puede mantener en esta posici\u00f3n. Los servos est\u00e1ndar suelen girar 180\u00ba, pero es habitual encontrar servos que giran 90\u00ba y otros 360\u00ba, que son los conocidos como servos de rotaci\u00f3n continua. En el interior del mismo est\u00e1n ubicados tanto la electr\u00f3nica de control como los engranajes reductores que a su vez pueden llevar o no topes f\u00edsicos que marquen el \u00e1ngulo de giro. Para su funcionamiento s\u00f3lo necesitan ser alimentados (conexiones GND y VCC o 5V) y una se\u00f1al de control.</p> <p>Los servomotores son en realidad motores de corriente continua a los que se les ha a\u00f1adido una reductora, para que giren m\u00e1s despacio y con m\u00e1s fuerza, y un controlador electr\u00f3nico que permite hacer que gire un determinado \u00e1ngulo. Adem\u00e1s, el servo en todo momento sabe en qu\u00e9 posici\u00f3n est\u00e1, aunque se apague o reinicie. Esto significa que si a un servo que hemos movido a un determinado punto, lo hemos dejado sin alimentaci\u00f3n y al alimentarlo de nuevo le indicamos que gire 90\u00ba, no va a girar 90\u00ba sino que se va a dirigir a su posici\u00f3n de 90\u00ba que tiene memorizada internamente.</p> <p>En la figura siguiente vemos esquematizado el interior de un servo.</p> <p> <p> Interior de un servo 9g</p> <p></p> <p>Su aspecto real lo vemos en la figura siguiente donde tambi\u00e9n se aprecian las palas y tornilleria que lo acompa\u00f1an.</p> <p> <p> Aspecto real de un servo 9g</p> <p></p> <p>Veamos su principio b\u00e1sico de funcionamiento: La electr\u00f3nica de control del servomotor tiene un circuito de referencia incorporado que emite la se\u00f1al de referencia, que es un ciclo de 20 ms con un ancho de pulso de 1,5 ms. Se compara la tensi\u00f3n de control recibida con la de referencia y se genera una diferencia de tensi\u00f3n. El circuito de control en la placa decidir\u00e1 la direcci\u00f3n de rotaci\u00f3n en consecuencia y accionar\u00e1 el motor. El sistema de engranajes o reductora convierten el giro del motor en un par de fuerza a trav\u00e9s del eje. El sensor detecta que se ha alcanzado la posici\u00f3n enviada de acuerdo con la se\u00f1al de retroalimentaci\u00f3n. Cuando la diferencia de tensi\u00f3n existe el motor gira y cuando la diferencia se reduce a cero, el motor se detiene. Normalmente, el \u00e1ngulo de rotaci\u00f3n es de 0 a 180 grados, aunque existen servos de 90\u00ba y de rotaci\u00f3n continua o 360\u00ba.</p> <p>El servomotor viene con un conector hembra de tres pines para tres cables de conexi\u00f3n, que se distinguen por los colores marr\u00f3n, rojo y naranja (diferentes marcas pueden tener diferentes colores).</p> <p>El \u00e1ngulo de rotaci\u00f3n del servomotor se controla regulando el ciclo de trabajo de la se\u00f1al PWM cuyo est\u00e1ndar es de 20 ms (50 Hz).</p> <p>Existe un tipo especial de servomotor que permite la rotaci\u00f3n continua. En algunos casos se trata de servomotores \u201ctrucados\u201d de forma que se modifican para permitir la rotaci\u00f3n continua quitando los topes mec\u00e1nicos y se sustituye el potenci\u00f3metro por un divisor de tensi\u00f3n con dos resistencia iguales (en algunos casos no se ponen resistencias y se bloquea el potenci\u00f3metro para que no gire dej\u00e1ndolo justo en su punto central). Este tipo de modificaci\u00f3n la podemos realizar nosotros (en la web existen multitud de tutoriales) o tambi\u00e9n podemos comprar un servomotor de rotaci\u00f3n continua listo para funcionar sin tener que hacer ning\u00fan tipo de bricolaje.</p> <p>A continuaci\u00f3n vemos las partes de un servo t\u00edpico.</p> <p> <p> Despiece de un servo 9g</p> <p></p>"},{"location":"conceptos/avanzados/#control-de-un-servomotor","title":"Control de un servomotor","text":"<p>Uno de los problemas que se nos plantean cuando cogemos un servo por primera vez es averiguar cual es su posici\u00f3n. Lo que nosotros hacemos cuando enviamos la se\u00f1al PWM a la patilla de control del servo es indicarle a que posici\u00f3n queremos que se dirija. El servo a priori, mediante el potenci\u00f3metro y la electr\u00f3nica de control, sabe en que posici\u00f3n est\u00e1 por lo que si le enviamos un dato con el que el servo no pueda posicionarse estar\u00e1 constantemente intentando buscar la posici\u00f3n.</p> <p>En la imagen vemos las se\u00f1ales de posicionado del servo y los \u00e1ngulos a los que se debe colocar.</p> <p> <p> Se\u00f1ales PWM para posiconar servo</p> <p></p> <p>La se\u00f1al PWM debe ser tal que en un periodo (tiempo) de 20ms se debe generar un pulso de 1ms, 1.5ms o 2ms que el controlador interpretar\u00e1 como 0, 90 y 180 grados respectivamente. Es decir, el pulso entre 1 y 2ms ir\u00e1 siendo interpretado por el controlador para ir moviendo el servo hasta la posici\u00f3n de destino.</p> <p>Lo que nosotros tendremos que programar cuando utilicemos un servo es, entre otras cosas, el \u00e1ngulo en el que queremos posicionarlo que en los servos mas habituales estar\u00e1 comprendido entre 0 y 180\u00ba.</p> <p>Una vez que hemos colocado y conectado el servo y lo posicionamos en sus distintos \u00e1ngulos es momento de elegir la posici\u00f3n que mas nos interese para colocar la pala en su lugar, lo que depender\u00e1 de la aplicaci\u00f3n, logicamente.</p> <p>La velocidad del movimiento est\u00e1 condicionada por el dise\u00f1o f\u00edsico del propio servo y este se mover\u00e1 a su m\u00e1xima velocidad para cambiar de una posici\u00f3n a otra. Entre los movimientos programados a diferentes \u00e1ngulos es conveniente programar un peque\u00f1o retardo para que al servo le de tiempo de llegar a una posici\u00f3n determinada antes de recibir la orden de moverse a otra. Si no lo hacemos as\u00ed es muy posible que el servo inicie un movimiento de \"vibraci\u00f3n\" intentando moverse de una posici\u00f3n a la otra.</p> <p>Es evidente que habr\u00e1 aplicaciones en las que nos interese controlar la velocidad a la que se mueve el servo y la forma mas sencilla de hacerlo es asociando el \u00e1ngulo de giro a una variable e ir incrementando esta poco a poco. La velocidad se controla mediante el retardo entre el movimiento debido a un valor de la variable y el siguiente. Aqu\u00ed debemos tener precauci\u00f3n con el valor del retardo y relacionarlo con el valor de incremento de la variable para que el tiempo sea suficiente para que se haga el movimiento pero no excesivamente largo que har\u00eda el movimiento global muy lento. Tambi\u00e9n debemos poner un retardo fuera del bucle que provoca los movimientos para dar tiempo a que el servo retorne a su posici\u00f3n inicial. L\u00f3gicamente si queremos que este movimiento de regreso lo haga a velocidad controlada utilizaremos otro bucle decremental para ello.</p>"},{"location":"conceptos/avanzados/#placas-de-expansion-para-microbit","title":"Placas de expansi\u00f3n para micro:bit","text":"<p>Aunque existen muchas versiones de distintos fabricantes en nuestro caso vamos a describir tres de ellas. Basicamente la funcionalidad de ampliaci\u00f3n de pines es la misma en todas ellas y se distinguen porque incluyen diferentes funcionalidades, distribuci\u00f3n de pines o drivers para motores.</p>"},{"location":"conceptos/avanzados/#freenove","title":"Freenove","text":"<p>Tiene el siguiente aspecto:</p> <p> <p> Extension board de Freenove</p> <p></p> <p>La placa viene preparada con:</p> <ul> <li>Un conector para alimentaci\u00f3n externa de 7 a 12V</li> <li>Un puerto USB-Micro para conectarla al ordenador</li> <li>Un puerto USB-A colocado en vertivcal para conectar la micro:bit</li> <li>Un diodo LED D1 indicador de 5V</li> <li>Un diodo LED D2 indicador de 3.3V</li> </ul>"},{"location":"conceptos/avanzados/#keyestudio","title":"Keyestudio","text":"<p>Una micro:bit por si sola no tiene potencia suficiente para controlar directamente motores DC. La placa KS4033 Keyestudio Micro bit DRV8833 Motor Driver Expansion Board incorpora un driver para motores DC con un chip DRV8833CPWP que entrega una corriente m\u00e1xima de 700mA. Adem\u00e1s, dispone de cuatro modos de control del motor: rotaci\u00f3n en sentido horario, rotaci\u00f3n en sentido antihorario, arranque y parada. PWM soporta frecuencias de hasta 100 kHz. Los motores van en el conector azul con clemas atornilladas para mayor facilidad y fiabilidad del conexionado. La placa tambi\u00e9n incorpora interfaces de 3 pines para conectar otros sensores.</p> <p>Los pines A1, A2, B2 y B1 del conector azul de la placa de expansi\u00f3n son controlados por P13, P12, P15 y P16 de la placa micro:bit.</p> <p> <p> Extension board de Keyestudio</p> <p></p> <p>Las especificaciones t\u00e9cnicas de la placa son:</p> <ul> <li>Tensi\u00f3n de entrada VM: 5 a 10.8V DC</li> <li>Corriente de funcionamiento de la parte motriz: \u2264700mA</li> <li>Configuraci\u00f3n de salida para motor: doble puente en h</li> <li>Temperatura de trabajo: 0 a 50 \u00baC</li> </ul> <p>A continuaci\u00f3n vemos un diagrama t\u00edpico de conexionado de motores y la alimentaci\u00f3n de los mismos.</p> <p> <p> Conexionado de la extension board de Keyestudio</p> <p></p>"},{"location":"conceptos/avanzados/#dfrobot","title":"DFROBOT","text":"<p>Esta placa de expansi\u00f3n de DFROBOT con montaje vertical de la micro:bit tiene capacidad para controlar cuatro motores DC o dos motores paso a paso. Utiliza el controlador HR8833 con una corriente m\u00e1xima de funcionamiento de 1,5A.</p> <p>La placa de expansi\u00f3n incorpora en los conectores P, 9 pines GPIO de f\u00e1cil conexionado pues incorporan Vcc y GND, En los conectores S hay disponibles 8 conexiones para servos, adem\u00e1s de los conectores atornillados de motores.Tambi\u00e9n dispone de un hub de dos conectores I2C. La placa soporta alimentaci\u00f3n externa de 3.5V a 5.5V a trav\u00e9s del conector DC de 2.1mm o de la clema para cables atornillados que se pueden conectar directamente a un portapilas con 3 pilas AA o AAA. La placa incorpora interruptor de encendido/apagado de la alimentaci\u00f3n externa.</p> <p> <p> Extension board de DFROBOT</p> <p></p> <p>Tiene las siguientes especificaciones:</p> <ul> <li>Tensi\u00f3n de alimentaci\u00f3n: 3.5 a 5.5V DC</li> <li>Tensi\u00f3n de salida digital: 0V / 3.3V</li> <li>Tensi\u00f3n de salida anal\u00f3gica: 0 a 3.3V DC</li> <li>Interface micro:bit: P0 P1 P2 P8 P12 P13 P14 P15 P16</li> <li>Interface servo: 8</li> <li>Interface motor: 4 motores DC / 2 motores paso a paso</li> </ul>"},{"location":"conceptos/discretos/","title":"Componentes discretos","text":"<p>Se describen brevemente las caracter\u00edsticas y principio de funcionamiento de los componentes b\u00e1sicos para construir circuitos que se montan para pruebas.</p>"},{"location":"conceptos/discretos/#cables-y-conectores","title":"Cables y conectores","text":"<p>En electr\u00f3nica se utilizan multitud de cables y conectores especializados por caracter\u00edsticas y por aplicaci\u00f3n. Para lo que nos interesa existen unos componentes b\u00e1sicos conocidos como puentes, jumpers o cables dupont que est\u00e1n dise\u00f1ados para interconectar componentes mediante la inserci\u00f3n de sus dos terminales.</p> <p>Estos cables utilizan en sus extremos (lo llevan crimpado) o bien conectores macho (Male) o bien hembra (Female), por lo que se pueden clasificar en los tres tipos siguientes, que se comercializan en diferentes colores y longitudes.</p> <p> Conexiones Cable macho-macho (M/M) hembra/hembra (F/F) macho/hembra (M/F) <p></p>"},{"location":"conceptos/discretos/#protoboard","title":"Protoboard","text":"<p>Tambi\u00e9n conocida como breadboard es una placa con multitud de agujeros interconectados de una determinada manera formando grupos de conexiones. Permiten montar de forma r\u00e1pida circuitos mas o menos sencillos. Existen de muchos tama\u00f1os diferentes de los que vemos una muestra en la imagen.</p> <p> <p> Placas protoboard</p> <p></p> <p>Hay dos cosas importantes en este tipo de componente, la primera es no introducir en los agujeritos componentes o cables de mas de 0.5mm de di\u00e1metro porque a la larga esto provocar\u00e1 falsos contactos con otros componentes y la segunda es tener muy claro como van conectados internamente los agujeros.</p> <p> <p> Conexiones internas en placas protoboard</p> <p></p>"},{"location":"conceptos/discretos/#resistencias","title":"Resistencias","text":"<p>La resistencia es un componente electr\u00f3nico del grupo denominado pasivos que est\u00e1 dise\u00f1ado para oponerse al paso de la corriente. El valor de la resistencia se expresa en ohmios o sus m\u00faltiplos. Se fabrican principalmente de carb\u00f3n (la mina de un l\u00e1piz es una resistencia) o de pelicula met\u00e1lica y se comercializan en una amplia gama de valores. Su aspecto lo vemos en la imagen.</p> <p> <p> Resistencias</p> <p></p> <p>Las resistencias est\u00e1n definidas por tres caracter\u00edsticas fundamentales:</p> <ul> <li>el valor resistivo</li> <li>la potencia m\u00e1xima que puede disipar</li> <li>la tolerancia</li> </ul> <p>Hay resistencias con valores de Ohmios (\u2126), Kilohmios (K\u2126), Megaohmios (M\u2126) y otros m\u00faltiplos y subm\u00faltiplos. La equivalencias entre ellas es:</p> <ul> <li>1 Kilohmio (K\u2126) = 1,000 Ohmios (\u2126)</li> <li>1 Megaohmio (M\u2126) = 1,000,000 Ohmios (\u2126) = 1,000 Kilohmios (K\u2126)</li> </ul> <p>Para poder saber que valor y tolerancia tiene una resistencia, existe un c\u00f3digo de colores que nos ayuda a obtener con facilidad estos valores. La potencia no se indica expresamente en este tipo de resistencias y depende de su tama\u00f1o, por lo que con el uso nos iremos acostumbrando.</p> <p>Existen resistencia de 3 (en desuso), 4, 5 y 6 bandas de colores y cada una se lee de manera diferente aunque parecida. Veamoslas.</p> <p>Existen muchas p\u00e1ginas y aplicaciones que nos ayudan a averiguar el valor de una resistencia por sus bandas de color. Una muy completa y f\u00e1cil de usar es la de Digikey, una tienda de componentes que adem\u00e1s nos ofrece otras muchas calculadoras que nos resultar\u00e1n \u00fatiles.</p>"},{"location":"conceptos/discretos/#4-bandas","title":"4 bandas","text":"<p>En estas, una de las bandas estar\u00e1 m\u00e1s cercana al terminal o patilla, puede ser mas ancha y es esa su primera cifra significativa o banda 1, la siguiente es la banda 2, la siguiente es la banda multiplicadora y la cuarta banda es la banda de tolerancia, esta banda normalmente es mas estrecha. A continuaci\u00f3n vemos como se leen estas resistencias.</p> <p> <p> Resistencias de cuatro bandas</p> <p></p> <p>El valor se obtendr\u00eda poniendo: 56 x 10\u2074 = 560k \u00b1 5%</p>"},{"location":"conceptos/discretos/#5-bandas","title":"5 bandas","text":"<p>En este caso hay tres cifras significativas y se leen como vemos a continuaci\u00f3n.</p> <p> <p> Resistencias de cinco bandas</p> <p></p> <p>El valor se obtendr\u00eda poniendo: 247 x 10\u00b2 = 24700 = 24K7 \u00b1 5%</p>"},{"location":"conceptos/discretos/#6-bandas","title":"6 bandas","text":"<p>A estas resistencias se a\u00f1ade una sexta banda como \u00faltima banda para indicar el coeficiente de temperatura y tambi\u00e9n tienen tres cifras signiticativas. A continuaci\u00f3n vemos como se leen. El coeficiente de temperatura indica cuanto cambia el valor de la resistencia en funci\u00f3n de la temperatura utilizando normalmente ppm/K (partes por mill\u00f3n por grado Kelvin) como unidad. Es muy raro ver resistencias de seis bandas como componente habitual.</p> <p> <p> Resistencias de seis bandas</p> <p></p> <p>El valor se obtendr\u00eda poniendo: 412 x 10\u00b3 = 412K \u00b1 1% y 5 ppm/K</p>"},{"location":"conceptos/discretos/#el-diodo-led","title":"El diodo LED","text":"<p>El diodo LED (Light Emitting Diode) es un diodo semiconductor capaz de emitir luz, lo mas usuales dentro del espectro visible aunque tambi\u00e9n pueden ser de infrarrojos, laser, etc. Su uso mas habitual es como indicador y, \u00faltimamente cada vez mas frecuentes en iluminaci\u00f3n. Sus principales ventajas frente a luces incandescentes son:</p> <ul> <li>Menor consumo de energ\u00eda</li> <li>Mayor vida \u00fatil</li> <li>Menor tama\u00f1o</li> <li>Gran durabilidad y fiabilidad</li> <li>En la imagen siguiente vemos el aspecto f\u00edsico que tiene y su s\u00edmbolo electr\u00f3nico.</li> </ul> <p> <p> Aspecto y s\u00edmbolo del LED</p> <p></p> <p>El color de la c\u00e1psula es simplemente orientativo, es la longitud de onda quien define realmente el color de la luz emitida. Por ello el LED con la c\u00e1psula transparente puede emitir en cualquiera de los colores del espectro visible.</p> <p>La forma de la capsula mas habitual es cil\u00edndrica de 3 o 5 mm de di\u00e1metro, aunque existen otras formas menos usuales como las que vemos en la imagen siguiente:</p> <p> <p> Tipos de encapsulados para LEDs</p> <p></p> <p>El LED es un dispositivo que tiene polaridad siendo su comportamiento el siguiente: En polarizaci\u00f3n directa (\u00e1nodo a positivo y c\u00e1todo a negativo) el LED emite luz y en polarizaci\u00f3n inversa (\u00e1nodo negativo y c\u00e1todo positivo) se comporta pr\u00e1cticamente como un interruptor abierto.</p> <p>Para su correcto funcionamiento el diodo LED se polariza poni\u00e9ndole en serie una resistencia que limita la corriente que pasa a trav\u00e9s del mismo y, por tanto, determina el nivel de brillo de la luz emitida.</p> <p>Sin entrar en detalles en la tabla siguiente se dan los valores de tensi\u00f3n directa (VF) y corriente directa (IF) para los colores mas habituales de LEDs. A partir de estos valores y el valor de tensi\u00f3n de alimentaci\u00f3n de nuestro LED podemos calcular el valor de la resistencia serie sin mas que aplicar la formula indicada.</p> <p> <p> Tensi\u00f3n y corriente para distintos colores</p> <p></p>"},{"location":"conceptos/ohm/","title":"Ley de Ohm","text":"<p>Es una ley que publica el f\u00edsico alem\u00e1n Georg Sim\u00f3n Ohm en 1827. Su descubrimiento consisti\u00f3 en ver que una corriente electrica (I) que circula a trav\u00e9s de un conductor es proporcional a la diferencia de potencial (V) entre los extremos del conductor e inversamente proporcional a la resistencia el\u00e9ctrica (R) del mismo. La ley de Ohm establece esta relaci\u00f3n:</p> <p> <p>I = \\dfrac {V}{R} \\space;\\space R = \\dfrac {V}{I} \\space;\\space V = I \\cdot R</p> <p></p> <p> <p> Circuito base de la ley de Ohm</p> <p></p>"},{"location":"conceptos/ohm/#unidades","title":"Unidades","text":"<p>La ley de Ohm relaciona tres magnitudes el\u00e9ctricas que se denominan, representan habitualmente y su unidad fundamental de medida es:</p> <ul> <li>Voltaje o tensi\u00f3n, se representa por la letra V y a veces por la U y se mide en voltios, que se representan por V.</li> <li>Intensidad de corriente, se representa por la letra I y se mide en Amperios que se representan por A.</li> <li> <p>Resistencia el\u00e9ctrica, se representa por la letra R y se mide en Ohmios que se representan por \\Omega o por facilidad de escritura con una R, o incluso se omite para valores bajos de resistencia.</p> </li> <li> <p>La unidad de corriente (I) es el amperio (A). En electr\u00f3nica las corrientes de amperios no son muy usuales y se suelen usar los subm\u00faltiplos de, as\u00ed que 1A = 1000mA (miliamprerios) y 1A = 1000000\u03bcA (microamperios) o lo que es lo mismo, 1mA = 1000\u03bcA.</p> </li> <li> <p>La unidad de tensi\u00f3n (V) es el voltio. Otras unidades habituales son 1kV (kilovoltio) = 1000V, 1V = 1000 mV (milivoltio), 1mV = 1000\u03bcV (microvoltio).</p> </li> <li> <p>La unidad de resistencia es el ohmios (\\Omega que, por facilidad, se suele sustituir por R). 1K \\Omega (kilohmio) = 1K = 1000R, 1M \\Omega (megaohmio) = 1000K = 1000000R.</p> </li> </ul>"},{"location":"conceptos/ohm/#ecuaciones-de-la-ley-de-ohm","title":"Ecuaciones de la ley de Ohm","text":"<p>Una forma cl\u00e1sica de representar la ley de Ohm es mediante un tri\u00e1ngulo equilatero dividido en tres partes (ver imagen siguiente) donde la divisi\u00f3n horizontal interior representa la l\u00ednea de fracci\u00f3n y la vertical la multiplicaci\u00f3n. De esta forma es f\u00e1cil recordarla.</p> <p> <p> Tri\u00e1ngulo nmem\u00f3nico de la ley de Ohm</p> <p></p> <p>Tapando la unidad que buscamos aparece la relaci\u00f3n entre las otras dos.</p> <p>Otro diagrama que muestra la forma en que se relacionan las magnitudes que intervienen en la ley de Ohm es:</p> <p> <p> Diagrama circular de la ley de Ohm</p> <p></p>"},{"location":"conceptos/ohm/#circuito","title":"Circuito","text":"<p>Para que la corriente circule es necesario un circuito o lazo cerrado formado por componentes electr\u00f3nicos. En la figura siguiente, a la izquierda vemos representado un circuito de bucle cerrado, por lo que la corriente circula a trav\u00e9s del mismo. A la derecha vemos un circuito abierto por el que no circula corriente.</p> <p> <p> Tri\u00e1ngulo nmem\u00f3nico de la ley de Ohm</p> <p></p>"},{"location":"conceptos/ohm/#resistencias-pull-up-y-pull-down","title":"Resistencias pull-up y pull-down","text":"<p>Cuando necesitamos conectar ciertos elementos a alg\u00fan pin de entrada, como por ejemplo un pulsador externo, no se puede hacer directamente porque cuando se acciona el pulsador se crea un cortocircuito en la alimentaci\u00f3n que puede incluso da\u00f1ar de manera irreversible nuestro dispositivo.</p> <p>Lo que se hace es colocar un resistencia de alto valor (4K7 a 10K) entre Vcc y GND en serie con el pulsador y tomar la se\u00f1al de salida de la uni\u00f3n de ambos elementos. Seg\u00fan situ\u00e9mos el pulsador y la resistencia tendremos uno u otro caso.</p> <p> <p> Pull-up y pull-down externos</p> <p></p> <p>Hay algunos pines que tienen la posibilidad de habilitar su propia resistencia que ya llevan incorporada habl\u00e1ndose entonces de pull-up o pull-down interno.</p>"},{"location":"conceptos/signals/","title":"Conceptos t\u00e9cnicos","text":"<p>Secci\u00f3n dedicada al estudio inicial de las se\u00f1ales en este tipo de electr\u00f3nica y algunas formas de trabajar con las mismas.</p>"},{"location":"conceptos/signals/#senales-digitales-y-analogicas","title":"Se\u00f1ales digitales y anal\u00f3gicas","text":"<p>Vamos a ver una muy breve introducci\u00f3n a los circuitos digitales y anal\u00f3gicos que nos permita distinguir unos de otros y como tratar sus se\u00f1ales.</p> <p>Una se\u00f1al digital es una se\u00f1al discreta en el tiempo y por tanto est\u00e1 formada por una secuencia de cantidades. Una se\u00f1al digital puede cambiar instantaneamente su valor, como por ejemplo el estado de un pulsador, que puede estar accionado o no. En la pr\u00e1ctica son se\u00f1ales que se denominan cuadradas, por su forma.</p> <p>La electr\u00f3nica digital utiliza magnitudes con dos valores discretos conocidos como '0 - 1, alto - bajo, on - off, High - Low', etc, y que se corresponden con la presencia o no de tensi\u00f3n en un determinado punto. Estos valores discretos pueden sufrir peque\u00f1as variaciones en alguna variable del circuito pero, si no cambia el valor discreto no se produce ning\u00fan cambio en el comportamiento del circuito por lo que podemos decir que este no depende del valor exacto de la se\u00f1al. En la figura siguiente vemos una se\u00f1al digital t\u00edpica.</p> <p> <p> Se\u00f1al digital</p> <p></p> <p>Una se\u00f1al anal\u00f3gica es una se\u00f1al que cambia de valor con el tiempo de manera continuada. En la vida real la mayor\u00eda de las se\u00f1ales son anal\u00f3gicas, como por ejemplo la temperatura, que a lo largo de un d\u00eda est\u00e1 cambiando continuamente pero en valores discretos y no con cambios importantes. En la pr\u00e1ctica son ondas que varian en funci\u00f3n del tiempo.</p> <p>La electr\u00f3nica anal\u00f3gica por contra emplea magnitudes con valores continuos o variables continuas. Una peque\u00f1a variaci\u00f3n en una variable puede producir un gran cambio en el comportamiento del circuito. En la imagen vemos un ejemplo de se\u00f1al anal\u00f3gica simple.</p> <p> <p> Se\u00f1al anal\u00f3gica</p> <p></p> <p>En las placas micro:bit disponemos de 25 conectores situados en el borde inferior. En general diremos que los pines son de tipo GPIO o pines de entrada/salida de prop\u00f3sito general. Algunos pines son para E/S serie, SPI e I2C</p> <p>Un pin GPIO (General Purpose Input/Output, Entrada/Salida de Prop\u00f3sito General) es un pin gen\u00e9rico, cuyo comportamiento (incluyendo si es un pin de entrada o de salida) se puede programar por el usuario en tiempo de ejecuci\u00f3n. En el apartado de informaci\u00f3n t\u00e9cnica siguiente se profundiza en que es cada pin.</p>"},{"location":"conceptos/signals/#pwm","title":"PWM","text":"<p>PWM son siglas en ingl\u00e9s que significan Pulse Width Modulation, que lo podemos traducir a espa\u00f1ol como modulaci\u00f3n de ancho de pulso. Los pines PWM permiten generar una se\u00f1al anal\u00f3gica mediante una salida digital mapeada con 8 bits, o lo que es lo mismo, valores del 0 al 255, es decir mediante una salida PWM podemos emular una se\u00f1al anal\u00f3gica.</p> <p>En realidad una placa microcontrolada no es capaz de generar una salida anal\u00f3gica y lo que se hace es emplear un truco que consiste en activar una salida digital durante un tiempo y el resto del tiempo del ciclo mantenerla desactivada. El valor promedio de la salida es el valor anal\u00f3gico. En el tipo de modulaci\u00f3n PWM mantendremos constante la frecuencia, o lo que es lo mismo, el tiempo entre pulsos y lo que se hace es variar la anchura del pulso.</p> <p>La proporci\u00f3n de tiempo que est\u00e1 encendida la se\u00f1al, respecto al total del ciclo, se denomina ciclo de trabajo o Duty cycle, y generalmente se expresa en tanto por ciento. En la imagen siguiente vemos se\u00f1ales con distintos ciclos de trabajo.</p> <p> <p> Distintos Duty cicle</p> <p></p> <p>Las se\u00f1ales PWM emulan una se\u00f1al anal\u00f3gica para aplicaciones como variar la luminosidad de un LED y variar la velocidad de motores de corriente continua.</p> <p>Por limitaciones impuestas por la circuiter\u00eda de micro:bit solamente pueden coexistir tres pines PWM de manera simultanea. Si intentamos habilitar un cuarto pin PWM se desabilitar\u00e1 alg\u00fan otro pin PWM.</p>"},{"location":"conceptos/signals/#el-bus-i2c","title":"El bus I2C","text":"<p>Las siglas I2C corresponden en realidad a I\u00b2C que tiene su origen en las iniciales del ingl\u00e9s Inter-Integrated Circuit (IIC = I\u00b2C) y que siginifican Circuito Inter-Integrado y vamos a explicar un poco en que consiste este sistema de conexionado.</p> <p>El bus conocido por las siglas I2C, IIC o I\u00b2C, es un bus serie de datos desarrollado en 1982 por Philips Semiconductors (hoy NXP Semiconductors, parte de Qualcomm). Se utiliza principalmente internamente para la comunicaci\u00f3n entre diferentes partes de un circuito, por ejemplo, entre un controlador y circuitos perif\u00e9ricos integrados. Posteriormente fue adoptado progresivamente por otros fabricantes hasta convertirse en un est\u00e1ndar del mercado con miles de circuitos integrados de diferentes fabricantes.</p> <p>I2C tambi\u00e9n se denomina TWI (Two Wired Interface) \u00fanicamente por motivos de licencia, denominaci\u00f3n introducida por Atmel. No obstante, la patente caduc\u00f3 en 2006, por lo que actualmente no hay restricci\u00f3n sobre el uso del t\u00e9rmino I2C.</p> <p>El bus I2C requiere \u00fanicamente dos cables o lineas de se\u00f1al para su funcionamiento, uno para la se\u00f1al de reloj (SCL, Serial Clock) y otro para el env\u00edo de datos (SDA, Serial Data). Ambas l\u00edneas precisan resistencias de pull-up hacia Vcc. Cualquier dispositivo conectado a estas l\u00edneas es de drenador o colector abierto (Open Collector), lo cual en combinaci\u00f3n con las resistencias pull-up, crea un circuito Wired-AND. En la imagen siguiente vemos el diagrama b\u00e1sico de conexionado del bus con algunos ejemplos de dispositivos. La se\u00f1al de reloj siempre es generada por el circuito que act\u00faa como Master.</p> <p> <p> Diagrama de conexi\u00f3n del bus I2C</p> <p></p> <p>Para ser reconocido en el bus, cada dispositivo dispone de una direcci\u00f3n f\u00edsica, que se emplea para acceder a cada uno de ellos de forma individual. Esta direcci\u00f3n puede ser fijada por hardware, en cuyo caso se pueden modificar los \u00faltimos 3 bits mediante \u201cjumpers\u201d o microinterruptores, o por software.</p> <p>En general, cada dispositivo conectado al bus debe tener una direcci\u00f3n \u00fanica. Si tenemos varios dispositivos similares tendremos que cambiar la direcci\u00f3n o, en caso de no ser posible, implementar un bus secundario.</p> <p>El bus I2C tiene una arquitectura de tipo master-slave, lo que indica que el master es el encargado de controlar al resto de dispositivos tipo slave con los que se comunica y que se comunican con el, teniendo siempre el master prioridad absoluta. El dispositivo master es el que inicia la comunicaci\u00f3n con los slaves. Los slaves no pueden iniciar la comunicaci\u00f3n (el master tiene que preguntarles), ni hablar entre si directamente.</p> <p>El bus I2C debe ser por lo tanto s\u00edncrono, es decir debe existir una se\u00f1al de reloj que controle las comunicaciones. Es el master el que proporciona la se\u00f1al de reloj, que mantiene sincronizados a todos los dispositivos del bus. De esta forma, se elimina la necesidad de que cada dispositivo tenga su propio reloj, de tener que acordar una velocidad de transmisi\u00f3n y mecanismos para mantener la transmisi\u00f3n sincronizada como en UART o SPI. En la imagen vemos un cronograma ejemplo del funcionamiento del sistema.</p> <p> <p> Cronograma de trabajo del bus I2C</p> <p></p> <p>El protocolo de comunicaci\u00f3n I2C sigue la siguiente secuencia:</p> <ul> <li>Primero, el master genera la se\u00f1al de reloj del bus (SCL).</li> <li>Se inicia la comunicaci\u00f3n por orden del master al establecer la condici\u00f3n de START, que se produce cuando SDA pasa de uno a cero y se mantiene en cero durante un tiempo.</li> <li>El master direcciona a los slaves.</li> <li>El master indica si se va a leer o escribir.</li> <li>El slave direccionado responde con una se\u00f1al de conformidad ACK (acknowledge).</li> <li>Se transmite los datos byte a byte desde SDA al receptor. Por cada pulso desde SCL se transmite un bit de informaci\u00f3n.</li> <li>El destinatario de la informaci\u00f3n responde con una se\u00f1al de conformidad ACK.</li> <li>Se acaba la comunicaci\u00f3n cuando el master establece la condici\u00f3n de STOP, que se produce cuando SDA, por orden del master pasa de cero a uno y se mantiene en uno durante un tiempo.</li> </ul> <p>Son muchos los dispositivos I2C que se pueden direccionar por este bus I2C, siendo lo m\u00e1s com\u00fan en los dispositivos para I2C que utilicen direcciones de 7 bits, aunque existen dispositivos de 10 bits, pero es un caso raro. Una direcci\u00f3n de 7 bits implica que se pueden poner hasta 128 (27) dispositivos sobre un bus I2C. Hemos visto que las direcciones son de 8 bits y esto es porque el bit extra de los 7 de la direcci\u00f3n lo emplea el master para informar al slave si va a leer o escribir. Si el bit de lectura/escritura es cero, el dispositivo master est\u00e1 escribiendo en el slave. Si el bit es 1 el master est\u00e1 leyendo desde el slave. La direcci\u00f3n de 7 bit se coloca en los 7 bits m\u00e1s significativos del byte y el bit de lectura/escritura es el bit menos significativo.</p>"},{"location":"guias/intro/","title":"Introducci\u00f3n a Python","text":""},{"location":"guias/intro/#que-es-python-y-de-donde-viene","title":"\u00bfQue es Python y de donde viene?","text":"<p>Una breve introducci\u00f3n a cosas de Python que nos pueden ayudar con la gu\u00eda de MicroPython. Al final se trata el asunto de los permisos en Linux, que aunque sea un poco \"off topic\" puede resultar \u00fatil.</p>"},{"location":"guias/intro/#creador-de-python","title":"Creador de Python","text":"<p>Python es un lenguaje de programaci\u00f3n interpretado (no hay que compilar los programas) cuya filosof\u00eda hace hincapi\u00e9 en una sintaxis que favorezca un c\u00f3digo legible.</p> <p>Python fue creado a finales de los ochenta, por el holand\u00e9s Guido van Rossum en el Centro para las Matem\u00e1ticas y la Inform\u00e1tica (CWI, Centrum Wiskunde &amp; Informatica), en los Pa\u00edses Bajos.</p> <p>El nombre del lenguaje proviene de la afici\u00f3n de su creador por los humoristas brit\u00e1nicos Monty Python y no de la serpiente del mismo nombre. Aunque se suele usar un s\u00edmbolo con una serpiente pit\u00f3n para representarlo, de ah\u00ed la normal confusi\u00f3n.</p> <p>Se trata de un lenguaje de programaci\u00f3n multiparadigma o que soporta m\u00e1s de un paradigma de programaci\u00f3n, representando un paradigma un enfoque particular o filosof\u00eda para la construcci\u00f3n del software. Python soporta:</p> <ul> <li>Orientaci\u00f3n a objetos. En la programaci\u00f3n orientada a objetos (OOP) los objetos manipulan los datos de entrada para la obtenci\u00f3n de datos de salida espec\u00edficos, donde cada objeto ofrece una funcionalidad especial. Los objetos permiten la agrupaci\u00f3n en librer\u00edas y usualmente permiten al usuario la creaci\u00f3n de sus propias librer\u00edas. Se basa en t\u00e9cnicas de herencia, cohesi\u00f3n, abstracci\u00f3n, polimorfismo, acoplamiento y encapsulamiento.</li> <li>Programaci\u00f3n imperativa. Es la forma natural de programar un ordenador, es el estilo de programaci\u00f3n que se utiliza en el ensamblador y el m\u00e1s cercano a la m\u00e1quina. Sigue la arquitectura arquitectura cl\u00e1sica de Von Newmann con una memoria donde se almacenan los datos y el programa y una unidad de control que ejecuta las instrucciones del programa, conocida c\u00f3mo contador del programa.</li> <li>Programaci\u00f3n funcional. Es un estilo de programaci\u00f3n cuyo m\u00e9todo b\u00e1sico de computaci\u00f3n es la aplicaci\u00f3n de funciones a sus argumentos.</li> </ul>"},{"location":"guias/intro/#filosofia-python","title":"Filosof\u00eda Python","text":"<p>Es muy parecida a la filosof\u00eda de Unix. El c\u00f3digo que sigue los principios de Python de legibilidad y transparencia se dice que es \"pythonic\". Por el contrario, el c\u00f3digo opaco u ofuscado es bautizado como \"unpythonic\". Los puntos que describen su filosofia son:</p> <ul> <li>Bello es mejor que feo.</li> <li>Expl\u00edcito es mejor que impl\u00edcito.</li> <li>Simple es mejor que complejo.</li> <li>Complejo es mejor que complicado.</li> <li>Plano es mejor que anidado.</li> <li>Disperso es mejor que denso.</li> <li>La legibilidad cuenta.</li> <li>Los casos especiales no son tan especiales como para quebrantar las reglas.</li> <li>Lo pr\u00e1ctico gana a lo puro.</li> <li>Los errores nunca deber\u00edan dejarse pasar silenciosamente.</li> <li>A menos que hayan sido silenciados expl\u00edcitamente.</li> <li>Frente a la ambig\u00fcedad, rechaza la tentaci\u00f3n de adivinar.</li> <li>Deber\u00eda haber una -y preferiblemente s\u00f3lo una- manera obvia de hacerlo.</li> <li>Aunque esa manera puede no ser obvia al principio a menos que usted sea holand\u00e9s (en clara referencia a su autor).</li> <li>Ahora es mejor que nunca.</li> <li>Aunque nunca es a menudo mejor que ya mismo.</li> <li>Si la implementaci\u00f3n es dif\u00edcil de explicar, es una mala idea.</li> <li>Si la implementaci\u00f3n es f\u00e1cil de explicar, puede que sea una buena idea.</li> <li>Los espacios de nombres (namespaces) son una gran idea \u00a1Hagamos m\u00e1s de esas cosas!</li> </ul> <p>El Zen de Python viene incorporado (en ingl\u00e9s) a partir de la versi\u00f3n 2.1.2 y podemos invocarlo con <code>import this</code> abriendo Python en una terminal en un sistema en el que lo tengamos instalado, l\u00f3gicamente.</p> <p> <p> Arrastrar y soltar un fragmento de c\u00f3digo</p> <p></p>"},{"location":"guias/intro/#tipos-de-permisos-en-linux","title":"Tipos de permisos en Linux","text":"<p>El comando CHMOD nos da la posibilidad de poder cambiar los permisos de los archivos y directorios combinando entre clases y tipos. Hay cuatro clases:</p> <ul> <li>Propietario (u). Creador del archivo o la carpeta</li> <li>Grupo (g). Usuarios que tendr\u00e1n acceso al archivo o carpeta</li> <li>Otros (o). Todos los usuarios</li> <li>Todos (a). Todos los tipos de usuario (propietario, grupo y otros)</li> </ul> <p>Hay tres tipos de permisos:</p> <ul> <li>Lectura ( r). Permite que el usuario vea el archivo pero no puede realizar cambios en el mismo ni copiarlo o borrarlo.</li> <li>Escritura (w). Se permite que los usuarios que acceden al archivo o carpeta puedan realizar sobre el mismo cualquier tipo de edici\u00f3n, copiar, cortar o borrar.</li> <li>Ejecutar (x). Al activar esta opci\u00f3n, la cual viene por defecto deshabilitada, podemos ejecutar archivos.</li> </ul> <p>Hay tres modificadores para la tarea:</p> <ul> <li>+. Concede el permiso</li> <li>-. Deniega el permiso</li> <li>=. Sobreescribe un permiso con el permiso anterior.</li> </ul> <p>En entornos Unix cada permiso tiene el siguiente valor:</p> <ul> <li>Lectura: 4</li> <li>Escritura: 2</li> <li>Ejecuci\u00f3n: 1</li> </ul> <p>Jugando con sumas de estos valores establecemos distintos permisos, por ejemplo, si queremos dar un permiso de escritura usaremos el 6 = 4 + 2 (Lectura + Escritura). Si queremos que pueda ejecutar usaremos el 7 = 4 + 2 + 1 (Lectura + Escritura + Ejecuci\u00f3n).</p> <p>En la tabla tenemos todos los valores posibles.</p> <p> Dec. Bin. Permiso read write exe 0 000 Sin permisos N N N 1 001 Ejecuci\u00f3n N N Y 2 010 Escritura N Y N 3 011 Lectura y escritura N Y Y 4 100 Lectura Y N N 5 101 Lectura y ejecuci\u00f3n Y N Y 6 110 Lectura y escritura Y Y N 7 111 Lectura, escritura y ejecuci\u00f3n Y Y Y <p></p> <p>El procedimiento para establecer el permiso es muy sencillo. Basta con ir a una terminal y ejecutar la siguiente orden:</p> <pre><code>chmod Tipo-permiso Ruta-Archivo\n</code></pre> <p>Ejemplos para modificar permisos en modo terminal:</p> <pre><code>chmod o=rwx * \u2192 Dar permisos de lectura, escritura y ejecuci\u00f3n a los otros usuarios.\n\nchmod go= * \u2192 Quitar todos los permisos a grupo y los otros usuarios.\n\nchmod 666 /Documentos/curso-python/Ejercicios/holamundo.py\n</code></pre> <p>En sistemas Linux con letras veremos algo como lo siguiente:</p> <ul> <li>0 \u2192 ---  \u2192 sin acceso</li> <li>1 \u2192 --x \u2192 ejecuci\u00f3n</li> <li>2 \u2192 -w- \u2192 escritura</li> <li>3 \u2192 -wx \u2192 escritura y ejecuci\u00f3n</li> <li>4 \u2192 r-- \u2192 lectura</li> <li>5 \u2192 r-x \u2192 lectura y ejecuci\u00f3n</li> <li>6 \u2192 rw- \u2192 lectura y escritura</li> <li>7 \u2192 rwx \u2192 lectura, escritura y ejecuci\u00f3n</li> </ul> <p>Por ejemplo: chmod 777. Le damos a los 3 tipos de usuarios permiso de lectura, ejecuci\u00f3n y escritura (hemos sumado4+2+1).  Si queremos dar permisos de lectura y escritura ser\u00eda 4+2 = 6 y si si lo que queremos es s\u00f3lo dar lectura ser\u00eda 4. Si lo que queremos es dar lectura y ejecuci\u00f3n ser\u00eda de sumar 4 + 1 = 5.</p> <p>Diferentes combinaciones t\u00edpicas:</p> <ul> <li>chmod 755. Permiso de lectura y ejecuci\u00f3n (4+1) a todos los usuarios excepto al propietario que lo tiene completo (lectura, escritura, ejecuci\u00f3n 4+2+1).</li> <li>chmod 666. Permisos de lectura y escritura a todos, excepto ejecuci\u00f3n (4+2). Todos pueden acceder al archivo, leer su contenido y modificarlo.</li> <li>chmod 644. Se suele utilizar para no permitr la escritura a nadie que no sea el propietario. El 755 es similar, lectura y ejecuci\u00f3n aunque este es m\u00e1s restrictivo (s\u00f3lo lectura) y (lectura, escritura para propietario).</li> </ul>"},{"location":"guias/intro/#palabras-reservadas-e-identificadores","title":"Palabras reservadas e identificadores","text":""},{"location":"guias/intro/#palabras-reservadas","title":"Palabras reservadas","text":"<p>Son palabras reservadas que tienen un significado especial para el compilador y que no podemos usar para poner nombres a variables o funciones. Todas las palabras, excepto <code>True</code>, <code>False</code> y <code>None</code> se escriben en min\u00fasculas. A continuaci\u00f3n se da un listado de todas las palabras reservadas o keywords:</p> <pre><code>False, None, True, and, as, assert, async, await, break, class, continue, \n\ndef, del, elif, else, except, finally, for, from, global, if, import, in, \n\nis, lambda, nonlocal, not, or, pass, raise, return, try, while, with, yield\n</code></pre> <p>El listado al principio nos puede resultar abrumador, pero imaginemos un lenguaje con tan solo esas palabras y entenderemos que no resultar\u00e1 tan complejo familiarizarse, al menos con las mas usuales.</p>"},{"location":"guias/intro/#identificadores","title":"Identificadores","text":"<p>Los identificadores son los nombres que se dan a variables, clases, m\u00e9todos, etc. No podemos usar palabras reservadas para estos nombres.</p> <p>Algunas reglas que nos pueden resultar \u00fatiles para nombrar idetificadores son:</p> <ul> <li>Los identificadores son sensibles a may\u00fasculas y min\u00fasculas</li> <li>Los identificadores no pueden ser palabras reservadas</li> <li>Los espacios en blanco no est\u00e1n permitidos</li> <li>Un identificador puede ser una secuencia de letras y n\u00fameros. Siempre debe empezar por una letra o por el s\u00edmbolo de subrayado \"_\". El primer car\u00e1cter de un identificador no puede ser un n\u00famero.</li> <li>No podemos utilizar caracteres especiales como la \u00f1, \u00a1, \u00bf o letras con acentos.</li> <li>No podemos utilizar los s\u00edmbolos como !, @, #, $, etc.</li> </ul> <p>Nos va a resultar muy \u00fatil recordar lo siguiente:</p> <ul> <li>Python es un lenguaje que distingue entre may\u00fasculas y min\u00fasculas. Esto significa que <code>Variable</code> y <code>variable</code> no son lo mismo</li> <li>Damos siempre a los identificadores un nombre que tenga sentido. Aunque que <code>c = 10</code> es un perfectamente v\u00e1lido, escribir <code>contador = 10</code> tendr\u00eda m\u00e1s sentido, y ser\u00eda m\u00e1s f\u00e1cil averiguar lo que representa cuando miremo el c\u00f3digo pasado un tiempo.</li> <li>Las palabras m\u00faltiples se pueden separar usando un gui\u00f3n bajo, como por ejemplo <code>esto_es_un_nombre_de_variable_muy_largo</code>.</li> </ul>"},{"location":"guias/intro/#variables-constantes-y-literales","title":"Variables, constantes y literales","text":""},{"location":"guias/intro/#variables","title":"Variables","text":"<p>En programaci\u00f3n, una variable es un nombre que se utiliza para referirse a una posici\u00f3n de memoria donde se almacena un valor. De forma m\u00e1s abstracta, puede considerarse como una caja que almacena un valor. El nombre de la caja es el nombre de la variable y el contenido su valor. Todas las variables constan de tres partes: un nombre, un tipo de dato y un valor. En la figura siguiente vemos tres variables de distintos tipos:</p> <p> <p> Concepto gr\u00e1fico de variable</p> <p>Enlace a la fuente</p> <p></p> <p>La variable <code>name</code> contiene la cadena <code>Bob</code>, la variable <code>winner</code> es cierta y la variable <code>score</code> contiene el valor <code>35</code>.</p> <p>Python no dispone de ning\u00fan comando para declarar variables. Una variable se crea cuando se le asigna valor por primera vez. La t\u00e9cnica de declarar variables es poner un nombre seguido del signo de asignaci\u00f3n (=) y el valor asignado a la variable. En la declaraci\u00f3n es importante tener claro que se distinguen may\u00fasculas de min\u00fasculas y que no est\u00e1n permitidos los caracteres especiales.</p> <p>En Python no se declara de forma explicita el tipo de la variable pues se trata de un lenguaje inferido. Las variables incluso pueden cambiar de tipo desde el que se establece al asignarle valor la primera vez. Es decir, si declaro <code>valor = 5</code> inicialmente la variable ser\u00e1 de tipo entero (int), pero si en el programa se realizan operaciones que al final hacen que <code>valor = 1.33</code> ahora valor es de tipo float. Autom\u00e1ticamente sabe que <code>valor</code> es un n\u00famero entero y declara la variable <code>valor</code> como un <code>int</code>.</p> <p>Aunque no es necesario si es posible especificar el tipo de dato de una variable, haciendo:</p> <pre><code>x = str(22) # x ser\u00e1 la cadena '22'\ny = int(22) # y ser\u00e1 el entero 22\nz = float(22) # z ser\u00e1 el n\u00famero de coma flotante 22.0\n</code></pre> <p>Es posible saber el tipo de una variable en un momento dado con la sentencia <code>type(variable)</code>.</p> <p>Algunas reglas para nombrar variables que podemos tener en cuenta son:</p> <ul> <li>Los nombres pueden tener una combinaci\u00f3n de letras min\u00fasculas o may\u00fasculas o n\u00fameros o el s\u00edmbolo de subrayado \"_\".</li> <li>Crear nombres que tengan sentido, aunque sean largos.</li> <li>Si usamos varias palabras para definir el nombre, estas las separamos por \"_\"</li> <li>Python es sensible a may\u00fasculas y min\u00fasculas.</li> <li>Hay que evitar palabras reservadas en nombres de variables.</li> </ul>"},{"location":"guias/intro/#constantes","title":"Constantes","text":"<p>Una constante no es mas que un tipo especial de variable cuyo valor no puede modificarse.</p> <p>En Python, las constantes suelen declararse y asignarse en un m\u00f3dulo (un nuevo archivo que contiene variables, funciones, etc y que se importa al archivo principal).</p> <p>Veamos c\u00f3mo declaramos constantes en un archivo separado y lo usamos en el archivo principal,</p> <ul> <li>Creamos un archivo que nombramos constantes.py y que contendr\u00e1:</li> </ul> <pre><code>PI = 3.141592\nFUERZA_GRAVEDAD = 9.82\n</code></pre> <ul> <li>Creamos el archivo principal main.py, que contendr\u00e1:</li> </ul> <pre><code>import constantes\n\nprint(constantes.PI)\nprint(constantes.FUERZA_GRAVEDAD)\n</code></pre> <p>En el ejemplo creamos el archivo de m\u00f3dulo constantes.py y asignamos el valor constante a PI y FUERZA_GRAVEDAD.</p> <p>Despu\u00e9s, creamos el archivo main.py e importamos el m\u00f3dulo constantes. Finalmente, imprimimos el valor de cada constante.</p> <p>La convenci\u00f3n es nombrarlas en may\u00fasculas para distinguirlas de las variables.</p>"},{"location":"guias/intro/#literales","title":"Literales","text":"<ul> <li>Num\u00e9ricos</li> </ul> <p>Los literales son representaciones de valores fijos en un programa. Pueden ser n\u00fameros, caracteres, cadenas, etc. Por ejemplo, \"\u00a1Hola, mundo!\", 12, 23.0, \"C\", etc.</p> <p>Los literales num\u00e9ricos son inmutables (no pueden cambiar) y pueden pertenecer a uno de los tres tipos de datos num\u00e9ricos posibles: Entero, Coma flotante y Complejo. Los tipos son:</p> <ul> <li>Decimal. N\u00fameros regulares. Por ejemplo: 5, 22, -40</li> <li>Binario. Deben comenzar por 0b. Por ejemplo: 0b110, 0b11</li> <li>Octal. Deben empezar con 0o. Por ejemplo: 0o13, 0o7</li> <li>Hexadedicmal. Deben empezar con 0x. Por ejemplo 0x13, 0xFF</li> <li>Coma flotante. Contienen el punto decimal. Por ejemplo 10.2, 3.14</li> <li> <p>Complejo. Tienen la forma <code>a + bj</code>. Por ejemplo: 3 - 2j, -4 + j</p> </li> <li> <p>Booleanos</p> </li> </ul> <p>Solamente hay dos literales booleanos <code>True</code> y <code>False</code></p> <ul> <li>Cadenas de caracteres</li> </ul> <p>Los literales de caracteres son caracteres unicode encerrados entre comillas, por ejemplo <code>S</code>. Los literales cadenas de caracteres son cadenas de csaracteres encerradas entre comillas, por ejemplo <code>Python es divertido</code>.</p> <ul> <li>Especiales</li> </ul> <p>En Python existe un literal especial, <code>None</code>. Podemos usarlo, por ejemplo, para especificar una variable nula, por ejemplo:</p> <pre><code>var = None\nprint(var)\n# El resultado ser\u00e1: None\n</code></pre>"},{"location":"guias/intro/#tipos-de-datos-en-python","title":"Tipos de datos en Python","text":"<p>En Python, al igual que en programaci\u00f3n en general, los tipos de datos especifican el tipo de datos que puede almacenarse en una variable.</p>"},{"location":"guias/intro/#numericos","title":"Num\u00e9ricos","text":"<p>Contienen valores num\u00e9ricos y sabemos que:</p> <ul> <li>Los n\u00fameros enteros son de tipo int</li> <li>Los fraccionarios son de tipo float</li> <li>La divisi\u00f3n (/) siempre devuelve un n\u00famero en coma flotante</li> <li>Para obtener la parte entera de una divisi\u00f3n se usa el operador //</li> <li>Para calcular el resto de una divisi\u00f3n se usa el operador %</li> <li>Para calcular potencias podemos usar el operador **</li> <li>Los par\u00e9ntesis se pueden usar para agrupar expresiones</li> <li>El signo igual (=) se utiliza para asignar un valor (n\u00fameros, booleanos, cadenas, \u2026) a una variable</li> <li>El tipo de la variable ser\u00e1 el del dato asignado, no se declara el tipo de la variable al crearla</li> <li>Por convenci\u00f3n el nombre comienza en min\u00fascula y si son varias palabras se unen por gui\u00f3n bajo</li> </ul> <p>Los tipos b\u00e1sicos de datos son:</p> <ul> <li><code>int</code>: n\u00fameros enteros con signo sin l\u00edmite de tama\u00f1o, ejemplo: entero = 5</li> <li><code>float</code>: n\u00fameros reales, decimales o de coma flotante con precisi\u00f3n de hasta 15 decimales, ejemplo: real = 5.6</li> <li><code>complex</code>: n\u00fameros complejos, por ejemplo 5.5 - 5j</li> <li>Para averiguar el tipo de dato usamos la funci\u00f3n <code>type()</code>.</li> </ul> <p>Podemos realizar conversi\u00f3n de tipos as\u00ed:</p> <ul> <li>A entero int(variable)</li> <li>A real float(variable)</li> </ul>"},{"location":"guias/intro/#cadenas","title":"Cadenas","text":"<p>Contienen secuencias de caracteres. Una cadena es una secuencia de caracteres representada entre comillas simples o dobles.</p> <p>Las cadenas pueden estar encerradas entre comillas simples ('...') o dobles (\"...\") con el mismo resultado. Podemos usar  para incluir comillas en una cadena.</p> <p>La funci\u00f3n print() devuelve la cadena que encierra entre los par\u00e9ntesis, omitiendo las comillas que la encierran.</p> <p>En la imagen siguiente se ven varios ejemplos con cadenas utilizando como editor el IDLE que por defecto se instala con Python y que se abre desde una terminal simplemente invocando a Python.</p> <p> <p> Cadenas en el IDLE</p> <p></p> <p>Una cadena raw (cruda) se interpreta tal como se escribe, es decir, se omiten los caracteres especiales expresados con . Las cadenas raw se escriben entrecomilladas y van precedidas del car\u00e1cter 'r'. En la imagen vemos un ejemplo.</p> <p> <p> Cadena cruda en el IDLE</p> <p></p> <p>Es posible aplicar la operaci\u00f3n de multiplicar a textos haciendo que estos se repitan. En la imagen siguientes vemos ejemplos de concatenaci\u00f3n y multiplicaci\u00f3n, as\u00ed como un error cometido.</p> <p> <p> Concatenar y multiplicar textos en el IDLE</p> <p></p>"},{"location":"guias/intro/#secuencias","title":"Secuencias","text":"<p>Contienen colecciones de datos, como las listas, las tuplas, las colecciones de datos (set) o los diccionarios.</p> <p>Una lista es una colecci\u00f3n ordenada de elementos similares o de distinto tipo separados por comas y encerrados entre corchetes [ ].</p> <p>Tupla es una secuencia ordenada de elementos, igual que una lista. La \u00fanica diferencia es que las tuplas son inmutables. Una vez creadas, las tuplas no pueden modificarse. En Python, se utilizan los par\u00e9ntesis () para almacenar los elementos de una tupla.</p> <p>Las colecciones de datos son un conjunto desordenada de elementos \u00fanicos. Una colecci\u00f3n de datos se define por valores separados por comas dentro de llaves { }.</p> <p>Un diccionario es una colecci\u00f3n ordenada de elementos. Almacena los elementos como pares clave/valor. Siendo las claves identificadores \u00fanicos que se asocian a cada valor.</p> <p>Estudiaremos estos \u00faltimos tipos mas extensamente cuando los necesitemos.</p> <p>Los datos de tipo booleano solamente pueden contener <code>True</code> o <code>False</code>.</p> <p>Dado que en programaci\u00f3n Python todo es un objeto, los tipos de datos son en realidad clases y las variables son instancias(objeto) de estas clases.</p>"},{"location":"guias/intro/#comentarios-en-python","title":"Comentarios en Python","text":"<ul> <li> <p>Una sola linea: Escribiendo el s\u00edmbolo almohadilla (#) delante del comentario.</p> </li> <li> <p>Multilinea: Escribiendo triple comillas dobles (\u201c\u201d\u201d) al principio y al final del comentario.</p> </li> </ul> <p>En los comentarios, pueden incluirse palabras que nos ayuden a identificar adem\u00e1s, el subtipo de comentario:</p> <pre><code># TODO esto es algo por hacer\n# FIXME (arreglarme) esto es algo que debe corregirse\n# XXX esto tambi\u00e9n, es algo que debe corregirse\n</code></pre>"},{"location":"guias/intro/#identation-o-sangria-en-python","title":"Identation o sangria en Python","text":"<p>La sangr\u00eda se refiere a los espacios al comienzo de una l\u00ednea de c\u00f3digo.</p> <p>Mientras que en otros lenguajes de programaci\u00f3n la sangr\u00eda en el c\u00f3digo es solo para facilitar la lectura, la sangr\u00eda en Python es muy importante ya que se usa para indicar un bloque de c\u00f3digo.</p> <pre><code>if 5 &gt; 2:\n    print(\"Cinco es mayor que 2\")\n</code></pre> <p>Lo siguiente ser\u00eda un error de sintaxis.</p> <pre><code>if 5 &gt; 2:\nprint(\"Cinco es mayor que 2\")\n</code></pre> <p>El n\u00famero de espacios de la identation puede ser cualquiera siempre que al menos sea un espacio. Siempre hay que usar el mismo n\u00famero de espacios en el mismo bloque de c\u00f3digo.</p>"},{"location":"guias/intro/#operadores-en-python","title":"Operadores en Python","text":"<p>Los operadores son s\u00edmbolos especiales que realizan operaciones con variables y valores.</p> <p>A continuaci\u00f3n tenemos una lista de los diferentes tipos de operadores de Python:</p> <ul> <li>Operadores aritm\u00e9ticos</li> <li>Operadores de asignaci\u00f3n</li> <li>Operadores de Comparaci\u00f3n</li> <li>Operadores L\u00f3gicos</li> <li>Operadores Bitwise</li> <li>Operadores especiales</li> </ul>"},{"location":"guias/intro/#operadores-aritmeticos","title":"Operadores aritm\u00e9ticos","text":"<p>Los operadores aritm\u00e9ticos se utilizan para realizar operaciones matem\u00e1ticas como sumas, restas, multiplicaciones, etc.</p> <p> Operador Descripci\u00f3n Ejemplo + Suma o concatenaci\u00f3n en textos <code>5+3=8</code>, <code>\"Hola\" + \"Mundo\" = \"Hola Mundo</code> - Diferencia <code>6-3=3</code> * Multiplicaci\u00f3n <code>3*3=9</code> / Divisi\u00f3n <code>6/2=3</code> // Parte entera de un cociente <code>10//3=3</code> % Resto de un cociente <code>10%3=1</code> ** Potenciaci\u00f3n <code>5**2=25</code> <p></p>"},{"location":"guias/intro/#operadores-de-asignacion","title":"Operadores de asignaci\u00f3n","text":"<p>Los operadores de asignaci\u00f3n se utilizan para asignar valores a variables.</p> <p> Operador Descripci\u00f3n Ejemplo = Asignaci\u00f3n <code>x=4</code>, <code>a = a + 1</code> += Suma y asignaci\u00f3n <code>x+=1</code> equivale a <code>x = x + 1</code> -= Diferencia y asignaci\u00f3n <code>x-=1</code> equivale a <code>x = x - 1</code> *= Multiplicaci\u00f3n y asignaci\u00f3n <code>x*=3</code> equivale a <code>x = x * 3</code> /= Divisi\u00f3n y asignaci\u00f3n <code>x/=3</code> equivale a <code>x = x / 3</code> %= Asignaci\u00f3n de restos <code>x%=3</code> equivale a <code>x = x % 3</code> **= Asignaci\u00f3n de exponentes <code>x**=3</code> equivale a <code>x = x ** 3</code> <p></p>"},{"location":"guias/intro/#operadores-de-comparacion","title":"Operadores de Comparaci\u00f3n","text":"<p>Los operadores de comparaci\u00f3n comparan dos valores/variables y devuelven un resultado booleano: Verdadero o Falso <code>True</code> o <code>False</code>.</p> <p> Operador Descripci\u00f3n Ejemplo == Igual a <code>2==3</code> retorna <code>False</code> != Distinto de <code>2!=3</code> retorna <code>True</code> &lt; Menor que <code>2&lt;3</code> retorna <code>True</code> &gt; Mayor que <code>2&gt;3</code> retorna <code>False</code> &lt;= Menor o igual que <code>2&lt;=3</code> retorna <code>True</code> &gt;= Mayor o igual que <code>2&gt;=3</code> retorna <code>False</code> <p></p>"},{"location":"guias/intro/#operadores-logicos","title":"Operadores L\u00f3gicos","text":"<p>Los operadores l\u00f3gicos se utilizan para comprobar si una expresi\u00f3n es Verdadera o Falsa. Se utilizan en la toma de decisiones.</p> <p> Operador Descripci\u00f3n Ejemplo and AND l\u00f3gica <code>a and b #True si a y b son ciertos</code> or OR l\u00f3gica <code>a or b #True si a o b son ciertos</code> not NOT l\u00f3gica <code>not a #True si el operador a es falso</code> <p></p> <p>En la figura siguiente vemos un ejemplo con lo que devuelve en cada caso.</p> <p> <p> Ejemplos en el IDLE de operadores l\u00f3gicos</p> <p></p>"},{"location":"guias/intro/#operadores-bitwise","title":"Operadores Bitwise","text":"<p>Los operadores bit a bit o bitwise act\u00faan sobre los operandos como si fueran cadenas de d\u00edgitos binarios. Operan bit a bit, de ah\u00ed su nombre.</p> <p> Operador Descripci\u00f3n Ejemplo &amp; AND bit a bit <code>5&amp;6 # 101 &amp; 110 = 110 = 4</code> | OR bit a bit <code>5 \\| 6 # 101 \\| 110 = 111 = 7</code> ~ NOT bit a bit <code>~3 # ~011 = 100 = -4</code> ^ XOR bit a bit <code>5^3 # 101^011 = 110 = 6</code> &lt;&lt; Desplazamiento izquierda <code>4&lt;&lt;1 # 100 &lt;&lt; 1 = 1000 = 8</code> &gt;&gt; Desplazamiento derecha <code>4 &gt;&gt; 1 # 100 &gt;&gt; 1 = 010 = 2</code> <p></p>"},{"location":"guias/intro/#operadores-especiales","title":"Operadores especiales","text":"<p>El lenguaje Python ofrece algunos tipos especiales de operadores como el operador de identidad (<code>identity</code>) y el operador de pertenencia (<code>membership</code>).</p> <ul> <li>Operadores <code>identity</code></li> </ul> <p>En Python, <code>is</code> e <code>is not</code> se utilizan para comprobar si dos valores se encuentran en la misma parte de la memoria. Dos variables que son iguales no implica que sean id\u00e9nticas. Algunos ejemplos aclaran mejor lo dicho.</p> <pre><code>x1 = 5\ny1 = 5\nx2 = 'Hello'\ny2 = 'Hello'\n\nprint(x1 is not y1)  # False\n\nprint(x2 is y2)  # True\n</code></pre> <p>Vemos que x1 e y1 son enteros con los mismos valores, por lo que son iguales e id\u00e9nticos. Lo mismo ocurre con x2 e y2 (cadenas).</p> <ul> <li>Operadores <code>membership</code></li> </ul> <p>En Python, <code>in</code> y <code>not in</code> son los operadores de pertenencia. Se utilizan para comprobar si un valor o variable se encuentra en una secuencia (cadena, lista, tupla, conjunto y diccionario).</p> <p>En un diccionario s\u00f3lo podemos comprobar la presencia de la clave, no del valor.</p>"},{"location":"guias/mblocks/","title":"Microblocks","text":"<p>MicroBlocks es una herramienta de programaci\u00f3n por bloques basada en Snap!. Se trata de un software que puede trabajar online o localmente y que nos va a permitir programar diferentes placas, entre ellas la micro:bit.</p> <p> <p> Logotipo de MicroBlocks</p> <p>Logotipo descargado de la entrada en SAP de Kathy Giori  titulada Recap of \u201cSneak Preview into MicroBlocks\u201d.</p> <p></p> <p>MicroBlocks es un lenguaje de programaci\u00f3n por bloques similar a Scratch que es una excelente herramienta para aprender desde nivel principiante hasta nivel experto y v\u00e1lido para edades que van desde los 8 hasta los 99 a\u00f1os.</p> <p>En el apartado Get Started de su web tenemos descrito como trabajar desde un navegador y los distintos sistemas operativos as\u00ed como los pasos a seguir para configurar nuestra placa y como comenzar a crear programas.</p> <p>En esta ocasi\u00f3n vamos a trabajar de forma local descargando e instalando el programa en nuestro ordenador. En mi caso trabajar\u00e9 con Linux de 64 bits instalando el paquete debian descargado 'ublocks-amd64.deb'. La forma elegida para instalarlo, suponiendo que el paquete est\u00e1 en Descargas, es:</p> <pre><code>sudo dpkg -i ~/Descargas/ublocks-amd64.deb\n</code></pre> <p>Tras la instalaci\u00f3n verificamos que todo est\u00e1 correcto y que Linux ve la placa ejecutando en una terminal lo que vemos en la imagen siguiente.</p> <p> <p> Verificaci\u00f3n de conexi\u00f3n con micro:bit en Linux</p> <p></p> <p>En el enlace Mis notas sobre Linux trabajando con Ubuntu tenemos un par de entradas que describen problemas con el paquete brltty (Braille TTY). En el caso de placas con un chip microcontrolador de la serie USB CP210x, algunas de ellas compatibles con MicroBlocks. Si tenemos este caso el problema se puede resolver eliminando el paquete BRLTTY.</p> <pre><code>sudo apt remove brltty\n</code></pre> <p>El programa una vez instalado lo tenemos disponible en aplicaciones, como vemos en la imagen siguiente.</p> <p> <p> App MicroBlocks disponible</p> <p></p>"},{"location":"guias/mblocks/#por-que-usar-microblocks","title":"\u00bfPor qu\u00e9 usar MicroBlocks?","text":"<p>MicroBlocks tiene una caracter\u00edstica que lo distingue de otros lenguajes de programaci\u00f3n por bloques y es que la programaci\u00f3n real ocurre seg\u00fan se desarrolla el programa, lo que podemos denominar como programaci\u00f3n en directo o en vivo y, debido a esto, que implica que el c\u00f3digo se descarga seg\u00fan se escribe tenemos la otra caracter\u00edstica que le dota de independencia o autonom\u00eda, ya que cuando demos el programa por bueno, este ya est\u00e1 grabado como firmware en la placa.</p> <p>Otra de la caracter\u00edsticas importantes que ofrece MicroBlocks es la multitarea o posibilidad de desarrollar funcionalidades que trabajan de forma paralela y separada cada tarea. Por ejemplo, reproducir un sonido mientras se controla un servomotor. Esta forma de trabajo hace que el c\u00f3digo sea mas sencillo de escribir y de entender.</p> <p>Cuando trabajamos con MicroBlocks la placa que conectemos se comporta como una tarjeta de memoria. No hay necesidad de leer un archivo de proyecto, simplemente conectamos la placa y el script o programa nos aparecer\u00e1 en el IDE. Es decir, MicroBlocks lee el programa que hay en la placa y lo carga de manera autom\u00e1tica.</p> <p>El funcionamiento de MicroBlocks se basa en:</p> <ul> <li>El editor de bloques o IDE que se puede ejecutar online o de manera local.</li> <li>Una m\u00e1quina virtual que se ejecuta en la placa microcontroladora. Esta m\u00e1quina virtual es la encargada de ejecutar el programa de usuario y lo hace compilando en c\u00f3digo de bytes o instrucciones de bajo nivel muy parecidas al c\u00f3digo m\u00e1quina. Si tenemos habilitados los bloques avanzados podemos ver los bytes generados por el programa, como vemos en la animaci\u00f3n siguiente:</li> </ul> <p> <p> C\u00f3digo de bytes</p> <p></p> <p>La parte m\u00e1s importante de la informaci\u00f3n de bytes es la primera l\u00ednea, que muestra el n\u00famero de bytes compilados. Los scripts en MicroBlocks no deben superar los 1000 bytes, de ah\u00ed la importancia de esta informaci\u00f3n.</p> <ul> <li>El sistema de comunicaci\u00f3n entre la placa y el host remoto o el ordenador que hace que el firmware se actualice seg\u00fan se escribe el programa. Este sistema es el encargado de enviar los bytes y comandos para iniciar el programa y procesar mensajes del microcontrolador. As\u00ed el editor proporciona realimentaci\u00f3n gr\u00e1fica de lo que sucede en el microcontrolador y directamente puede mostrar valolres en un \"bocadillo de conversaci\u00f3n\" como el de la figura siguiente.</li> </ul> <p> <p> Bocadillo de conversaci\u00f3n</p> <p></p> <p>MicroBlocks tambi\u00e9n dispone de una herramienta de representaci\u00f3n gr\u00e1fica que estudiaremos en su momento.</p> <p>Una funcionalidad importante del editor es que, adem\u00e1s de programar por bloques, administra las Librerias, que est\u00e1n escritas en MicroBlocks. Existen muchas que iremos viendo poco a poco. Las librerias escritas en MicroBlocks pueden ser editadas por los usuarios.</p>"},{"location":"guias/mblocks/#configuracion-del-equipo","title":"Configuraci\u00f3n del equipo","text":"<p>Necesitamos un ordenador (\u00a1no un dispositivo m\u00f3vil!) con un puerto USB, un cable USB y una placa soportada. Podemos ejecutar MicroBlocks en un navegador Chromium, Chrome o Edge, o descargarlo como una aplicaci\u00f3n independiente para Linux, Chromebook, Windows o MacOS. Las placas soportadas son:</p> <ul> <li>BBC micro:bit v1 y v2</li> <li>Calliope mini</li> <li>Circuit Playground Express y Bluefruit</li> <li>Citilab ED1</li> <li>Raspberry Pi Pico and Pico W</li> <li>Adafruit Clue</li> <li>M5Stack Core Grey</li> <li>ESP8266 y ESP32</li> </ul> <p>Los instaladores est\u00e1n disponibles para las versiones liberadas listas para descargar la apropiada para nuestro sistema operativo. Si estamos trabajando con Chrome o Edge es muy posible que nos advierta de que estamos descargando un archivo que podr\u00eda da\u00f1ar nuestro ordenador. Debemos ignorar esta y sucesivas advertencias para proceder con la descarga.</p> <p>En Linux se descarga un paquete .deb, ublocks-amd64.deb en concreto para esta ocasi\u00f3n que se instala de forma muy sencilla. Con una terminal abierta en el directorio donde est\u00e1 el archivo .deb tecleamos:</p> <pre><code>dpkg -i ~/Descargas/ublocks-amd64.deb\n</code></pre> <p>Tras breves instantes el programa estar\u00e1 instalado y lo tendremos disponible en aplicaciones, como ya hemos visto antes.</p>"},{"location":"guias/mblocks/#configuracion-de-la-placa","title":"Configuraci\u00f3n de la placa","text":"<p>El proceso de configuraci\u00f3n de las placas soportadas es muy similar en todas ellas y es seguir el proceso que vamos a ver a continuaci\u00f3n. En este caso particular se toman las im\u00e1genes y animaciones realizando el proceso con una micro:bit V2.21.</p> <p>Conectamos la placa al ordenador y en el men\u00fa de MicroBlocks hacemos clic en el engranaje y seleccionamos la opci\u00f3n 'actualizar firmware de la placa'.</p> <p> <p> Actualizar firmware de la placa</p> <p></p> <p>En el men\u00fa de la ventana emergente tenemos que seleccionar el tipo de placa que hemos conectado.</p> <p> <p> Seleccionar placa</p> <p></p> <p>Si estamos trabajando con MicroBlocks en un navegador, se nos pedir\u00e1 que seleccionemos la placa si a\u00fan no est\u00e1 conectada.</p> <p>Si no hay una placa conectada aparecer\u00e1 el siguiente aviso.</p> <p> <p> No puedo abrir puerto serie</p> <p></p> <p>Si todo est\u00e1 correcto el icono del puerto USB pasa a estar acompa\u00f1ado de un c\u00edrculo verde que indica la conexi\u00f3n.</p> <p> <p> Conexi\u00f3n por puerto serie realizada</p> <p></p> <p>En este video del canal Youtube de MicroBlocks Fun titulado Quick introduction to MicroBlocks for programming a micro:bit (Introducci\u00f3n r\u00e1pida a MicroBlocks para programar un micro:bit) tenemos una introducci\u00f3n r\u00e1pida a MicroBlocks con micro:bit.</p> <p>La informaci\u00f3n en ingl\u00e9s de la guia de usuario y el manual de referencia de bloques tambi\u00e9n pueden resultarnos de gran ayuda.</p>"},{"location":"guias/mblocks/#actualizar-firmware-en-esp32","title":"Actualizar firmware en ESP32","text":"<p>Los dispositivos ESP son una categor\u00eda especial de Espressif que cuentan con capacidad WIFI. En estas placas se borra totalmente el contenido de la memoria flash de la placa y se carga el firmware m\u00e1s reciente. Tras seleccionar ESP32 se inicia la actualizaci\u00f3n del firmware y aparece informaci\u00f3n del progreso en la pantalla.</p> <p> <p> Actualizar firmware en ESP32</p> <p></p>"},{"location":"guias/mblocks/#habilitardeshabilitar-autocarga-de-librerias","title":"Habilitar/deshabilitar autocarga de librerias","text":"<p>Una de las cosas buenas del editor MicroBlocks es que siempre trata de simplificar las cosas a los usuarios. Dado que cada placa con microcontrolador tiene diferentes caracter\u00edsticas, funciones y capacidades, MicroBlocks intenta de forma autom\u00e1tica complementar las funcionalidades b\u00e1sicas cargando las bibliotecas que estime necesarias, siempre que la opci\u00f3n est\u00e9 habilitada, que se distinguir\u00e1 porque la opci\u00f3n disponible es desactivar.</p> <p> <p> Autocarga de librerias activada</p> <p></p> <p>Cuando se selecciona, este elemento se deshabilita esta funcionalidad y depende del usuario cargar las bibliotecas requeridas.</p> <p> <p> Autocarga de librerias desactivada</p> <p></p>"},{"location":"guias/mblocks/#habilitardeshabilitar-plugshare","title":"Habilitar/deshabilitar PlugShare","text":"<p>Otra caracter\u00edstica muy interesante del editor de MicroBlocks es que cargar\u00e1 autom\u00e1ticamente un proyecto desde el microcontrolador conecvtado, si no hay otro proyecto cargado en el editor. La activaci\u00f3n y desactivaci\u00f3n de la opci\u00f3n es id\u00e9ntica a la de la carga de librer\u00edas. Si la opci\u00f3n muestra desactivar es que est\u00e1 habilitada por lo que el editor leer\u00e1 el proyecto desde el dispositivo y luego proceder\u00e1 a cargarlo en el editor. Si la opci\u00f3n muestra activar es que la funcionalidad no est\u00e1 habilitada.</p> <p>Esta funci\u00f3n es muy importante porque permite a los usuarios compartir proyectos simplemente intercambiando sus dispositivos f\u00edsicos y conect\u00e1ndolos a un ordenador. No hay que compartir archivos.</p> <p>Podr\u00edamos denominar a esta funcionalidad como \"conecta y comparte\".</p> <p> <p> PlugShare activado</p> <p></p>"},{"location":"guias/mblocks/#descripcion-general","title":"Descripci\u00f3n general","text":"<p>En la imagen siguiente vemos los nombres de las distintas partes que componen el editor de MicroBlocks.</p> <p> <p> Partes del editor</p> <p></p> <ul> <li>Bloques. Los bloques est\u00e1n organizados por categorias codificadas por colores. Cuando se selecciona una categor\u00eda se despliegan los correspondientes a esa categoria en la zona denominada paleta de bloques. En la wiki de MicroBlocks podemos encontrar una referencia completa a los bloques (Block Reference) con multitud de ejemplos resueltos.</li> <li>Barra de men\u00fas. Contiene, de izquierda a derecha, el icono en forma de globo terraqueo para configurar el idioma, la rueda dentada para entrar en opciones de MicroBlocks, la hoja de papel que muestra el men\u00fa archivo, el gr\u00e1fico es un men\u00fa con opciones de graficar y conectar y el conector USB para el men\u00fa conectar.</li> <li>Nombre del proyecto. Es el nombre del proyecto actual.</li> <li>Botones de inicio/parada. Son dos iconos que sirven para controlar la ejecuci\u00f3n de los programas.</li> <li>Librerias. Aqu\u00ed se muestran las diversas bibliotecas que se cargan seg\u00fan sea requerido.</li> <li>\u00c1rea de bloques de programa. Es donde se crea el programa o script de usuario y las funciones, que en MicroBlocks se conocen como bloques personalizados.</li> <li>Barra de informaci\u00f3n. Si vamos moviendo el rat\u00f3n por los diversos bloques y \u00e1reas del IDE en esta barra se muestra el tipo de bloque y una breve informaci\u00f3n de ayuda sobre los bloques; as\u00ed como la funcionalidad de las distintas \u00e1reas. La informaci\u00f3n detallada del bloque est\u00e1 disponible a trav\u00e9s del men\u00fa contextual de cada bloque.</li> <li>Controles tama\u00f1o bloques. Estos tres controles permiten cambiar el tama\u00f1o de los bloques aumentando (+) o disminuyendo (-), as\u00ed como establecerlos en el tama\u00f1o predeterminado o del 100% de zoom (=).</li> </ul>"},{"location":"guias/mblocks/#idioma","title":"Idioma","text":"<p>En la imagen siguiente vemos el men\u00fa desplegado.</p> <p> <p> Idioma</p> <p></p> <p>Simplemente tenemos que seleccionar el idioma deseado de entre los que est\u00e1 traducido MicroBlocks. Esto configura todos los men\u00fas, mensajes y bloques de c\u00f3digo en ese idioma. La operaci\u00f3n puede demorarse unos segundos dependiendo del equipo en el que se est\u00e9 ejecutando el programa.</p>"},{"location":"guias/mblocks/#microblocks_1","title":"MicroBlocks","text":"<p>En la figura siguiente vemos este men\u00fa desplegado.</p> <p> <p> MicroBlocks</p> <p></p> <ul> <li>La opci\u00f3n 'acerca de...' nos muestra la informaci\u00f3n sobre MicroBlocks que vemos en la imagen siguiente.</li> </ul> <p> <p> acerca de...</p> <p></p> <ul> <li>Actualizar el firmware de la placa es lo que permite al usuario cargar la \u00faltima versi\u00f3n del firmware en la placa conectada. Dependiendo de los dispositivos conectados y de las condiciones se puede desplegar un men\u00fa para seleccionar el dispositivo concreto. Es la opci\u00f3n que utilizaremos para grabar los programas en la placa.</li> <li>Mostrar bloques avanzados modifica el men\u00fa MicroBlocks mostrando mas opciones, como vemos en la imagen siguiente.</li> </ul> <p> <p> Bloques avanzados</p> <p></p> <ul> <li>La opci\u00f3n versi\u00f3n de firmware nos devuelve la versi\u00f3n de firmware de la m\u00e1quina virtual para micro:bit, como vemos en la imagen siguiente.</li> </ul> <p> <p> versi\u00f3n de firmware</p> <p></p> <ul> <li>La opci\u00f3n borra y reparticiona el firmware en placa ESP borra totalmente el contenido de la memoria y carga el programa actual en placas con capacidad EiFi tipo ESP.</li> <li>La opci\u00f3n inicia el servidor HTTP. Activa (o desactiva si est\u00e1 activo) el servidor HTTP de MicroBlocks en el puerto por defecto 6473, aunque este puede ser cambiado.</li> <li>La opci\u00f3n desactiva autocarga de librerias de placa permite desabilitar la funcionalidad de MicroBlocks de que intente autom\u00e1ticamente complementar las funcionalidades b\u00e1sicas del dispositivo conectado cargando varias bibliotecas.</li> <li>La opci\u00f3n activar PlugShare en proyecto en blanco es una funci\u00f3n que si est\u00e1 habilitada hace que el editor de MicroBlocks cargue autom\u00e1ticamente un proyecto desde el microdispositivo conectado, siempre que no haya un proyecto cargado en el editor. Si el \u00edcono de conexi\u00f3n no es verde y est\u00e1 habilitado PlugShare cuando estamos en un proyecto vac\u00edo, tan pronto como se establezca la conexi\u00f3n USB, MicroBlocks leer\u00e1 y cargar\u00e1 el proyecto que contiene el dispositivo conectado.</li> <li>La opci\u00f3n oculta los bloques avanzados devuelve al men\u00fa MicroBlocks a su estado por defecto, que es la opci\u00f3n mas habitual.</li> </ul>"},{"location":"guias/mblocks/#archivo","title":"Archivo","text":"<p>En la figura siguiente vemos este men\u00fa desplegado.</p> <p> <p> Archivo</p> <p></p> <ul> <li>Guarda. Cuando demos por finalizado un proyecto, o tengamos que dejarlo para otro momento sin perder el trabajo realizado, debemos guardarlo en el ordenador. Se nos abrir\u00e1 una ventana como la de la imagen siguiente.</li> </ul> <p> <p> Guarda fichero</p> <p></p> <ul> <li>Nuevo. Para crear nuevos proyectos. Si tenemos un programa cargado en el \u00e1rea de trabajo del editor, mostrar\u00e1 un mensaje solicitando confirmaci\u00f3n para eliminar del editor el proyecto activo. En la imagen siguiente vemos el mensaje.</li> </ul> <p> <p> Confirmacion</p> <p></p> <p>Si la contestaci\u00f3n es 'Si' el \u00e1rea de trabajo queda vac\u00eda y las bibliotecas a\u00f1adidas por el usuario se borran.</p> <ul> <li>Abre. Esta opci\u00f3n permite cargar en el editor proyectos .ubp previamente guardados. Si hay un proyecto cargado en el \u00e1rea de trabajo, se mostrar\u00e1 un mensaje de confirmaci\u00f3n (igual que en Nuevo) y se presenta una ventana de di\u00e1logo que permite localizar y abrir el archivo deseado. En la imagen siguiente vemos esta ventana.</li> </ul> <p> <p> Di\u00e1logo abrir fichero</p> <p></p> <p>En la categor\u00eda Ejemplos es donde se presentan muchos proyectos de MicroBlocks para diferentes microdispositivos y opciones de hardware.</p> <ul> <li>Copia URL del proyecto al portapapeles. Cuando trabajamos online permite compartir el proyecto.</li> </ul>"},{"location":"guias/mblocks/#conectar","title":"Conectar","text":"<p>En la figura siguiente vemos este men\u00fa desplegado. En esta ocasi\u00f3n hay un dispositivo ya conectado y por eso se muestra la opci\u00f3n disconnect (/dev/ttyACM0).</p> <p> <p> Conectar</p> <p></p> <p>Si tenemos varios dispositivos conectados a puertos USB se nos mostrar\u00e1n los mismos para que podamos escoger el dispositivo que nos interesa. Al seleccionar uno y hacer clic en Conectar se establecer\u00e1 una conexi\u00f3n con el dispositivo correspondiente. Si la conexi\u00f3n tiene \u00e9xito, el \u00edcono USB cambiar\u00e1 a uno con un fondo circular verde, como vemos en la imagen siguiente.</p> <p> <p> Conectado</p> <p></p> <p>Es importante prestar atenci\u00f3n al estado de este icono. MicroBlocks ejecuta muchos procesos internos automatizados y la actualizaci\u00f3n y sincronizaci\u00f3n autom\u00e1tica del c\u00f3digo del proyecto en el dispositivo conectado es uno de ellos, pero esto solo es posible cuando el \u00edcono est\u00e1 en modo verde.</p> <p>Existen diversas razones por las que la conexi\u00f3n puede interrumpirse. Cuando esto ocurre el icono dejar\u00e1 de estar verde y debemos buscar el motivo de la desconexi\u00f3n.</p>"},{"location":"guias/mblocks/#botones-de-inicioparada","title":"Botones de inicio/parada","text":"<p>MicroBlocks siempre est\u00e1 en conexi\u00f3n; se puede hacer clic en bloques o secuencias de comandos individuales para ejecutarlos sin hacer clic en el bot\u00f3n de 'Inicio'.</p> <p>La funci\u00f3n principal del bot\u00f3n 'Inicio' es simular el encendido del dispositivo iniciando todas las secuencias de comandos.</p> <p>El bot\u00f3n 'STOP' detiene la ejecuci\u00f3n del proyecto. Todas las variables son desasignadas. Todos los scripts se detienen.</p> <p>El proyecto cargado en el dispositivo estar\u00e1 en el mismo hasta nueva grabaci\u00f3n de firmware. De hecho, podemos desconectarlo, encenderlo desde una fuente externa y ejecutar el proyecto sin el editor.</p>"},{"location":"guias/mblocks/#programando","title":"Programando","text":"<p>Dado que es la parte en la que mas se trabaja, la creaci\u00f3n de programas, la vemos en su propio apartado.</p> <p>Los bloques colocados en el \u00e1rea de trabajo los podemos mover a voluntad con el rat\u00f3n, as\u00ed como con los men\u00fas contextuales que aparecen al pulsar el bot\u00f3n derecho. Existen una serie de atajos asociados a las teclas Ctrl y Shift que se ir\u00e1n viendo.</p>"},{"location":"guias/mblocks/#arrastrar-y-soltar","title":"Arrastrar y soltar","text":"<p>El movimiento de arrastrar y soltar es el habitual de entornos de programaci\u00f3n por bloques y adem\u00e1s resulta muy intuitivo. Lo nuevo en Microblocks es que mientras se arrastra aparece una sombra paralela que pretende crear un efecto 3D de que el bloque en movimiento va flotando sobre el \u00e1rea de trabajo, incluso por encima del resto de bloques.</p> <p> <p> Sombra paralela</p> <p></p>"},{"location":"guias/mblocks/#acoplar-bloques","title":"Acoplar bloques","text":"<p>Cuando nos acercamos con un bloque o un conjunto de bloques a otro u otros bloques, aparecer\u00e1 una l\u00ednea blanca blanca horizontal que designa un punto de acople.</p> <p> <p> L\u00ednea blanca mostrando punto de acople</p> <p></p> <p>Si soltamos el bot\u00f3n del rat\u00f3n cuando se ve esa l\u00ednea blanca el bloque o bloques se acoplar\u00e1n a los del otro lado de la l\u00ednea.</p>"},{"location":"guias/mblocks/#menu-contextual-de-bloques","title":"Men\u00fa contextual de bloques","text":"<p>Si situamos el cursor sobre un bloque que est\u00e1 en un grupo de bloques y hacemos clic con el bot\u00f3n secundario o derecho, nos aparece un men\u00fa contextual.</p> <p> <p> Men\u00fa contextual en bloques</p> <p></p> <p>Este men\u00fa contextual ofrece mas opciones si hemos seleccionado 'Mostrar bloques avanzados'.</p> <p> <p> Men\u00fa contextual en bloques avanzados</p> <p></p> <ul> <li>Copiar en el portapapeles. Es una operaci\u00f3n que crea una copia de los conjuntos de bloques seleccionados en el portapapeles. Estos se pueden pegar dentro del mismo proyecto o en un proyecto diferente. Tambi\u00e9n es posible copiar/pegar entre el editor online y el local.</li> <li>Copiar al Portapapeles como URL. Esta caracter\u00edstica se utiliza principalmente para incorporar programas MicroBlocks en p\u00e1ginas web, ya que el formato est\u00e1 codificado como URL.</li> </ul>"},{"location":"guias/mblocks/#menu-contextual-de-area-de-trabajo","title":"Men\u00fa contextual de \u00e1rea de trabajo","text":"<p>Es el men\u00fa contextual que aparece cuando hacemos un clic derecho sobre cualquier zona vac\u00eda del \u00e1rea de trabajo.</p> <p> <p> Men\u00fa contextual en \u00e1rea de trabajo</p> <p></p> <ul> <li>tama\u00f1o de bloques. Cuando se selecciona nos muestra una lista con porcentajes para escoger est\u00e1ndo tildado el valor actual.</li> <li>deshaz el \u00faltimo movimiento. Invierte el \u00faltimo movimiento de bloque completado.</li> <li>limpia. Organiza los conjuntos y los bloques sueltos en la pantalla en una disposici\u00f3n de arriba hacia abajo y de izquierda a derecha desde el lado izquierdo del \u00e1rea de trabajo. Los bloques se organizan en m\u00faltiples columnas determinadas por el ancho del \u00e1rea IDE. \u00a1Esta operaci\u00f3n no se puede deshacer!</li> <li>copia todos los programas al portapapeles. Es la pareja de copiar al portapapeles. Mientras que el primero solamente copia el bloque o el programa, este copia todos los programas del proyecto.</li> <li>copia todos los programas al portapapeles como URL. Es lo mismo que el visto anteriormente.</li> <li>guarda una imagen de todos los programas visibles. Es la versi\u00f3n complementaria de la vista en el men\u00fa contextual de bloques.</li> <li>fija la escala de la imagen a exportar. Al seleccionarla nos muestra una lista con porcentajes para escoger est\u00e1ndo tildado el valor actual.</li> </ul>"},{"location":"guias/mblocks/#crear-un-programa","title":"Crear un programa","text":"<p>Por defecto, al iniciar Microblocks aunque se haga con la micro:bit conectada, no tendremos disponibles los bloques de manejo de la pantalla de 5x5 LEDs. Estos bloques se encuentran en la libreria 'Pantalla LED' que debemos a\u00f1adir a nuestro programa. Desde 'Control debemos situar los bloques 'al empezar' y 'por siempre'.</p> <p>Repetimos el 'Primer proyecto' en el que vamos a utilizar, adem\u00e1s de los dos nombrados, el 'limpia pantalla' y 'muestra car\u00e1cter'. En la animaci\u00f3n siguiente vemos el proceso y la simulaci\u00f3n.</p> <p> <p> Primer proyecto</p> <p></p> <p>Podemos observar que tras unos instantes el programa comienza a ejecutarse en la micro:bit conectada. En el caso de Microblocks el bloque usado solamente permite un car\u00e1cter y no crea la animaci\u00f3n si ponemos mas de uno. Para hacer esto tenemos disponible otro bloque.</p> <p>Ya tenemos creado el programa y comprobado que funciona, es hora de salvarlo en el ordenador. Esto lo haremos asi principalmente para tener disponibles todos los programas y poder enlazarlos donde convenga en estas notas. En la animaci\u00f3n siguiente vemos el proceso de descarga del archivo.</p> <p> <p> Descarga del archivo Primer-proyecto.ubp</p> <p></p> <p>El Primer proyecto lo podemos descargar desde este enlace.</p> <p>Durante el proceso de cambios en el programa podemos comprobar que el conjunto de bloques esta rodeado de una l\u00ednea verde que indica que el programa se est\u00e1 ejecutando en la micro:bit. Lo apropiado cuando vamos a realizar cambios es detener la ejecuci\u00f3n, hacer los cambios y volver a poner la ejecuci\u00f3n en marcha.</p> <p> <p> Realizando cambios</p> <p></p> <p>En la animaci\u00f3n vemos junto a los botones de inicio/parada el icono indicador de progreso de la sincronizaci\u00f3n entre el IDE y la placa.</p>"},{"location":"guias/mblocks/#enlaces-utiles","title":"Enlaces \u00fatiles","text":"<ul> <li> <p>En la web de Francisco Soldado denominada 'ardutaller' nos vamos a encontrar con una entrada MicroBlocks \u2192&gt; micro:bit donde aparece un video con detalles adicionales sobre el trabajo con esta pareja de software/hardware. En ese mismo enlace tenemos disponibles varias actividades totalmente resueltas tanto en catal\u00e1n como espa\u00f1ol.</p> </li> <li> <p>Este es el video en Youtube integrado en la web titulado Introducion al Software Microblocks. Conexi\u00f3n a Microbit</p> </li> </ul>"},{"location":"guias/mkcode/","title":"Microsoft MakeCode","text":"<p>El editor MakeCode de Microsoft es una buena forma de comenzar a programar la BBC micro:bit seg\u00fan mi criterio. Se utiliza un sistema de bloques codificados por colores que resultan f\u00e1ciles de usar y lo suficientemente potentes como para acceder a todas las funciones de la placa. Tambi\u00e9n se puede cambiar el editor a JavaScript para ver el c\u00f3digo equivalente a los bloques.</p> <p>Se puede encontrar m\u00e1s informaci\u00f3n sobre c\u00f3mo usar el editor MakeCode en las Preguntas m\u00e1s frecuentes de MakeCode.</p> <p>Lo que vamos a mostrar aqu\u00ed es una referencia de MakeCode a trav\u00e9s del editor que podemos encontrar en:</p> <p> <p> Abrir el editor online MakeCode</p> <p></p> <p>Existen versiones descargables de MakeCode, pero no para Linux.</p>"},{"location":"guias/mkcode/#primeros-pasos","title":"Primeros pasos","text":"<p>El aspecto que se nos va a mostrar al entrar en el enlace anterior es el que vemos en la imagen siguiente, que se corresponde con la parte superior de la web. Es posible la primera vez se en ingl\u00e9s pero lo podemos cambiar haciendo clic en la rueda dentada y escogiendo el idioma entrando en la primera opci\u00f3n que se muestra.</p> <p> <p> Pantalla inicial de MakeCode</p> <p></p> <p>La ventana requiere pocas explicaciones y lo primero que vamos a hacer en crear un nuevo proyecto haciendo clic en el bloque de 'Nuevo proyecto'. Para crear proyectos en la nube tendremos que loguearnos mediante una cuenta v\u00e1lida. En la animaci\u00f3n siguiente vemos como crear nuestro primer proyecto.</p> <p> <p> Primer programa en MakeCode</p> <p></p> <p>Al principio nos pide un nombre para el programa y nos ofrece la posibilidad de escoger como queremos trabajar en cuanto a c\u00f3digo se refiere. Posteriormente lanza un peque\u00f1o tutorial, que aunque est\u00e1 en ingl\u00e9s, nos explica muy claramente como trabajar con el programa.</p> <p>En la animaci\u00f3n siguiente se recorren las opciones principales que est\u00e1n disponibles cuando estamos editando un proyecto.</p> <p> <p> Ventana de edici\u00f3n de proyecto en MakeCode</p> <p></p>"},{"location":"guias/mkcode/#descripcion-de-la-ventana-de-proyecto","title":"Descripci\u00f3n de la ventana de proyecto","text":"<ul> <li>En la parte superior izquierda de la pantalla es donde est\u00e1 situado el simulador que se muestra con una imagen de una micro:bit. Se trata de una secci\u00f3n muy importante porque nos permite trabajar con la mayor parte de los programas sin necesidad de tener una placa f\u00edsica conectada, adem\u00e1s resultar \u00fatil para depurar el c\u00f3digo.</li> <li>A la derecha del simulador se sit\u00faa una columna con los bloques de programaci\u00f3n organizados por categorias. Cuando hacemos clic en una categoria se despliegan, a la derecha, los bloques mas utilizados de esa categoria. Muchas veces, debajo del nombre correspondiente a esa categoria aparece un letrero ...mas, que si se pulsa muestra el resto de bloques de la categoria. Para llevar un bloque al \u00e1rea de programaci\u00f3n basta con hacer clic sobre el mismo y arrastrarlo a la misma. En la parte superior de esta columna hay un buscador por si no recordamos muy bien donde est\u00e1 el bloque que buscamos.</li> <li>A la derecha de los bloques de programaci\u00f3n est\u00e1 la zona de programaci\u00f3n, que es donde se arrastran los bloques para crear el programa.</li> <li>Tanto en la parte superior como inferior de la pantalla tenemos enlaces a funcionalidades del programa que quedan resumidas en la imagen siguiente.</li> </ul> <p> <p> Barras de herramientas de MakeCode</p> <p></p>"},{"location":"guias/mkcode/#crear-un-programa","title":"Crear un programa","text":"<p>Por defecto, al crear un proyecto, MakeCode sit\u00faa dos bloques de eventos en el a\u0155ea de programa, 'al iniciar' y 'para siempre'. Otros bloques que permiten iniciar el programa los podemos encontrar en 'Entrada'. Esta ser\u00e1 la primera tarea a realizar en nuestro programa, decidir que evento es el que inicia el c\u00f3digo.</p> <p>El programa lo vamos creando arrastrando bloques al \u00e1rea de programaci\u00f3n y podemos ir probando el funcionamiento en el simulador. Las opciones que permiten interactuar con el simulador son dependientes de los bloques introducidos.</p> <p>Vamos a hacer algo en este 'Primer proyecto' que es el nombre que le dimos al primer programa. Simplemente vamos a utilizar dos bloques, uno va a ser 'Borrar la pantalla' y el otro 'Mostrar n\u00famero', ambos en la secci\u00f3n 'Entrada'. El primero lo vamos a poner en el bloque 'al iniciar' de manera que cada vez que se inicia la micro:bit se apaguen todos los LEDs y el segundo lo pondremos en 'para siempre' y sin modificar nada vemos como el n\u00famero 0 se muestra mientras est\u00e1 alimentada la micro:bit. En la animaci\u00f3n siguiente vemos el proceso y la simulaci\u00f3n.</p> <p> <p> Primer proyecto</p> <p></p> <p>Podemos hacer pruebas cambiando el n\u00famero e incluso entrando n\u00fameros de varias cifras para ver lo que ocurre.</p>"},{"location":"guias/mkcode/#grabar-codigo-en-la-microbit","title":"Grabar c\u00f3digo en la micro:bit","text":"<p>Aunque es posible utilizar el bot\u00f3n 'Descargar' para grabar directamente el programa en la memoria flash, el proceso que nosotros vamos a seguir siempre va a ser descargar el .hex y arrastrarlo a la unidad MICROBIT montada. Esto lo haremos asi principalmente para tener disponibles todos los programas y poder enlazarlos donde convenga en estas notas. En la animaci\u00f3n siguiente vemos el proceso de descarga del archivo.</p> <p> <p> Descarga del archivo Primer-proyecto.hex</p> <p></p> <p>El Primer proyecto lo podemos descargar desde este enlace.</p> <p>Una vez descargado el .hex y conectada la micro:bit a un puerto USB procedemos a grabar el programa en la micro:bit para comprobar que funciona exactamente igual que en la simulaci\u00f3n. El proceso lo vemos en la animaci\u00f3n siguiente.</p> <p> <p> Grabar en la micro:bit el archivo Primer-proyecto.hex</p> <p></p> <p>Durante el proceso de grabaci\u00f3n podemos comprobar el parpadeo del LED amarillo de la cara posterior y como se desmonta y monta la unidad MICROBIT reseteandose la placa.</p>"},{"location":"guias/outofthebox/","title":"Experiencia inmediata","text":"<p>Cuando abrimos y conectamos una micro:bit nueva, se ejecuta un programa de demostraci\u00f3n grabado en f\u00e1brica. Esto es lo que se conoce como \"Out of box experience\" que se traduce como \"experiencia inmediata\" y que nos permite comenzar a ver y disfrutar funcionalidades de la placa sin hacer nada mas que conectarla. Si queremos restablecer de f\u00e1brica la micro:bit podemos descargarnos el archivo .hex listo para usar.</p> <p>El programa es v\u00e1lido para todas las versiones de micro:bit aunque, l\u00f3gicamente, si no disponemos de las funcionalidades que nos da la V2 no podremos disfrutarlas.</p> <p>Una vez descargado el programa lo grabamos en nuestra micro:bit y veremos como la pantalla LED comienza a hacer cosas, nos saluda y a partir de aqu\u00ed podemos ir desbloqueando varios juegos siguiendo las instrucciones en pantalla y lo que vamos a ver aqu\u00ed.</p> <p>Una primera cosa que podemos hacer con la V2 es \"dormir a la micro:bit\" manteniendo presionado el bot\u00f3n de reset de la parte posterior hasta que se apague el LED de encendido. Para \"despertarla\" presionamos de nuevo reset.</p> <ul> <li>Presionar lo botones. Median te una flecha nos indica el bot\u00f3n que debemos pulsar para avanzar. Los botones son las entradas m\u00e1s b\u00e1sicas de que dispone micro:bit</li> <li>Ag\u00edtala (Shake it). Cuanto mas agitemos la micro:bit mas LEDs se enceder\u00e1n. Esta funcionalidad est\u00e1 programada con el sensor de movimiento que integra la placa y que se conoce como aceler\u00f3metro porque mide fuerzas. Puede medir la fuerza de sacudida o en que direcci\u00f3n se realiza esta.</li> <li>Tilt: chase the dot. Se trata de atrapar el punto intermitente inclinando la micro:bit.</li> <li>Aplaude (Clap). La micro:bit V2 dispone de micr\u00f3fono y escucha el sonido.</li> <li>Huevo de pascua. A veces se denominan as\u00ed los juegos secretos. Cuando veamos en pantalla un coraz\u00f3n debemos pulsar simultaneamente los botones A y B y se desbloquer\u00e1 el juego de la serpiente.</li> </ul> <p>Podemos reiniciar la microbit en cualquier momento para iniciar de nuevo la demostraci\u00f3n.</p> <p>El c\u00f3digo que descargamos est\u00e1 escrito en C++ por lo que no se cargar\u00e1 en los editores de MakeCode o Python. Ahora bien, se puede  crear un programa propio para esta 'experiencia lista para usar' tanto en MakeCode como en Python.</p> <p>Tanto para enviar a la micro:bit este programa como otro archivo hexadecimal podemos utilizar la herramienta online micro:bit WebUSB hex file flashing tool o micro:bit WebUSB herramienta de flasheo de archivos hexadecimales.</p> <p>En la animaci\u00f3n siguiente vemos esta herramienta en funcionamiento.</p> <p> <p> Herramienta de flasheo</p> <p></p> <p>En la imagen vemos la ventana de la aplicaci\u00f3n traducida.</p> <p> <p> Herramienta de flasheo traducida</p> <p></p>"},{"location":"guias/pyt/","title":"BBC micro:bit con MicroPython","text":"<p>Practicamente todas las explicaciones sobre este tema van a estar basadas en BBC micro:bit MicroPython documentation que desafortunadamente no est\u00e1 es espa\u00f1ol.</p> <p>Uno de los lenguajes que entiende la micro:bit es el Python y la versi\u00f3n que se ejecuta en BBC micro:bit se llama MicroPython.</p> <p>Aunque en principio toda la informaci\u00f3n se va a referir a la versi\u00f3n V2 de micro:bit casi todo ser\u00e1 v\u00e1lido para versiones anteriores, excepto claro lo no implementado en estas.</p> <p>Fundamentalmente vamos a utilizar, para crear los programas, el editor de MicroPython para micro:bit que es muy similar MakeCode. Tambi\u00e9n se puede trabajar con el edit Mu.</p> <p>Python en BBC micro:bit est\u00e1 pensado para que estudiantes de 11 a 14 a\u00f1os (o edades superiores), aprendan fundamentos de la programaci\u00f3n a trav\u00e9s de la codificaci\u00f3n basada en texto.</p> <p> <p> Editor de MicroPython</p> <p></p> <p>Conectamos la micro:bit al ordenador mediante un cable USB.</p> <p>Escribimos el script (programa) en la ventana del editor y hacemos clic en el bot\u00f3n \"Enviar a micro:bit\" o \"Guardar\" para despu\u00e9s transferirlo al micro:bit.</p>"},{"location":"guias/pyt/#partes-del-editor-de-python-microbit","title":"Partes del editor de Python micro:bit","text":"<p>En la gu\u00eda de usuario User guide tenemos la descripci\u00f3n que vamos a resumir aqu\u00ed de las partes que componen el editor.</p> <p> <p> Apartados del editor de MicroPython</p> <p></p>"},{"location":"guias/pyt/#1-referencia","title":"1. Referencia","text":"<p>La secci\u00f3n facilita descubrir lo que Python y micro:bit pueden hacer, como explorar bloques en MakeCode o Scratch.</p> <p>Tamibi\u00e9n sirve para ver f\u00e1cilmente el potencial del hardware que incorpora la micro:bit y que el software de escritura en Python aumenta la creatividad de los alumnos.</p>"},{"location":"guias/pyt/#2-fragmentos-de-codigo","title":"2. Fragmentos de c\u00f3digo","text":"<p>Son fragmentos de c\u00f3digo listos para arrastrar y soltar en el \u00e1rea de programa. Estos fragmentos son totalmente funcionales, ahorran tiempo y ayudan a superar barreras de falta de habilidad con el teclado y recordar de forma precisa la sintaxis.</p> <p> <p> Arrastrar y soltar un fragmento de c\u00f3digo</p> <p></p> <p>Podemos observar como al arrastrar al \u00e1rea de c\u00f3digo la identation (sangria) se realiza de forma autom\u00e1tica para respetar la sintaxis de Python.</p>"},{"location":"guias/pyt/#3-resaltado-de-la-estructura-del-codigo","title":"3. Resaltado de la estructura del c\u00f3digo","text":"<p>Los distintos colores y la l\u00edneas de sangria que se muestran en los programas Python ayudan en las fases de dise\u00f1o, planificaci\u00f3n y prueba de un proyecto. Es f\u00e1cil seguir y entender el flujo de un programa si se mantiene todo en su lugar.</p> <p>En la animaci\u00f3n siguiente se provocan diversos errores de manera intencionada y se muestra la marca del error y la informaci\u00f3n que nos ofrece.</p> <p> <p> Resaltado de la estructura del c\u00f3digo</p> <p></p>"},{"location":"guias/pyt/#4-resaltado-de-errores","title":"4. Resaltado de errores","text":"<p>Los errores forman parte normal de la codificaci\u00f3n. Los s\u00edmbolos circulares junto al n\u00famero de l\u00ednea ayudan a identificar errores y corregirlos antes de enviar el c\u00f3digo a la micro:bit. Se puede pasar el cursor sobre el c\u00edrculo en el margen para que se muestre una explicaci\u00f3n del error. Repetimos aqu\u00ed la animaci\u00f3n previa donde hemos visto esto.</p> <p> <p> Resaltado de errores</p> <p></p>"},{"location":"guias/pyt/#5-autocompletar","title":"5. Autocompletar","text":"<p>El miedo a una pantalla en blanco y no saber qu\u00e9 escribir son dos de las mayores barreras para comenzar la codificaci\u00f3n basada en texto.</p> <p>Para ayudar con esto, a medida que escribe c\u00f3digo, el editor nos hace sugerencias que permiten elegir haciendo clic o presionando la tecla Intro. Esto ahorra tiempo, evita errores tipogr\u00e1ficos y evita tener que recordar de forma precisa una determinada sintaxis.</p> <p>Tambi\u00e9n es otra forma de descubrir qu\u00e9 pueden hacer Python y micro:bit, por ejemplo, al ver las opciones disponibles para mostrar im\u00e1genes ya definidas. Adem\u00e1s, si nos movemos con las flechas del teclado, por las opciones nos ir\u00e1n apareciendo a la derecha las descripciones de cada una de ellas.</p> <p> <p> Autocompletar</p> <p></p>"},{"location":"guias/pyt/#6-simulador","title":"6. Simulador","text":"<p>Permite probar el c\u00f3digo antes de grabarlo en la micro:bit real. Esto ayuda a desarrollar, probar, depurar y evaluar el c\u00f3digo y permite crear proyectos sin disponer fisicamente de la placa.</p> <p> <p> Simulador</p> <p></p>"},{"location":"guias/pyt/#7-ideas-y-api","title":"7. Ideas y API","text":"<p>En la pesta\u00f1a 'Ideas' hay programas completos listos para usar que se pueden modificar para crear los nuestros propios.</p> <p>El men\u00fa API (abreviatura de \"Application Programming Interfaces\" o \"interfaz de programaci\u00f3n de aplicaciones\") nos proporciona una descripci\u00f3n general m\u00e1s detallada de los comandos de MicroPython que se pueden usar con micro:bit. Esto puede ser \u00fatil cuando deseamos entender mejor lo que estamos haciendo en un trozo de c\u00f3digo en particular y qu\u00e9 opciones o argumentos se pueden usar con una funci\u00f3n.</p> <p> <p> Ideas y API</p> <p></p> <p>En la imagen siguiente tenemos un resumen de estos apartados.</p> <p> <p> Partes del editor explicadas en un gr\u00e1fico</p> <p></p>"},{"location":"guias/pyt/#uso-del-simulador","title":"Uso del simulador","text":"<p>La micro:bit que hay en la barra lateral de la derecha es un simulador. Si hacemos clic en reproducir podemos probar nuestro c\u00f3digo. Si el c\u00f3digo utiliza funciones como el aceler\u00f3metro, el sensor de temperatura, el sensor de luz (o cualquier otra funci\u00f3n de micro:bit), se pueden simular las condiciones necesarias para probar la micro:bit con los controles encontramos debajo. Tambi\u00e9n podemos usar la consola serie simulada para interactuar con la micro:bit simulada.</p> <p>En el video Simulator: micro:bit Python Editor enlazado de la documentaci\u00f3n vemos como se usa el simulador.</p>"},{"location":"guias/pyt/#flasheando-la-microbit","title":"Flasheando la micro:bit","text":"<p>Una vez comprobado el funcionamiento del programa tenemos todo listo para probarlo en la micro:bit real simplemente escogiendo 'Enviar a micro:bit'.</p> <p>El video Direct flashing from Python to micro:bit enlazado de la documentaci\u00f3n muestra los siguientes pasos si tenemos un navegador compatible con WebUSB.</p> <p>Si el navegador no soporta webUSB o no conseguimos una configuraci\u00f3n adecuada, como es mi caso utilizando Chomium tenemos que utilizar un m\u00e9todo alternativo para enviar el programa a la micro:bit.</p> <p> <p> Flasheando la micro:bit</p> <p></p>"},{"location":"guias/pyt/#abriendo-un-programa","title":"Abriendo un programa","text":"<p>Para abrir un programa, ya sea porque lo hemos guardado anteriormente o porque es de un tercero, hacemos clic en el bot\u00f3n 'Abrir'. En la ventana de di\u00e1logo que se amuestra seleccionamos el archivo '.hex' o '.py' que queremos abrir y luego hacemos clic en abrir. Alternativamente, podemos arrastrar y soltar un archivo '.hex' o un script '.py' en el editor.</p> <p> <p> Abriendo un programa</p> <p></p>"},{"location":"guias/pyt/#proyectos-configuracion-y-ayuda","title":"Proyectos, configuraci\u00f3n y ayuda","text":"<p>Las tres pesta\u00f1as de la parte inferior izquierda nos dan acceso a estas funcionalidades.</p> <ul> <li>Proyecto. La secci\u00f3n de proyectos, que se encuentra en el men\u00fa de la izquierda, es particularmente \u00fatil si necesitamos agregar archivos de Python adicionales al proyecto. Esto puede ser, por ejemplo, para agregar un m\u00f3dulo para un accesorio o para agregar un c\u00f3digo proporcionado por un tercero.</li> </ul> <p>Al hacer clic en el bot\u00f3n se enumeran todos los archivos .py del proyecto. Originalmente, solo habr\u00e1 un archivo con el nombre main.py que incluye el c\u00f3digo inicial que hemos tecleado en la parte central del editor.</p> <p>Si necesitamos un segundo archivo en el proyecto, podemos elegir 'Crear archivo' y ponerle un nombre, por ejemplo, lo podemos llamar 'ampliar' y se crear\u00e1 un nuevo archivo Python dentro del proyecto.</p> <p>Si por el contrario lo que queremos es abrir un archivo, procedente de un proveedor de accesorios o un tercero, hacemos clic el bot\u00f3n 'Abrir', localizamos el archivo en nuestro ordenador y lo abrimos. Se nos mostrar\u00e1 una ventana '\u00bfCambiar archivos? con una frase que empieza por \"Sustituir c\u00f3digo principal por ...\" y que finaliza con el nombre del archivo seleccionado. A la derecha de esta frase hay un icono que si lo clicamos nos va a permitir escoger entre las opciones de 'Sustituir c\u00f3digo' o 'A\u00f1adir archivo' para a\u00f1adirlo como archivo adicional. Este archivo adicional, que est\u00e1 dentro del proyecto, puede ser referenciado en main.py utilizando la funci\u00f3n 'import'.</p> <p>Si, por otro lado, queremos volver al c\u00f3digo original en alg\u00fan momento, por ejemplo porque se ha realizado un cambio en el programa existente y queremos restablecerlo, podemos usar el bot\u00f3n 'Restablecer proyecto' que est\u00e1 en la parte inferior. Pero cuidado porque esto reemplaza todo el c\u00f3digo, nos lleva de regreso al c\u00f3digo predeterminado y elimina cualquier archivo adicional a\u00f1adido.</p> <p> <p> Proyecto</p> <p></p> <p>El directorio donde se almacenan los proyectos es 'Descargas'.</p> <ul> <li>Configuraci\u00f3n. Se nos abre un men\u00fa donde podemos escoger entre 'Idioma' y 'Configuraci\u00f3n' que muestra una ventana con unas cuantas opciones de configuraci\u00f3n.</li> </ul> <p> <p> Configuraci\u00f3n</p> <p></p> <ul> <li>Ayuda. En esta pesta\u00f1a tenemos acceso a diferentes opciones como 'Ayuda y asistencia' que nos abre una web para consultas, 'Documentaci\u00f3n de MicroPython' que nos dirige a la wiki de referencia citada al principio del apartado, 'Comentarios' un sitio desde enviar nuestros propios comentarios, 'T\u00e9rminos de uso' que nos dirige a la web donde est\u00e1n definidos y 'Acerca de nosotros' que es el t\u00edpico Acerca de... que vemos en la ventana siguiente.</li> </ul> <p> <p> Acerca de nosotros</p> <p></p> <p>Es importante leer 'T\u00e9rminos de uso' donde est\u00e1 descrito todo lo que debemos tener en cuenta cuando se utiliza micro:bit y todo lo relacionado con la marca en los t\u00e9rminos indicados que adem\u00e1s debemos aceptar. Los t\u00e9rminos de uso se dan en 18 puntos.</p>"},{"location":"guias/pyt/#editando-codigo","title":"Editando c\u00f3digo","text":"<p>Para la creaci\u00f3n y edici\u00f3n de nuestros programas utilizaremos la ventana central del editor micro:bit MicroPython.</p> <p>En esta ventana nos ser\u00e1n de gran utilidad las caracter\u00edsticas de autocompletado, detecci\u00f3n de errores y la funcionalidad de los botones deshacer y rehacer que tambi\u00e9n permiten corregir errores.</p> <p> <p> Editando c\u00f3digo</p> <p></p> <p>En la imagen siguiente tenemos enmarcada con l\u00ednea verde discontinua la zona de edici\u00f3n de c\u00f3digo. Esta zona la podemos ampliar minimizando el men\u00fa de la izquierda (1), el men\u00fa de la derecha (4) o ajustando su anchura (2). Los iconos de zoom (3) permiten ampliar y reducir el tama\u00f1o del texto en la ventana y los controles deshacer/rehacer (5) tienen la funcionalidad habitual y permiten cierto nievel de edici\u00f3n.</p> <p> <p> Manejo del editor</p> <p></p>"},{"location":"guias/pyt/#primer-proyecto","title":"Primer proyecto","text":"<p>Para trabajar con Python en micro:bit necesitamos conocer la API de MicroPython que se trata en otro apartado y cuyo original podemos consultar en la webgrafia. Aqu\u00ed vamos a resumir muy brevemente el significado de las tres l\u00edneas de c\u00f3digo que compoenen el programa.</p> <p>Todo lo necesario para poder interactuar con el hardware lo tenemos en el m\u00f3dulo microbit y para facilitar su uso se recomienda iniciar todos los scripts con: <pre><code>from microbit import *\n</code></pre> La pantalla de LEDs se controla a partir del objeto display y sus m\u00e9todos, dos de los cuales usamos en el programa y que trabajan de la forma siguiente: <pre><code>display.clear() #Apaga todos los LEDs\ndisplay.show(0) #Muestra el n\u00famero entre par\u00e9ntesis\n</code></pre> Los n\u00fameros pueden tener mas de una cifra y si queremos mostrarlos como cadena de texto los encerramos entre comillas simples o dobles. L\u00f3gicamente en este caso podemos utilizar otros caracteres que no sean n\u00fameros.</p> <p>El primer proyecto lo tenemos disponible en los enlaces siguientes:</p> <ul> <li>Primer proyecto .hex</li> <li>Primer proyecto .py</li> </ul>"},{"location":"programacion/mkcode/","title":"MakeCode","text":"<p>De manera muy resumida lo que haremos en esta secci\u00f3n es:</p> <ul> <li>Describir los bloques y conceptos relacionados.</li> <li>Incluiremos esquemas si resultan necesarios.</li> </ul> <p>Se explican los bloques utilizados de los men\u00fas de bloques. Referencia a micro:bit reference The micro:bit APIs.</p>"},{"location":"programacion/mkcode/#comentarios","title":"Comentarios","text":"<p>Todo lenguaje de programaci\u00f3n contempla la posibilidad de realizar comentarios en el c\u00f3digo para que sirvan de aclaraci\u00f3n de para que sirve cada bloque en el programa, en especial en alguna parte que transcurrido un tiempo nos resulte complicada de entender.</p> <p>En MakeCode la forma de hacer comentarios es siempre sobre un bloque, as\u00ed que si Si necesitamos a\u00f1adir un comentario a un bloque desplegamos las opciones del bloque pinchando con el bot\u00f3n derecho y a\u00f1adimos un comentario pinchando en la entrada 'a\u00f1adir comentario'. Esto har\u00e1 que aparezca, en la esquina superior izquierda del bloque, un peque\u00f1o icono con forma de hoja escrita. Si pulsamos sobre este icono se despliega un peque\u00f1o editor, dimensionable y movible, donde podemos escribir nuestro comentario. En este editor hay un s\u00edmbolo de papelera que elimina el comentario actual. Esta opci\u00f3n est\u00e1 disponible tambi\u00e9n en el men\u00fa contextual, l\u00f3gicamente si se ha creado un comentario. En la animaci\u00f3n siguiente vemos el funcionamiento.</p> <p> <p> Comentarios</p> <p></p>"},{"location":"programacion/mkcode/#basico","title":"B\u00e1sico","text":"<p>En este grupo tenemos acceso a la funcionalidad b\u00e1sica de la micro:bit.</p> <ul> <li>al iniciar. Se trata del bloque de la imagen y es un bloque que se ejecuta una sola vez cuando se inicia la micro:bit. Es uno de los dos bloques que aparecen al principio cuando escogemos Restablecer o creamos un nuevo proyecto desde Mis proyectos.</li> </ul> <p> <p> Bloque 'al iniciar'</p> <p></p> <ul> <li>para siempre. Se trata del bloque de la imagen y es un bloque que se ejecuta de manera infinita. Es el otro de los dos bloques que aparecen al principio cuando escogemos Restablecer o creamos un nuevo proyecto desde Mis proyectos.</li> </ul> <p> <p> Bloque 'para siempre'</p> <p></p> <ul> <li>mostrar cadena. Muestra la cadena de texto en la pantalla caracter a caracter. En la imagen la palabra es Hello.</li> </ul> <p> <p> Bloque 'mostrar cadena'</p> <p></p> <ul> <li>mostrar icono. Dibuja el icono seleccionado en la pantalla.</li> </ul> <p> <p> Bloque 'mostrar icono'</p> <p></p> <ul> <li>borrar la pantalla. Apaga todos los LEDs.</li> </ul> <p> <p> Bloque 'borrar la pantalla'</p> <p></p> <ul> <li>pausa (ms). Detiene la ejecuci\u00f3n del programa el tiempo establecido en milisegundos.</li> </ul> <p> <p> Bloque 'pausa (ms)'</p> <p></p>"},{"location":"programacion/mkcode/#pantalla-led","title":"Pantalla LED","text":"<p>Control de la pantalla LED.</p> <ul> <li>ajustar brillo. Configura el brillo de la pantalla desde 0 (apagada) a 255 (m\u00e1ximo brillo). Los bloques de pantalla posteriores a este tendr\u00e1n el brillo establecido hasta que no se cambien el valor a otro distinto.</li> </ul> <p> <p> Bloque 'ajustar brillo'</p> <p></p> <ul> <li>graficar x,y,brillo. Enciende el LED indicado en la coordenada x,y con el brillo especificado. La coordenadas x es la horizontal y la y es la vertical. La coordenada 0,0 es la esquina superior ezquierda, la 0,4 es la derecha, la 4,0 es la inferior izquierda y la 4,4 la inferior derecha.</li> </ul> <p> <p> Bloque 'graficar x,y,brillo'</p> <p></p>"},{"location":"programacion/mkcode/#arrays-o-arreglos","title":"Arrays o arreglos","text":"<p>Se van a utilizar para agregar, eliminar y sustituir elementos en listas. En MakeCode las listas se nombran indistintamente como array, matriz o lista y tienen su propio men\u00fa de bloques que es visible cuando desplegamos 'Avanzado'. Los bloques existentes est\u00e1n clasificados en los siguientes grupos:</p> <ol> <li>Create</li> <li>Leer</li> <li>Modificar</li> <li>Operaciones</li> </ol> <p>Describiremos estos grupos de forma somera porque esta es suficiente para entender lo que hace el bloque. No obstante, algunos se describen de manera mas explicita.</p>"},{"location":"programacion/mkcode/#create","title":"Create","text":"<ul> <li>fijar 'nn' a. Le da a la variable el valor de la entrada, para valores num\u00e9ricos.</li> <li>fijar 'tt' a. Le da a la variable el valor de la entrada, para texto.</li> <li>matriz vacia. Crea una lista con los elementos que introduzcamos con el '+'.</li> </ul>"},{"location":"programacion/mkcode/#leer","title":"Leer","text":"<ul> <li>longitud del arreglo. Devuelve el n\u00famero de elementos de una lista.</li> <li>obtener el valor en 'x'. Obtiene el valor del elemento 'x'.</li> <li>eliminar el valor en 'x'. Elimina el elemento 'x' de la lista.</li> <li>obtener y eliminar el \u00faltimo valor de (<code>pop</code>). Elimina y devuelve el \u00faltimo elemento de una matriz. Se elimina el \u00faltimo elemento de la matriz, por lo que la matriz se reduce en un elemento.</li> <li>obtener y eliminar el primer valor de (<code>shift</code>). Elimina y devuelve el primer elemento de una matriz. Se elimina el primer elemento de la matriz, por lo que la matriz se reduce en un elemento.</li> <li>obtener valor aleatorio. Devuelve un valor al azar de la matriz.</li> </ul>"},{"location":"programacion/mkcode/#modificar","title":"Modificar","text":"<ul> <li>establecer el valor en 'x' a 'nn'. Estable el valor del elemento 'x' al valor indicado en 'nn'.</li> <li>a\u00f1adir valor 'nn' al final (<code>push</code>). A\u00f1ade un nuevo elemento al final de una matriz.</li> <li>eliminar el \u00faltimo valor de. Elimina el \u00faltimo elemento de la matriz y lo devuelve.</li> <li>eliminar el primer valor de. Elimina el primer elemento de la matriz y lo devuelve.</li> <li>insertar 'nn' al principio (<code>unshift</code>). A\u00f1adir un elemento al principio de una matriz y devolver la nueva longitud de la matriz.</li> <li>insertar en 'x' valor 'nn' (<code>insertAt</code>). Inserta el valor 'nn' en la posici\u00f3n espe\u00edfica indicada por 'x' aumentando la longitud del array en uno. El elemento se agrega a la matriz en la posici\u00f3n que indiquemos. Si ya hay un elemento en esa posici\u00f3n, entonces \u00e9l y todos los elementos posteriores se desplazan a la posici\u00f3n superior siguiente.</li> <li>eliminar valor en 'x' (<code>removeAt</code>). Elimina el elemento que hay en la posici\u00f3n 'x'. El tama\u00f1o de la matriz se reduce en uno. El elemento se elimina de la matriz en la posici\u00f3n que indiquemos. Todos los dem\u00e1s elementos posteriores se desplazan hacia abajo a la posici\u00f3n inferior siguiente.</li> </ul>"},{"location":"programacion/mkcode/#operaciones","title":"Operaciones","text":"<ul> <li>bloque encontrar indice de (<code>IndexOf</code>). Devuelve la posici\u00f3n o \u00edndice de la primera aparici\u00f3n de un valor en una matriz. Devuelve un n\u00famero, que es la posici\u00f3n en la matriz del elemento. El resultado es -1 si no se encuentra ninguna coincidencia.</li> <li>invertir (<code>reverse</code>). Invertir los elementos de una matriz.</li> </ul>"},{"location":"programacion/mkcode/#variables","title":"Variables","text":"<p>Cuando vamos a utilizar bucles, estos siempre llevan asociada una variable, y por eso debemos aprender a gestionar el tema de las variables en MakeCode. Las variables tienen su propio men\u00fa y es relativamente sencillo de usar. Como ya se ha dicho, una variable es un espacio en la memoria donde el programa puede almacenar valores. El sistema nos permite asignarles un nombre simb\u00f3lico como por ejemplo \u201ctemperatura\u201d, \u201cvelocidad\u201d, \u201destado\u201d,\u2026 para facilitar su uso.</p> <p>Cuando accedemos al men\u00fa 'Variables' por primera vez y si no hemos pues ning\u00fan bloque en el \u00e1rea de programa, el aspecto del men\u00fa es el siguiente:</p> <p> <p> Variables en MakeCode</p> <p></p> <p>Veamos como funciona la creaci\u00f3n de una variable, cambiarle el nombre, eliminarla y dem\u00e1s tareas que podemos hacer con ellas. En la animaci\u00f3n siguiente vemos el proceso de crear y poner nombre a una variable. Vemos que al hacer clic en el bot\u00f3n se abre una ventana de di\u00e1logo donde nos pide el nombre, que tecleamos seg\u00fan las reglas establecidas, y que al hacer clic en 'Aceptar' se nos crean tres bloques, dos para trabajar con la variable creada y uno que es la propia variable, todos ellos con el nombre que hemos puesto a esa variable.</p> <p> <p> Creaci\u00f3n de una variable en MakeCode</p> <p></p> <p>El bloque 'fijar' sirve para inicializar la variable al valor especificado, el bloque 'cambiar' es el equivalente al operador '+=' con el incremento que establezcamos en 'por' y el \u00faltimo bloque es el valor de la variable.</p> <p>Al final de la animaci\u00f3n tambi\u00e9n vemos que al hacer clic en la flechita de cualquiera de los bloques se despliega un men\u00fa en el que aparece la variable, la opci\u00f3n de crear otra nueva, renombrarla o borrar la variable que est\u00e1 seleccionada en ese momento. En la animaci\u00f3n siguiente vemos estos aspectos en funcionamiento.</p> <p> <p> Trabajo con el men\u00fa desplegable en una variable en MakeCode</p> <p></p> <p>Cuando pasamos por el men\u00fa de bloques vemos que 'fijar' y 'cambiar' no se vuelven a crear cuando creamos nuevas variables ya que est\u00e1n todas en el desplegable y lo \u00fanico que tenemos que hacer es seleccionarlas. Si se crea, en cambio, un bloque para el contenido de cada variable. Tambi\u00e9n vemos que si eliminamos una variable que est\u00e1 en uso en varios sitios se elimina, preva advertencia, de todos ellos.</p> <p>Ahora bien, la variables como tal se eliminan de la zona de programa pero no del men\u00fa 'Variables, donde siguen estando disponibles hasta que las eliminemos, tarea que solamente es posible hacer desde alguno de los bloques situado en la zona de programa.</p>"},{"location":"programacion/mkcode/#bucles","title":"Bucles","text":""},{"location":"programacion/mkcode/#bloque-for","title":"Bloque for","text":"<p>Son bloques que repiten el c\u00f3digo asociado un n\u00famero determinado de veces, Lo pueden hacer utilizando una variable como \u00edndice o estableciendo el n\u00famero exacto de veces.</p> <p>El aspecto del bloque para recorrer con una variable lo vemos en la imagen siguiente:</p> <p> <p> Bloque for en MakeCode</p> <p></p> <p>Cuando llevamos el bloque a la zona de programa se crear\u00e1 una variable index, salvo que esta ya exista. Un bloque como el siguiente crear\u00e1 un contador con la variable i desde 0 hasta 4 y mostrar\u00e1 los n\u00fameros 0 al 9 uno tras otro en la pantalla LED.</p> <p> <p> Contador de 0 a 9</p> <p></p> <p>Una variedad de este bloque la tenemos en el bloque 'repetir' para el n\u00famero de veces que indiquemos, que tiene el aspecto que vemos en la figura siguiente.</p> <p> <p> Bloque repetir nn veces</p> <p></p> <p>En el ejemplo siguiente, cuando se inicia el dispositivo, se producen tres efectos de latido de un coraz\u00f3n.</p> <p> <p> Ejemplo de uso del bloque repetir nn veces</p> <p></p> <p>Otro bloque que utiliza el bucle for es el que vemos en la imagen siguiente, un bloque pensado para repetir el c\u00f3digo para cada valor de los contenidos en una lista.</p> <p> <p> Bucle for para elementos de una lista</p> <p></p> <p>En la imagen siguiente vemos un programa que utiliza este bloque. Hemos creado una lista aleatoria de valores y el programa lo que hace es encontrar y mostrar el mayor de ellos. El funcionamiento del programa lo leemos asi: se crea una variable <code>mayor</code> para guardar el valor del elemento de la lista de mayor valor, la matriz le hemos dejado el nombre <code>lista</code> y para recorrerla se utiliza la variable <code>valor</code>. El condicional (los veremos en una actividad posterior) va comprobando si <code>valor &gt; mayor</code> y mientras sea cierto se guarda en <code>mayor</code> el <code>valor</code> leido y si no es cierto se contin\u00faa con el siguiente elemento de la lista. Una vez finalizado el condicional se mestra la cadena con la variable <code>mayor</code>.</p> <p> <p> Ejemplo de bucle for para elementos de una lista</p> <p></p>"},{"location":"programacion/mkcode/#bloque-while","title":"Bloque while","text":"<p>Se trata de un bloque que repite su bloque de c\u00f3digo mientras la condici\u00f3n sea cierta (<code>True</code>). Su aspecto lo vemos en la imagen siguiente.</p> <p> <p> Bucle while</p> <p></p> <p>El bucle while tiene una condici\u00f3n que se eval\u00faa con un valor <code>booleano</code>. La condici\u00f3n se comprueba antes de que se ejecute ning\u00fan c\u00f3digo. Lo que significa que si la condici\u00f3n es falsa la primera vez que se eval\u00faa, el c\u00f3digo dentro del bucle no se ejecuta n\u00fanca.</p> <p>Con el bloque tal cual es solamente podemos establecer la condici\u00f3n como <code>True</code> o <code>False</code>, lo que es muy poca cosa. Es evidente que podr\u00e1 tener mucha mas potencia si recurrimos a condiciones mas complejas y utilizamos los operadores. Este apartado no lo vamos a estudiar en este momento, pero si diremos que estos bloques est\u00e1n en el men\u00fa 'L\u00f3gica' y su funcionamiento es el mismo que en visto en Python -&gt; Introducci\u00f3n.</p> <p>Como ejemplo vamos a ver como dibujar una l\u00ednea diagonal en los LEDs [(0,0) - (1,1) - (2,2) - (3,3) - (4,4) y (5,5)] de la pantalla. En la imagen vemos el programa final, donde observamos que la condici\u00f3n va a ser cierta hasta que index alcance el valor 4, por lo que se va a ir encendiendo cada LED a intervalos de un segundo. Esto solamente va a ocurrir cuando se inicia el disposiivo, aunque en este ejemplo concreto esto no tiene importancia.</p> <p> <p> Programa bucle while</p> <p></p>"},{"location":"programacion/mkcode/#bloque-cada-nn-ms","title":"Bloque cada 'nn' ms","text":"<p>Repite el c\u00f3digo en segundo plano de forma contnuada en el intervalo de tiempo que se indique. Establecemos la cantidad de tiempo que el bucle espera antes de que el c\u00f3digo en su interior se ejecute de nuevo. Esto es similar a un bucle \"forever\" (por siempre), en el sentido de que se ejecuta continuamente, excepto que hay un intervalo de tiempo establecido para esperar antes de que el bucle se ejecute la pr\u00f3xima vez. El bloque es muy \u00fatil si, por ejemplo, queremos estar comprobando cada cierto tiempo si ocurre un evento, como pulsar una tecla, escuchar un sonido, etc.</p> <p>En la imagen siguiente vemos el aspecto que tiene el bloque.</p> <p> <p> Bloque cada 'nn' ms</p> <p></p>"},{"location":"programacion/mkcode/#bloques-salir-y-continuar","title":"Bloques salir y continuar","text":"<p>Son los bloques equivalentes a las sentencias <code>break</code> y <code>continue</code> en MicroPython y funcionan exactamente igual, es decir, el bloque 'salir' permite salir de un bucle de forma inmediata y el bloque 'continuar' sirve para saltarse la iteraci\u00f3n actual del bucle.</p> <p>Los bloques tienen el aspecto que vemos en la imagen.</p> <p> <p> <code>break</code> y <code>continue</code></p> <p></p>"},{"location":"programacion/mkcode/#operadores-de-comparacion-y-booleanos","title":"Operadores de comparaci\u00f3n y booleanos","text":"<p>Como sabemos un valor booleano solamente puede tomar uno de dos valores posibles: <code>True (verdadero)</code> o <code>False (falso)</code>. Estos bloques los encontramos en la entrada 'L\u00f3gica' y son:</p> <p> <p> Valores booleanos</p> <p></p> <p>Los dos bloques existen de forma separada, pero cada uno de ellos puede adoptar el valor contrario al que muestra por defecto seleccionandolo con la flechita.</p> <p>Los operadores booleanos u operadores l\u00f3gicos son AND, OR y NOT y son operadores que a partir de valores de entrada booleanos crean otro valor tambi\u00e9n booleano. Estos bloques tambi\u00e9n los encontramos en la entrada 'L\u00f3gica' y son:</p> <p> <p> Operadores booleanos</p> <p></p> <p>A continuaci\u00f3n vemos una serie de bloques con operadores que satisfacen la condici\u00f3n.</p> <p> <p> Operadores booleanos</p> <p></p> <p>Tanto los valores booleanos como los operadores se usan con instrucciones <code>if</code> o <code>while</code> para determinar qu\u00e9 c\u00f3digo se ejecutar\u00e1 a continuaci\u00f3n. Por ejemplo:</p> <p> <p> Bucle <code>while</code> con una condici\u00f3n</p> <p></p> <p>En el siguiente ejemplo se utilizan operadores booleanos en el bucle.</p> <p> <p> Bucle <code>while</code> con una condici\u00f3n y operadores booleanos</p> <p></p>"},{"location":"programacion/mkcode/#sentencia-condicional-ifelifelse","title":"Sentencia condicional <code>if...elif...else</code>","text":"<ul> <li><code>if</code>. Ejecuta c\u00f3digo dependiendo de si una condici\u00f3n booleana es verdadera o falsa. El c\u00f3digo dentro del bloque <code>if</code> s\u00f3lo se ejecuta cuando el bloque <code>condici\u00f3n</code> es verdadero.</li> </ul> <p> <p> Condicional <code>if</code></p> <p></p> <p>Se pueden comparar variables con valores o variables con variables, para una condici\u00f3n verdadera o falsa.</p> <ul> <li><code>else</code>. Si necesitamos que se ejecute alg\u00fan otro c\u00f3digo cuando la condici\u00f3n del <code>if</code> no sea verdadera, lo ponemos en un \u00e1rea de bloque adicional llamada <code>else</code> (si no).</li> </ul> <p> <p> Condicional <code>if...else</code></p> <p></p> <p>Un condicional como el siguiente se podr\u00eda leer como: \"<code>si</code> tengo dinero por encima de una cantidad, <code>entonces</code> estoy feliz y <code>si no</code> estoy triste.</p> <p> <p> Condicional <code>if...else</code></p> <p></p> <p>Cambiando el valor asignado a dinero vemos el funcionamiento.</p> <p>La clausula <code>else</code> se a\u00f1ade al condicional <code>if</code> haciendo clic en el signo '+'.</p> <ul> <li><code>if...else if</code>. Condici\u00f3n <code>if</code> que si resulta falsa se evalua una nueva condici\u00f3n puesta en <code>elif</code>. Otra acci\u00f3n condicional es a\u00f1adir un <code>if</code> a un <code>else</code> para obtener un <code>else if</code>. Funciona as\u00ed</li> </ul> <p> <p> Condicional <code>if...else if</code></p> <p></p> <p>Hacemos clic en el s\u00edmbolo m\u00e1s '+' para a\u00f1adir secciones <code>else</code> o <code>else if</code> al bloque <code>if</code> actual.</p>"},{"location":"programacion/mkcode/#texto","title":"Texto","text":"<p>Si expandimos el men\u00fa 'Avanzado' nos encontraremos con una entrada 'Texto' que vamos a describir en esta actividad.</p> <ul> <li> Una letra, palabra o l\u00ednea de texto que puede contener letras, n\u00fameros y caracteres.</li> <li> Devuelve el n\u00famero de caracteres de la cadena de texto.</li> <li> A\u00f1ade una cadena de texto a otra para crear una cadena mas larga. Se pueden a\u00f1adir mas cadenas.</li> <li> Convierte un texto que s\u00f3lo tiene caracteres num\u00e9ricos en un valor num\u00e9rico de coma flotante. Se puede convertir una cadena de texto con caracteres num\u00e9ricos en un valor real de coma flotante. El texto debe tener s\u00f3lo caracteres num\u00e9ricos. Aunque tambi\u00e9n puede incluir los s\u00edmbolos '-' y '.'. Si el texto tiene otros caracteres, como \"-5.8g5u7\", s\u00f3lo se devuelve -5.8 ya que es el mejor intento de conversi\u00f3n a un n\u00famero. Por lo tanto, hay que no mezclar caracteres num\u00e9ricos con letras u otros s\u00edmbolos.</li> </ul> <p>Potencias de 10. Si la cadena de texto tiene la letra 'e' despu\u00e9s de los caracteres num\u00e9ricos y luego algunos caracteres num\u00e9ricos m\u00e1s como \"2e4\", entonces los caracteres num\u00e9ricos despu\u00e9s de la 'e' son un exponente de 10. Esto significa que una cadena con \"7.5e2\" se convierte en el valor de 750 cuando se convierte a un n\u00famero de coma flotante. Esto se debe a que el 2 despu\u00e9s de la 'e' indica 10\u00b2, lo que equivale a <code>10 * 10 =  100</code>. El valor resultante es entonces 7.5 * 100 que es igual a 750. En el siguiente ejemplo se toman los primeros d\u00edgitos de PI de la frase \"pi vale 3.141592\" y los convierte en un n\u00famero.</p> <p> <p> Extraer PI de una cadena</p> <p></p> <p>Descargar el programa</p> <ul> <li> Divide una cadena en cadenas m\u00e1s peque\u00f1as utilizando un caracter (una cadena) de separaci\u00f3n para dividir la cadena m\u00e1s grande.</li> <li> Determina si una cadena contiene los caracteres de una cadena especificada.</li> <li> Obtiene la posici\u00f3n (\u00edndice) de la primera aparici\u00f3n de un valor especificado en una cadena.</li> <li> Determina si una cadena de texto contiene caracteres o no. TODO</li> <li> Toma una parte de la cadena \"this\" para hacer una cadena m\u00e1s peque\u00f1a (subcadena). * Si una cadena tiene una parte que est\u00e1 copiada de otra cadena, se llama subcadena. Se puede crear una nueva cadena que s\u00f3lo contenga la palabra \"aqu\u00ed\" a partir de una cadena mayor que diga \"\u00a1Hola, estamos aqu\u00ed!\". Para ello, la subcadena se copia desde la posici\u00f3n de car\u00e1cter 15 en la primera cadena y se copian 4 caracteres. Se hace as\u00ed: . En el ejemplo se copian los sustantivos de la frase en dos cadenas m\u00e1s peque\u00f1as.</li> </ul> <p> <p> Extraer de cadena a subcadenas</p> <p></p> <p>Descargar el programa</p> <ul> <li> Se comparan dos cadenas de texto en funci\u00f3n de los caracteres que aparecen en primer lugar. Dos cadenas se comparan en funci\u00f3n del orden de sus caracteres. Si la cadena \"A\" vale \"111\" ser\u00e1 menor que una cadena con \"512\". Una cadena con \"Everything (Todo)\" es menor que \"Nothing (Nada)\" porque la 'N' viene despu\u00e9s de la 'E' en el alfabeto. La cadena \"abcdefg\" es mayor que \"abcdefa\". Son casi iguales, pero la \u00faltima letra de la segunda cadena es menor que la \u00faltima letra de la primera. Esto hace que toda la segunda cadena se compare como menor. En bloques, la comparaci\u00f3n de estas cadenas tiene el siguiente aspecto:</li> </ul> <p> <p> Comparar cadenas</p> <p></p> <ul> <li> Obtiene un car\u00e1cter (letra, n\u00famero o s\u00edmbolo) de un lugar de la cadena de texto. Podemos averiguar qu\u00e9 car\u00e1cter se encuentra en cualquier lugar de un texto. Puedes tener un texto que diga \"Hello there!\". El car\u00e1cter en la posici\u00f3n 6 es 't'. La palabra \"Hello\" m\u00e1s el espacio tienen las posiciones 0 - 5, as\u00ed que, 't' est\u00e1 en la posici\u00f3n 6. Para obtener el car\u00e1cter en esta posici\u00f3n, la letra 't', se podr\u00eda usar un bloque como este:</li> </ul> <p> <p> Extraer caracter de una cadena</p> <p></p> <ul> <li> Convierte el valor de cualquier tipo de dato a una cadena de texto. El siguiente ejemplo convierte un valor booleano y un valor num\u00e9rico en cadenas y las une en una cadena o frase.</li> </ul> <p> <p> Convertir valores booleanos y num\u00e9ricos en cadena</p> <p></p> <p>Descargar el programa</p> <ul> <li> Hacer que una cadena de un caracter sea representada a partir del c\u00f3digo num\u00e9rico que le asignemos. Al igual que el c\u00f3digo ASCII es un juego de caracteres que asigna un valor a cada uno de ellos, nosotros podemos crear nuestro propio c\u00f3digo asign\u00e1ndole un c\u00f3digo con este bloque. Por ejemplo, hacer que la letra B sea: </li> </ul>"},{"location":"programacion/mkcode/#bloques-de-entrada-para-los-botones","title":"Bloques de 'Entrada' para los botones","text":"<p>Cuando presionamos los botones A y/o B ocurre un evento (se ha presionado un bot\u00f3n). Este tipo de acci\u00f3n se considera una entrada a la microbit y tenemos bloques para manejarlo.</p> <ul> <li>al presionar el bot\u00f3n</li> </ul> <p>Presionar un bot\u00f3n inicia un manejador de eventos, que es una parte del programa que se ejecutar\u00e1 cuando ocurra algo, como por ejemplo,  cuando se pulsa un bot\u00f3n. Este manejador funciona cuando se pulsa el bot\u00f3n A o B, o A y B al mismo tiempo.Cuando estemos utilizando esta funci\u00f3n en un navegador, pulsaremos los botones de la pantalla en lugar de los del micro:bit.</p> <ul> <li>Para el bot\u00f3n A o B: Este manejador de evento funciona cuando el bot\u00f3n se pulsa y se suelta en menos de un segundo.</li> <li>Para A y B juntos: Este manejador funciona cuando A y B son presionados simultanemente. Disponemos de un segundo y medio desde que pulsamos el primer bot\u00f3n hasta que pulsamos el seg\u00fando para que se consideren ambos pulsados a la vez.</li> </ul> <p> <p> Bloque 'Al presionar el bot\u00f3n...'</p> <p></p> <p>En el siguiente ejemplo se cuenta cu\u00e1ntas veces se pulsa el bot\u00f3n A. Cada vez que se pulsa el bot\u00f3n, la pantalla LED muestra la variable de recuento que cada vez ser\u00e1 mayor.</p> <p> <p></p> <p>Contar pulsaciones de A</p> <p></p> <p>Descargar el programa</p> <p>En el ejemplo siguiente se simula un dado mostrando un n\u00famero del 1 al 6 cuando pulsamos el bot\u00f3n B. En el programa se utiliza el bloque de generaci\u00f3n de n\u00famero aleatorios entre dos valores dados que podemos encontrar en el men\u00fa 'Matem\u00e1ticas'.</p> <p> <p></p> <p>Dado</p> <p></p> <p>Descargar el programa</p> <ul> <li>bot\u00f3n A o B presionado</li> </ul> <p>El bloque siguiente comprueba si se est\u00e1 pulsando un bot\u00f3n en ese momento.</p> <p> <p></p> <p>Se ha presionado el bot\u00f3n</p> <p></p> <p>Un sencillo ejemplo nos aclara como funciona el bloque.</p> <p> <p></p> <p>Bot\u00f3n A presionado</p> <p></p> <p>Descargar el programa</p> <ul> <li>al pulsar el logotipo  (solo en versiones V2)</li> </ul> <p>El logo de micro:bit V2 act\u00faa como un bot\u00f3n t\u00e1ctil, por lo que es un actuador de entrada que cuando lo pulsamos (tocamos) se ejecuta su c\u00f3digo y cuando lo soltamos (no lo tocamos) deja de hacerlo.</p> <p> <p></p> <p>Bot\u00f3n t\u00e1ctil</p> <p></p> <p>El bloque funciona solamente con micro:bit V2 y si lo usamos con una placa V1 nos generar\u00e1 el c\u00f3digo de error 927 en la pantalla.</p> <ul> <li>el logotipo est\u00e1 pulsado  (solo en versiones V2)</li> </ul> <p>Comprueba si se est\u00e1 pulsando el logotipo de micro:bit. Utilizamos el valor booleano del estado de la pulsaci\u00f3n del logo para tomar una decisi\u00f3n l\u00f3gica en el programa.</p> <p>El ejemplo muestra una u otra imagen en funci\u00f3n de si se ha pulsado el logo o no.</p> <p> <p></p> <p>Logo presionado</p> <p></p> <p>Descargar el programa</p>"},{"location":"programacion/mkcode/#pines","title":"Pines","text":"<p>MakeCode dispone de bloques para controlar la corriente en los pines tanto para se\u00f1ales anal\u00f3gicas como digitales, servos, dispositivos i2c,...</p> <ul> <li>. Lee el valor de una se\u00f1al digital (0 o 1) desde el pin de la placa micro:bit. Los pines disponibles para el bloque son:</li> </ul> <p> <p></p> <p>Pines para lectura digital</p> <p></p> <ul> <li>. Escribe el valor de una se\u00f1al digital (0 o 1) en un pin de la placa micro:bit. Los pines disponibles para escritura digital son los mismos que para lectura digital.</li> <li>. Lee una se\u00f1al anal\u00f3gica (0 a 1023) desde el pin indicado. Los pines disponibles son:</li> </ul> <p> <p></p> <p>Pines para escritura digital</p> <p></p> <ul> <li>. Escribe una se\u00f1al anal\u00f3gica (0 a 1023) en el pin indicado. Los pines disponibles son los indicados para la lectura anal\u00f3gica.</li> <li>. Configura el periodo de la modulaci\u00f3n por anchura de pulso o PWM de la salida anal\u00f3gica en microsegundos. Antes de llamar a esta funci\u00f3n debemos configurar el pin indicado como anal\u00f3gico. Tenemos los mismo pines disponibles que para la lectura y escritura.</li> <li>El bloque siguiente es un bloque de lo que se conoce como mapeo. El mapeo consiste en reasignar un valor especificado dentro de un rango a otro rango diferente. Es com si hacemos un cambio de escala de los valores. La funci\u00f3n no limita los valores de los rangos, porque los valores fuera de rango a veces est\u00e1n previstos y son \u00fatiles. Si necesitamos limitar un rango, podemos utilizar la funci\u00f3n 'restringir' de 'Matem\u00e1ticas'.</li> </ul> <p> <p></p> <p></p> <p>Por ejemplo, el programa siguiente cambia los valores anal\u00f3gicos recibidos en el pin P0 de absolutos a porcentaje.</p> <p> <p></p> <p>Mapeo de valores</p> <p></p> <ul> <li>El bloque siguiente configura el pin indicado como una entrada digital y genera un evento cuando el pin es tocado, tanto alto como bajo. Este bloque no se puede simular y requiere hardware real para probarlo.</li> </ul> <p> <p></p> <p></p> <p>A continuaci\u00f3n vemos los pines que se pueden configurar en el bloque.</p> <p> <p></p> <p>Pines para el bloque cuando el pin nn es pulsado</p> <p></p> <ul> <li>. Obtiene la duraci\u00f3n del pulso en microsegundos.</li> <li>. Devuelve la duraci\u00f3n de un pulso en microsegundos.</li> <li>. Configura el pull del pin indicado. Hay muchos pines que se pueden configurar con pull-up. Por ejemplo, podemos establecer el valor de tensi\u00f3n de un pin a 3.3V o un \"1\" l\u00f3gico.</li> <li>. Emite una se\u00f1al PWM al pin actual.</li> <li>. Establece el pin que se utiliza para un tono musical anal\u00f3gico.</li> </ul>"},{"location":"programacion/python/","title":"Python","text":"<p>De manera muy resumida lo que haremos en esta secci\u00f3n es:</p> <ul> <li>Introducir los conceptos de programaci\u00f3n para programar la micro:bit desde BBC micro:bit MicroPython.</li> <li>Tambi\u00e9n introduciremos conceptos de micro:bit Micropython API.</li> </ul>"},{"location":"programacion/python/#api-el-modulo-microbit","title":"API: El m\u00f3dulo microbit","text":"<p>Todo lo necesario para interactuar con el hardware de la micro:bit est\u00e1 en el m\u00f3dulo microbit y se recomienda su uso escribiendo al principio del programa:</p> <p> <pre><code>from microbit import *\n</code></pre> </p> <p>Las funciones disponibles directamente son:</p> <pre><code>sleep(ms) #1\nrunning_time() #2\ntemperature() #3\nscale(valor_a_convertir, from_=(min, max), to=(min, max)) #4\npanic(error_code) #5\nreset() #6\nset_volume(valor) #7 (V2)\n'''\n1 Esperar el n\u00famero de milisegundos indicado\n2 Devuelve el tiempo en ms desde la \u00faltima vez que se encendi\u00f3 la micro:bit\n3 Devuelve la temperatura en Celcius\n4 Convierte un n\u00famero de una escala de valores a otra\n5 La micro:bit entra en modo p\u00e1nico por falta de memoria y se dibuja una\ncara triste en la pantalla. El valor de error_code puede ser cualquier entero.\n6 Resetea la micro:bit\n7 Estable el volumen de salida con un *valor* entre 0 y 255\n'''\n</code></pre>"},{"location":"programacion/python/#api-display","title":"API: Display","text":"<p>Control de la matriz de 5x5 LEDs que en micro:bit se conoce como pantalla. Los m\u00e9todos de la clase son:</p> <pre><code>display.get_pixel(x, y) #1\ndisplay.set_pixel(x, y, val) #2\ndisplay.clear() #3\ndisplay.show(image, delay=0, wait=True, loop=False, clear=False) #4\ndisplay.scroll(string, delay=400) #5\n'''\n1 Obtiene el brillo [0 (apagado) a 9 (m\u00e1x))] del pixel (x,y)\n2 Establece el brillo [0 (apagado) a 9 (m\u00e1x))] del pixel (x,y)\n3 Borra (apaga) la pantalla\n4 Muestra la imagen\n5 Desplaza una cadena por la pantalla a la velocidad en ms del *delay*\n'''\n</code></pre> <p>En ambos casos de la API existen otras muchas opciones no incluidas. La funcionalidad de autocompletar nos ayudar\u00e1 para no tener que recordar la sintaxis y conocer las que no aparece aqu\u00ed. En la animaci\u00f3n siguiente vemos un ejemplo de ambos casos.</p> <p> <p> Autocompletar funciones y m\u00e9todos</p> <p></p>"},{"location":"programacion/python/#las-listas-en-python","title":"Las listas en Python","text":"<p>Se trata de un tipo de dato que permite almacenar series de datos de cualquier tipo bajo su estructura. Se suelen asociar a las matrices o arrays de otros lenguajes de programaci\u00f3n.</p> <p>En Python las listas son muy versatiles permitiendo almacenar un conjunto arbitrario de datos. Es decir, podemos guardar en ellas lo que sea.</p> <p>Una lista se crea con [] y sus elementos se separan por comas. Una gran ventaja es que pueden tener datos de diferentes tipos.</p> <pre><code>lista = [1, \"Hola\", 3.141592, [1 , 2, 3], Image.HAPPY]\n</code></pre> <p>Las de principales propiedades de las listas:</p> <ul> <li>Son ordenadas, mantienen el orden en el que han sido definidas</li> <li>Pueden ser formadas por tipos arbitrarios de datos</li> <li>Pueden ser indexadas con [i]</li> <li>Se pueden anidar, es decir, meter una lista dentro de otra</li> <li>Son mutables, ya que sus elementos pueden ser modificados</li> <li>Son din\u00e1micas, ya que se pueden a\u00f1adir o eliminar elementos</li> </ul> <p>Evidentemente queda muchas cosas que aprender sobre las listas, pero con estos conocimientos tendremos suficiente para hacer lo que pretendemos, que no es otra cosa que animar im\u00e1genes.</p>"},{"location":"programacion/python/#bucles","title":"Bucles","text":"<p>Los Bucles son un tipo de estructura de control muy \u00fatil cuando queremos repetir un bloque de c\u00f3digo varias veces. En Python existen dos tipos de bloques, el bucle for para contar la cantidad de veces que se ejecuta un bloque de c\u00f3digo, y el bucle while que realiza la acci\u00f3n hasta que la condici\u00f3n especificada no sea cierta.</p>"},{"location":"programacion/python/#while","title":"While","text":"<p>La sintaxis de while es la siguiente:</p> <pre><code>while condicion:\n    bloque de codigo\n</code></pre> <p>donde \"condicion\", que se eval\u00faa en cada iteraci\u00f3n, puede ser cualquier expresi\u00f3n realizado con operadores condicionales que devuelva como resultado un valor True o False. Mientra que \"bloque de codigo\" es el conjunto de instrucciones que se estar\u00e1n ejecutando mientras la condici\u00f3n sea verdadera (True o '1'). Es lo mismo poner <code>while true:</code> que poner <code>while 1:</code>.</p> <p>Para recorrer los bucles se utilizan variables que forman parte de la condici\u00f3n, estableciendose en esta lo que deben cumplir.</p> <p>Un ejemplo sencillo podr\u00eda ser el siguiente, controlar el riego de una planta en funci\u00f3n del valor de la humedad de la tierra en la que est\u00e1.</p> <pre><code>from microbit import *\n\nwhile (humedad() &lt; 45):\n    display.scroll(Image.SAD)\n    sleep(1000)\n\ndisplay.show(Image.HAPPY)\n</code></pre> <p>que har\u00e1 que si la humedad baja por debajo de 45 se muestre una carita triste indicando que hay que regar y si es mayor mostrar\u00e1 una carita feliz. Evidentemente hay que resolver el tema de como obtener la humedad, pero esa es una historia que veremos mas adelante.</p> <p>El bucle <code>while</code> puede tener de manera opcional un bloque <code>else</code> cuyas sentencias se ejecutan cuando se han realizado todas las iteraciones del bucle. Un ejemplo lo vemos a continuaci\u00f3n:</p> <pre><code>cuenta = 0\nwhile cuenta &lt; 5:\n    print(\"Iteraci\u00f3n del bucle\")\n    cuenta = cuenta + 1\nelse:\n    print(\"bucle finalizado\")\n</code></pre>"},{"location":"programacion/python/#for","title":"for","text":"<p>Son tambi\u00e9n bucles pero su acci\u00f3n est\u00e1 dirigida a contar el n\u00famero de veces que ocurre algo o realizar una acci\u00f3n un determinado n\u00famero de veces. Es especialmente \u00fatil para recorrer los datos de una lista, tupla o diccionario.</p> <p>La sintaxis de este tipo de bucles en Python es:</p> <pre><code>for variable in secuencia:\n    declaracion\n</code></pre> <p>Siendo \"variable\" la variable que se va a recorrer en el bucle de forma que cuando se alcance el valor establecido se sale del bucle.</p> <p>La variable puede ser una cadena, un rango de valores que se expresa con <code>range(n)</code>, siendo n el n\u00famero de valores del rango que se inicia en 0 y que pueden ser iterados con una variable. Mas ampliamente, la sintaxis de <code>range()</code> es <code>range(start, stop, step)</code> siendo <code>start</code> y <code>stop</code> opcionales.</p> <p>Veamos un primer ejemplo en el que vamos a utilizar un bucle para encender uno a uno por filas los LEDs de la primera y \u00faltima columna.</p> <pre><code>from microbit import *\nfor var in range(5): # var puede tomar 5 valores, del 0 al 4\n    display.set_pixel(0, var, 9) # Se ilumina el LED de la fila 0 y el valor de var para columna\n    sleep(300)\n    display.set_pixel(4, var, 9) # Se ilumina el LED de la fila 4 y el valor de var para columna\n    sleep(300)\n</code></pre> <p>Los bucles se pueden anidar, es decir se puede crear un bucle dentro de otro del mismo o diferente tipo, de forma que por cada iteraci\u00f3n del bucle mas externo se tienen que producir todas las iteraciones del bucle mas interno. Veamos como ejemplo el de encender todos los LEDs de uno en uno, de izquierda a derecha, utilizando el valor de sus coordenadas x,y. El programa ser\u00eda:</p> <pre><code>from microbit import *\n\ndisplay.clear()\nfor y in range(0, 5): # Valor de columna\n    for x in range(0, 5): # Valor de fila\n        display.set_pixel(x, y, 9) # Encender LED x,y\n        sleep(100)\n</code></pre> <p>En la animaci\u00f3n siguiente vemos el programa en funcionamiento.</p> <p> <p> Uso de bucle for</p> <p></p> <p>El bucle <code>for</code> puede tener de manera opcional un bloque <code>else</code> cuyas sentencias se ejecutan cuando se han realizado todas las iteraciones del bucle. Un ejemplo lo vemos a continuaci\u00f3n:</p> <pre><code>for var in range(5):\n    print(var)\nelse:\n    print(\"bucle finalizado\")\n</code></pre>"},{"location":"programacion/python/#bucle-for-decontando","title":"Bucle for decontando","text":"<p>Se trata del mismo bucle <code>for</code> pero ahora la cuenta la realizamos hacia atr\u00e1s. Hay dos formas sencillas de hacerlo:</p> <ul> <li>Utilizando la funci\u00f3n <code>range()</code>. Si queremos darle un enfoque Pythonic simplemente configuramos los argumentos de la funci\u00f3n de manera que se indique el principio, el final y el incremento, que ser\u00e1 logicamente negativo.</li> </ul> <pre><code>for i in range(20, 0, -2): #imprimere 20, 18, 16, ... 0\n</code></pre> <ul> <li>Utilizando la funci\u00f3n <code>reversed()</code>. Es una funci\u00f3n incorporada en la que hay que indicar como primer argumento el final de la cuenta, como segundo el principio, teniendo en cuenta que se omite, y como tercero el decremento si es ditintos de 1, pero se especifica en m\u00f3dulo. Se utiliza as\u00ed:</li> </ul> <pre><code>for i in reversed(range(0,21,2)): #imprimere 20, 18, 16, ... 0\n</code></pre>"},{"location":"programacion/python/#sentencias-break-y-continue","title":"Sentencias <code>break</code> y <code>continue</code>","text":"<p>La sentencia <code>break</code> se utiliza para terminar un bucle de forma inmediata al ser encontrada. En la imagen vemos la sintaxis de la sentencia <code>break</code> y su funcionamiento.</p> <p> <p> Sintaxis y funcionamiento de <code>break</code></p> <p></p> <p>La sentencia <code>continue</code> se utiliza para saltar la iteraci\u00f3n actual del bucle y el flujo de control del programa pasa a la siguiente iteraci\u00f3n. En la imagen vemos la sintaxis de la sentencia <code>continue</code> y su funcionamiento.</p> <p> <p> Sintaxis y funcionamiento de <code>continue</code></p> <p></p> <p>En la figura siguiente vemos dos ejemplos de esta sentencia.</p> <p> <p> Funcionamiento de <code>continue</code></p> <p></p>"},{"location":"programacion/python/#imagenes","title":"Im\u00e1genes","text":"<p>MicroPython nos ofrece muchas im\u00e1genes integradas para mostrar por pantalla y podemos crear efectos interesantes. Mediante la caracter\u00edstica de autocompletar se nos van a mostrar todas las definidas que est\u00e1n listadas en la documentaci\u00f3n oficial. Ya hemos visto como cargar una imagen, lo que puedo aconsejar en este momento es realizar el ejercicio de mostrar cada una de las disponibles para familiarizarnos con ellas.</p> <p>Es perfectamente posible crar nuestras propias im\u00e1genes configurando cada Pixel o LED de la pantalla. Tambi\u00e9n es posible crear animaciones con im\u00e1genes.</p>"},{"location":"programacion/python/#imagenes-diy","title":"Im\u00e1genes DIY","text":"<p>Crear nuestras propias im\u00e1genes va a resultar una tarea sencilla cuando conozcamos la informaci\u00f3n para hacerlo. Cada pixel (LED) de la pantalla se puede configurar con diez valores que pueden tomar un valor entre 0 (cero) y 9 (nueve). Cuando le damos valor 0 (cero) es decirle literalmente que el brillo es nulo y sin embargo cuando le damos el valor 9 (nueve) lo ponemos al m\u00e1ximo de brillo posible. Podemos jugar con todos los valores intermedios para crear niveles de brillo.</p> <p>La forma mas sencilla de definir una imagen consiste en utilizar la clase microbit.Image para crearla a partir de una cadena o string que devuelva el pictograma. Es decir utilizando el comando Image(string) teniendo que constar de d\u00edgitos con los valores 0 a 9 indicados. Para verlo rapidamente hacemos el ejemplos de dibujar una X en relieve asign\u00e1ndola a una variable.</p> <pre><code>mi_imagen_X = Image(\"90009:\"\n                    \"06060:\"\n                    \"00300:\"\n                    \"06060:\"\n                    \"90009\")\n</code></pre> <p>Los dos puntos indican un salto de l\u00ednea por lo que se puede usar el ASCII no imprimible \"\\n\" que es precisamente eso, un salto de l\u00ednea.</p> <pre><code>mi_imagen_X = Image(\"90009\\n\"\n                    \"06060\\n\"\n                    \"00300\\n\"\n                    \"06060\\n\"\n                    \"90009\")\n</code></pre> <p>Los valores de brillo dan la sensaci\u00f3n de relieve de profundidas a la X.</p> <p>En cualquier caso esto no se escribe normalmente as\u00ed, salvo para hacer mas o menos un gr\u00e1fico del pixelado, sino en una sola l\u00ednea.</p> <pre><code>mi_imagen_X = Image(\"90009\\n06060\\n00300\\n06060\\n90009\")\n</code></pre> <p>Ahora parece mas elegante utilizar los dos puntos como indicador de salto de l\u00ednea.</p> <pre><code>mi_imagen_X = Image(\"90009:06060:00300:06060:90009\")\n</code></pre> <p>En la imagen vemos el resultado de lo explicado.</p> <p> <p> mi imagen de una X en relieve</p> <p></p> <p>Este es el c\u00f3digo creado:</p> <pre><code>from microbit import * \n\"\"\"mi_imagen_X = Image(\"90009\\n\"\n                       \"06060\\n\"\n                       \"00300\\n\"\n                       \"06060\\n\"\n                       \"90009\")\"\"\"\n#mi_imagen_X = Image(\"90009\\n06060\\n00300\\n06060\\n90009\")\nmi_imagen_X = Image(\"90009:06060:00300:06060:90009\")\ndisplay.show(mi_imagen_X)\n</code></pre>"},{"location":"programacion/python/#animar-imagenes","title":"Animar im\u00e1genes","text":"<p>En micro:bit Python ya disponemos de un par de listas de im\u00e1genes incorporadas que se llaman</p> <pre><code>Image.ALL_Clocks\nImage.ALL_ARROWS\n</code></pre> <p>Estas dos ordenes hacen que MicroPython entienda que necesita mostrar cada imagen de la lista, una tras otra.</p> <p>Cuando queremos mostrar en la pantalla una imagen se nos muestra la siguiente ayuda contextual:</p> <p> <p> Ayuda contextual para display.show()</p> <p></p> <p>donde nos indica claramente qie image puede ser una cadena, un n\u00famero, una imagen o una lista de im\u00e1genes. Adem\u00e1s aparecen las opciones que podemos configurar.</p> <p>Con esta informaci\u00f3n crear un \"reloj\" que est\u00e9 continuamente marcando cada hora es bastante sencillo, basta con poner el siguiente c\u00f3digo y darle a simular.</p> <pre><code># Imports go at the top\nfrom microbit import *\ndisplay.show(Image.ALL_CLOCKS, delay=400, loop=True)\n</code></pre> <p>En la animaci\u00f3n vemos el funcionamiento de este \"reloj\".</p> <p> <p> \"Reloj\" creado con display.show() y mostrar una lista</p> <p></p> <p>Si cambiamos el reloj por las flechas veremos como van rotando flechas en \u00e1ngulos de 45 grados.</p> <p> <p> Flechas creado con display.show() y mostrar una lista</p> <p></p> <p>Para animar nuestras propias im\u00e1genes tendremos que crear cada una sobre un lienzo de 5x5 pixeles y establecer las diferencias para crear la animaci\u00f3n. Podemos crear tantas im\u00e1genes como creamos oportuno. Creamos una lista con todas las im\u00e1genes en el orden que se tienen que reproducir y ya podemos mostrar nuestra lista en la pantalla.</p> <p>En la animaci\u00f3n siguiente vemos un efecto creado de esta forma.</p> <p> <p> Cortinilla animada</p> <p></p> <p>Este es el c\u00f3digo para crear la animaci\u00f3n.</p> <pre><code># Imports go at the top\nfrom microbit import *\ndisplay.clear()\ncor1=Image(\"90000:90000:90000:90000:90000\")\ncor2=Image(\"79000:79000:79000:79000:79000\")\ncor3=Image(\"57900:57900:57900:57900:57900\")\ncor4=Image(\"35790:35790:35790:35790:35790\")\ncor5=Image(\"13579:13579:13579:13579:13579\")\ncor6=Image(\"01357:01357:01357:01357:01357\")\ncor7=Image(\"00135:00135:00135:00135:00135\")\ncor8=Image(\"00013:00013:00013:00013:00013\")\ncor9=Image(\"00001:00001:00001:00001:00001\")\ncor10=Image(\"00000:00000:00000:00000:00000\")\ntodas_las_cortinas=[cor1,cor2,cor3,cor4,cor5,cor6,cor7,cor8,cor9,cor10]\ndisplay.show(todas_las_cortinas, delay=100, loop=True)\n</code></pre>"},{"location":"programacion/python/#sentencia-condicional-ifelse","title":"Sentencia condicional <code>if...else</code>","text":"<p>En Python hay tres formas de declaraci\u00f3n de <code>if...else</code></p> <ol> <li>Declaraci\u00f3n <code>if</code></li> <li>Declaraci\u00f3n <code>if...else</code></li> <li>Declaraci\u00f3n <code>if...elif...else</code></li> </ol> <ol> <li>Declaraci\u00f3n <code>if</code>. La sintaxix de esta declaraci\u00f3n en Python tiene la forma siguiente:</li> </ol> <pre><code>if condicion:\n    # Cuerpo de la sentencia if\n\n# C\u00f3digo despu\u00e9s del if\n</code></pre> <p>Si el resultado de evaluar la condici\u00f3n es cierto (True o 1), el c\u00f3digo en \"Cuerpo de la sentencia if\" y lo estar\u00e1 haciendo mientras se cumpla la condici\u00f3n.</p> <p>En el momento que la condici\u00f3n sea evaluada como falsa (False o 0) el c\u00f3digo en \"Cuerpo de la sentencia if\" se omite y  continua la ejecuci\u00f3n del programa por \"C\u00f3digo despu\u00e9s del if\". En la figura siguiente vemos la explicaci\u00f3n de forma gr\u00e1fica.</p> <p> <p> Funcionamiento de la sentencia <code>if</code></p> <p></p> <ol> <li>Declaraci\u00f3n <code>if...else</code>. Una sentencia <code>if</code> puede tener de manera opcional una clausula <code>else</code>. La sintaxix de esta declaraci\u00f3n en Python tiene la forma siguiente:</li> </ol> <pre><code>if condicion:\n    # Bloque de sentencias si condicion es True\n\n    else:\n    # Bloque de sentencias si condicion es False\n</code></pre> <p>La sentencia se eval\u00faa de la siguiente forma: Si <code>condici\u00f3n</code> es <code>True</code> se ejecuta el c\u00f3digo dentro del <code>if</code> y el c\u00f3digo dentro del <code>else</code> se omite. Si <code>condici\u00f3n</code> es <code>False</code> se ejecuta el c\u00f3digo dentro del <code>else</code> y el c\u00f3digo dentro del <code>if</code> se omite. Cuando finaliza bien la parte del <code>if</code> o bien la del <code>else</code> el programa continua con la siguiente sentencia.</p> <p>En la figura siguiente vemos la explicaci\u00f3n de forma gr\u00e1fica.</p> <p> <p> Funcionamiento de la sentencia <code>if...else</code></p> <p></p> <ol> <li>Declaraci\u00f3n <code>if...elif...else</code>. La sentencia <code>if...else</code> se utiliza para ejecutar un bloque de c\u00f3digo entre dos alternativas posibles. Sin embargo, si necesitamos elegir entre m\u00e1s de dos alternativas, entonces utilizamos la sentencia <code>if...elif...else</code>. La sintaxis de la sentencia <code>if...elif...else</code> es:</li> </ol> <pre><code>if condicion_1:\n    # Bloque 1\nelif condicion_2:\n    #Bloque 2\n\n    else:\n    # Bloque 3\n</code></pre> <p>Se eval\u00faa as\u00ed: Si <code>condicion_1</code> es <code>True</code>, se ejecuta Bloque 1. Si <code>condicion_1</code> es <code>False</code>, se eval\u00faa <code>condicion_2</code>. Si <code>condicion_2</code> es <code>True</code>, se ejecuta Bloque 2. Si <code>condicion_2</code> es <code>False</code>, se ejecuta Bloque 3.</p> <p>En la figura siguiente vemos la explicaci\u00f3n de forma gr\u00e1fica.</p> <p> <p> Funcionamiento de la sentencia <code>if...elif...else</code></p> <p></p>"},{"location":"programacion/python/#funciones-en-python","title":"Funciones en Python","text":"<p>En esta secci\u00f3n vamos a dar solamente una breve introducci\u00f3n a lo que son las funciones y los m\u00f3dulos en Python para estudiar dos funciones concretas definidas en MicroPhyton para micro:bit.</p> <p>Una funci\u00f3n es un bloque de c\u00f3digo que realiza una tarea espec\u00edfica.</p> <p>Supongamos que necesitas crear un programa para crear un c\u00edrculo y colorearlo. Puedes crear dos funciones para resolver este problema:</p> <ul> <li>crear una funci\u00f3n de c\u00edrculo</li> <li>crear una funci\u00f3n de color</li> </ul> <p>Dividir un problema complejo en trozos m\u00e1s peque\u00f1os hace que nuestro programa sea f\u00e1cil de entender y reutilizar.</p> <p>Existen dos tipos de funciones en Python:</p> <ul> <li>Standard library functions (Funciones de biblioteca est\u00e1ndar). Son funciones incorporadas en Python que est\u00e1n disponibles para su uso.</li> <li>User-defined functions (Funciones definidas por el usuario). Podemos crear nuestras propias funciones para que cumplan con nuestros requisitos.</li> </ul> <p>La sintaxis de una funci\u00f3n es la siguiente:</p> <pre><code>def nombre_funcion(argumentos):\n    #Cuerpo de la funci\u00f3n\n\n    return\n</code></pre> <p>Donde,</p> <ul> <li><code>def</code> es la palabra reservada para declarar una funci\u00f3n</li> <li><code>nombre_funcion</code> es el nombre que le damos a la funci\u00f3n</li> <li><code>argumentos</code> es el valor o valores pasados a la funci\u00f3n</li> <li><code>return</code> retorna un valor desde la funci\u00f3n. Es opcional</li> </ul> <p>Veamos un ejemplo sencillo que no manda parametros ni retorna nada.</p> <p><pre><code>def saludo():\n    print(\"Hola Mundo!\")\n\nsaludo() #Llama a la funci\u00f3n\nprint(\"Programa\")\nsaludo()\nprint(\"Otra vez programa\")\n</code></pre> Va a generar como salida la cadena \"Hola Mundo!\" seguida de la cadena \"Programa\" seguida otra vez de \"Hola Mundo!\" y finaliza con \"Otra vez programa\".</p> <p>Cuando se llama a la funci\u00f3n, el control del programa pasa a la definici\u00f3n de la funci\u00f3n, se ejecuta todo el c\u00f3digo dentro de la funci\u00f3n y desp\u00e9s el control del programa salta a la siguiente sentencia despu\u00e9s de la llamada a la funci\u00f3n.</p> <p>Como ya se ha mencionado, una funci\u00f3n tambi\u00e9n puede tener argumentos. Un argumento es un valor aceptado por una funci\u00f3n. Cuando creamos una funci\u00f3n con argumentos necesitamos pasar los correspondientes valores cuando la llamamos.</p> <p>De forma gen\u00e9rica una funci\u00f3n con argumentos tiene la siguiente sintaxis:</p> <pre><code>def funcion(arg1, arg2, ar3,...):\n    #C\u00f3digo\n\n#Llamada a la funci\u00f3n\nfuncion(valor1, valor2, valor3, ...)\n#C\u00f3digo\n</code></pre> <p>Cuando llamamos a la funci\u00f3n le pasamos los valores correspondiendo valor1 a arg1, valor2 a arg2 y as\u00ed sucesivamente.</p> <p>La llamada a la funci\u00f3n se puede hacer mencionando el nombre del argumento, que es lo que se conoce como 'argumentos con nombre', siendo el c\u00f3digo totalmente equivalente al anterior.</p> <pre><code>funcion(arg1=valor1, arg2=valor2, arg3=valor3, ...)\n</code></pre> <p>Una funci\u00f3n Python puede o no devolver un valor. Si queremos que nuestra funci\u00f3n devuelva alg\u00fan valor a una llamada realizada a funci\u00f3n, utilizamos la sentencia <code>return</code>.</p> <p>En el ejemplo siguiente se llama a la funci\u00f3n cuatro veces con valores diferentes.</p> <pre><code>def cal_potencia(base, exponente):\n    resultado = base ** exponente\n    return resultado\n\n#Llamadas a la funci\u00f3n\nprint('Potencia =', cal_potencia(2,8))\nprint('Potencia =', cal_potencia(3,3))\nprint('Potencia =', cal_potencia(4,5))\nprint('Potencia =', cal_potencia(9,6))\n</code></pre> <p>El resultado es:</p> <pre><code>Potencia = 256\nPotencia = 27\nPotencia = 1024\nPotencia = 531441\n</code></pre> <p>En Python, las funciones de la biblioteca est\u00e1ndar son las funciones incorporadas que se pueden utilizar directamente en nuestro programa. Por ejemplo,</p> <ul> <li><code>print()</code>, imprime la cadena entre comillas</li> <li><code>sqrt()</code>, devuelve la ra\u00edz cuadrada de un n\u00famero</li> <li><code>pow()</code>, devuelve la potencia de un n\u00famero</li> </ul> <p>Estas funciones est\u00e1n definidas dentro de un m\u00f3dulo. Y, para utilizarlas debemos incluir dicho m\u00f3dulo en nuestro programa. Por ejemplo, <code>sqrt()</code> y <code>pow()</code> est\u00e1n definidos en el m\u00f3dulo <code>math</code>. Para usar las funciones podemos hacer como en el ejemplo siguiente:</p> <pre><code>import math #Carga el m\u00f3dulo math\n\nraiz = math.sqrt(25)\nprint(\"La raiz cuadrada de 25 es \", raiz)\n\npotencia = pow(2, 8)\nprint(\"2^8 =\", potencia)\n</code></pre> <p>En el ejemplo la variable raiz contendr\u00e1 el c\u00e1lculo de la raiz cuadrada y se define por defecto como variable real o decimal y potencia contendr\u00e1 el resultado de elevar a 8 el n\u00famero 2. Los resultados obtenidos son:</p> <pre><code>La raiz cuadrada de 25 es 5.0\n2^8 = 256\n</code></pre> <p>Las principales ventajas de utilizar funciones son:</p> <ul> <li>C\u00f3digo reutilizable. Podemos llamar a la misma funci\u00f3n tantas veces en nuestro programa como necesitemos, lo que hace que nuestro c\u00f3digo sea reutilizable.</li> <li>C\u00f3digo legible. Las funciones nos ayudan a dividir nuestro c\u00f3digo en trozos para que nuestro programa sea mas legible y f\u00e1cil de entender.</li> </ul>"},{"location":"programacion/python/#modulos-en-python","title":"M\u00f3dulos en Python","text":"<p>A medida que nuestro programa crece, puede contener muchas l\u00edneas de c\u00f3digo. En lugar de poner todo en un solo archivo, podemos utilizar m\u00f3dulos para separar por funcionalidad los c\u00f3digos en varios archivos. Esto hace que nuestro c\u00f3digo quede organizado y sea m\u00e1s f\u00e1cil de mantener.</p> <p>Un m\u00f3dulo es un archivo que contiene c\u00f3digo para realizar una tarea espec\u00edfica. Un m\u00f3dulo puede contener variables, funciones, clases, etc. Veamos un ejemplo, vamos a crear un m\u00f3dulo escribiendo algo como lo siguiente:</p> <pre><code>#Definici\u00f3n del m\u00f3dulo suma\n\ndef sumar(a, b):\n\n    resultado = a + b\n    return resultado\n</code></pre> <p>Guardamos este programa en un archivo, por ejemplo <code>modulo_sumar.py</code> y tendremos definida una funci\u00f3n de nombre <code>sumar</code> en ese m\u00f3dulo. La funci\u00f3n recibe dos valores y devuelve la suma.</p> <p>Cuando, en un programa diferente, queramos sumar dos n\u00fameros podemos importar la definici\u00f3n creada utilizando la palabra reservada <code>import</code>. Para acceder a la funci\u00f3n definida en el m\u00f3dulo tenemos que utilizar el operador <code>.</code> (punto). Se parece mucho a que el m\u00f3dulo es una clase y la funci\u00f3n una instancia de esa clase.</p> <pre><code># Programa de sumas\nimport modulo_sumar\n\nmodulo_sumar.sumar(4, 5) #devolver\u00e1 9\n</code></pre> <p>Python tiene mas de 200 m\u00f3dulos est\u00e1ndar que pueden ser importados de la misma manera que importamos los m\u00f3dulos definidos por nosotros. En la documentaci\u00f3n de Python en espa\u00f1ol encontramos la referencia a La biblioteca est\u00e1ndar de Python.</p>"},{"location":"programacion/python/#eventos-para-los-botones","title":"Eventos para los botones","text":"<p>Si trabajamos con versiones anteriores a V2 solamente disponemos de los botones A, B y A+B, pero si tenemos una versi\u00f3n V2 tambi\u00e9n disponemos del bot\u00f3n t\u00e1ctil incorporado en el logo, aunque a todos los efectos este se considera un pin de entrada.</p> <p>El logo no es tratado exactamente como un bot\u00f3n, sino como un pin de nombre logo. En el borde existen otros tres pines, los 0, 1 y 2. Por ello la forma de trabajar con el logo va a ser un poco diferente, como veremos en la actividad A04.</p> <p>La diferencia fundamental, ademas de la forma, es que el logo es un sensor capacitivo y los pines son sensores resistivos. En la pr\u00e1ctica esto significa que el logo funciona simplemente tocandolo y los pines necesitan cerrar el circuito con GND, por lo que para que funcionen como pulsador debemos tocar tanto el pinto como GND.</p> <p>Si queremos que MicroPython reaccione a los eventos de pulsaci\u00f3n de los botones, debemos ponerlo en un bucle infinito y comprobar si el bot\u00f3n <code>is_pressed</code>.</p> <ul> <li>Funci\u00f3n <code>is_pressed()</code></li> </ul> <p>Para trabajar con los botones de la micro:bit tenemos disponibles funciones que se han cargado al importar el m\u00f3dulo <code>microbit</code>. Estas funciones est\u00e1n basadas en la funci\u00f3n gen\u00e9rica <code>is_pressed()</code> pensada para saber que tecla de un teclado se ha pulsado. Sin embargo, en el caso de MicroPython a para micro:bit a estos botones se les ha asignado un nombre a cada uno, <code>button_a</code> para el A y  <code>button_b</code> para el B, de manera que para usarlos se llama al bot\u00f3n y con el operador <code>.</code> a la funci\u00f3n <code>is_pressed()</code>. Por ejemplo, <code>button_a.is_pressed()</code> es el c\u00f3digo encargado de saber si estamos pulsando el bot\u00f3n A y <code>button_b.is_pressed()</code> si lo es el B.</p> <ul> <li>Funci\u00f3n <code>get_pressed()</code></li> </ul> <p>Esta funci\u00f3n retorna el total acumulado de pulsaciones de botones y restablece este total a cero antes de volver. Es decir, podemos capturar el n\u00famero de veces que hemos pulsado un bot\u00f3n. El valor de retorno es un n\u00famero, por lo que, para mostrarlo en la pantalla de LEDs hay que convertirlo en cadena con la funci\u00f3n <code>str()</code>.</p> <ul> <li>Funci\u00f3n <code>was_pressed()</code></li> </ul> <p>Devuelve <code>True</code> o <code>False</code> para indicar si se ha presionado el bot\u00f3n desde la \u00faltima vez que se inicio el dispositivo o se llam\u00f3 a este m\u00e9todo. Llamar a este m\u00e9todo borra el estado de que ha sido pulsado, de modo que el bot\u00f3n debe pulsarse de nuevo antes de que este m\u00e9todo vuelva a retornar <code>True</code>.</p> <p>Vamos a hacer un ejemplo que aclarar\u00e1 mejor lo explicado. Se trata de crear un programa (le podremos de nombre Caritas_X) en el que mientras mantegamos pulsado el bot\u00f3n A se muestra una cara sonriente, si no se pulsa ning\u00fan bot\u00f3n se muestra una cara triste y si se pulsa el bot\u00f3n B la cara desaparece (se apagan todos los LEDs) y tras 2 segundos aparece una X que se va haciendo cada vez mas grande partiendo del punto central. Finalmente pasados otros 2 segundos el programa vuelve a empezar. El c\u00f3digo es:</p> <pre><code>from microbit import *\nwhile True:\n    while True:\n        if button_a.is_pressed():\n            display.show(Image.HAPPY)\n        elif button_b.is_pressed():\n            break\n        else:\n            display.show(Image.SAD)\n\n    display.clear()\n    sleep(2000)\n    mi_X_peque = Image(\"00000:00000:00900:00000:0000\")\n    display.show(mi_X_peque)\n    sleep(200)\n    mi_X_media = Image(\"00000:09090:00900:09090:0000\")\n    display.show(mi_X_media)\n    sleep(200)\n    mi_X_grande = Image(\"90009:09090:00900:09090:90009\")\n    display.show(mi_X_grande)\n    sleep(2000)\n</code></pre> <p>En la animaci\u00f3n siguiente vemos como funciona</p> <p> <p> Funcionamiento de Caritas_X</p> <p></p> <p>Si observamos con cuidado apreciaremos que en alg\u00fan momento se accionan los botones A y B pero los que aparecen en la parte inferior, debajo de la pantalla de simulaci\u00f3n. Est\u00e1n al lado de un logotipo que indica que se pulsen con una flechita. Justo debajo de estos aparecen los citados del borde de placa y el logo junto a ellos, pues es tratado asi, como un pin, y adem\u00e1s a su izquierda hay un candado cerrado indicativo de que no se est\u00e1 usando ninguno de ellos. En la imagen siguiente se ve mejor lo indicado.</p> <p> <p> Control de acciones del simulador</p> <p></p> <p>Vamos a crear otro ejemplo en el que se cuenten las veces que pulsamos el bot\u00f3n A o el bot\u00f3n B durante un tiempo de 3 segundo. El programa es el siguiente:</p> <pre><code>from microbit import *\n\nsleep(3000) #Espera de 3 segundos\n\n#Convertimos n\u00famero a cadena con str()\npulsado = str(button_b.get_presses())\n\ndisplay.show(pulsado)\n\n# Por si hemos pulsado mas de 9 veces\ndisplay.scroll(pulsado)\n</code></pre> <p>En la 'Referencia' del compilador, dentro de Botones tenemos un ejemplo que nos indica el bot\u00f3n que hemos pulsado con cuatro opciones posibles, el A, el B, A o B y finalmente A y B. Animamos a cargarlos y probarlos para familiarizarnos todo lo posible con ellos.</p>"},{"location":"programacion/python/#pines-de-entradasalida","title":"Pines de Entrada/salida","text":""},{"location":"programacion/python/#digital","title":"Digital","text":"<p>Podemos utilizar los pines 0, 1 y 2 del borde de placa en modo digital tanto para leer su valor como para escribir o establecer su valor. Esto se representa con un \"1\" l\u00f3gico (sin las comillas) si est\u00e1n activados o los queremos activar y un \"0\" l\u00f3gico si est\u00e1n desactivados o los queremos desactivar.</p> <p>Si queremos escribir en ellos los pines estar\u00e1n actuando como salidas y tenemos que invocar al m\u00e9todo <code>write</code> para hacerlo. Las sentencias, para un pin gen\u00e9rico \"N\" son:</p> <pre><code>pinN.write_digital(1) #Salida en estado alto\npinN.write_digital(0) #Salida en estado bajo\n</code></pre> <p>Tambi\u00e9n podemos conectar, por ejemplo un interruptor o bot\u00f3n pulsador al pin (veremos como hacerlo en la siguiente actividad) y comprobar si el interruptor est\u00e1 abierto (0) o cerrado (1). En este caso los pines estar\u00e1n configurados como entradas y la lectura de su estado se obtiene invocando el m\u00e9todo <code>read</code>.  Las sentencias, para un pin gen\u00e9rico \"N\" son:</p> <pre><code>pinN.read_digital() #Devuelve el estado 0 o 1 del pin N\n</code></pre> <p>Nunca se conecta nada a los pines con un voltaje superior a 3v porque se puede da\u00f1ar la micro:bit.</p>"},{"location":"programacion/python/#analogica","title":"Anal\u00f3gica","text":"<p>Podemos utilizar los pines 0, 1 y 2 del borde de placa en modo anal\u00f3gico tanto para leer su valor como para escribir o establecer su valor. Esto significa que en lugar de estar activos o inactivos (0 o 1), var\u00edan su valor entre 0 y 1023.</p> <p>Si queremos escribir en ellos los pines estar\u00e1n actuando como salidas y tenemos que invocar al m\u00e9todo <code>write</code> para hacerlo. La sentencia, para un pin gen\u00e9rico \"N\" es:</p> <pre><code>pinN.write_analog(valor) #valor puede estar entre 0 y 1023\n</code></pre> <p>Si conectamos sensores o actuadores anal\u00f3gicos a los pines podemos leer su valor invocando a <code>read</code>. La sentencia, para un pin gen\u00e9rico \"N\" es:</p> <pre><code>pinN.read_analog(valor) #valor puede estar entre 0 y 1023\n</code></pre>"},{"location":"programacion/ublocks/","title":"MicroBlocks","text":"<p>De manera muy resumida lo que haremos en esta secci\u00f3n es:</p> <ul> <li>Describir los bloques y conceptos relacionados.</li> <li>Incluiremos esquemas si resultan necesarios.</li> </ul>"},{"location":"programacion/ublocks/#comentarios","title":"Comentarios","text":"<p>En MicroBlocks los comentarios son tratados desde un \u00fanico bloque que podemos encontrar en el men\u00fa 'Control'. Es un bloque no hace nada. Se utiliza para a\u00f1adir notas y documentaci\u00f3n a los scripts.</p> <p> <p> Comentarios</p> <p></p> <p>La ventana de entrada de texto se autodimensiona seg\u00fan introducimos texto y se pueden a\u00f1adir l\u00edneas pulsando la tecla enter.</p>"},{"location":"programacion/ublocks/#control","title":"Control","text":"<p>En este grupo tenemos acceso a los bloques de control de la micro:bit.</p> <ul> <li>al empezar. Los bloques debajo de este se ejecutan cuando se enciende la placa o cuando se hace clic en el icono verde EJECUTAR que tiene forma de flecha. Es uno de los bloques denominados sombrero.</li> </ul> <p> <p> Bloque 'al empezar'</p> <p></p> <ul> <li>por siempre. Se trata del bloque de la imagen y es un bloque que se ejecuta de manera indefinida.</li> </ul> <p> <p> Bloque 'por siempre'</p> <p></p> <ul> <li>espera xx milisegundos. Espera el n\u00famero de milisegundos indicado antes de continuar.</li> </ul> <p> <p> Bloque 'espera xx milisegundos'</p> <p></p>"},{"location":"programacion/ublocks/#pantalla-led","title":"Pantalla LED","text":"<p>Libreria con los bloques de control de la pantalla LED.</p> <ul> <li>limpia pantalla. Apaga todos los LEDs.</li> </ul> <p> <p> Bloque 'limpia pantalla'</p> <p></p> <ul> <li>pantalla. Muestra una imagen de la pantalla que permite cambiar el estado de cada LED haciendo clic sobre el mismo.</li> </ul> <p> <p> Bloque 'pantalla'</p> <p></p> <ul> <li>anima el texto. Muestra el texto introducido mediante desplazamiento caracter a caracter con el retardo en milisegundos que establezcamos.</li> </ul> <p> <p> Bloque 'anima el texto'</p> <p></p> <ul> <li>enciende x,y. Enciende el LED indicado en la coordenada x,y. La coordenadas x es la horizontal y la y es la vertical. La coordenada 1,1 es la esquina superior ezquierda, la 1,5 es la derecha, la 5,1 es la inferior izquierda y la 5,5 la inferior derecha.</li> </ul> <p> <p> Bloque 'enciende x,y'</p> <p></p>"},{"location":"programacion/ublocks/#operadores","title":"Operadores","text":"<p>Esta entrada se crea porque en MicroBlocks, en el men\u00fa espec\u00edfico, aparecen algunos operadores especiales. Las descripciones siguiente son las obtenidas de MicroBlocks Wiki.</p> <p>Dentro del grupo de bloques est\u00e1ndar tenemos los que se ven en la imagen.</p> <p> <p> Bloques est\u00e1ndar</p> <p></p> <ul> <li>  Devuelve el resto de la divisi\u00f3n entre los dos n\u00fameros introducidos, ambos inclusive.</li> <li> Devuelve un n\u00famero aleatorio (al azar) entre el primer y el segundo valor indicado.</li> </ul> <p>En la imagen vemos un ejemplo donde se averigua si un n\u00famero generado al azar es par o impar.</p> <p>A la variable <code>num_aleatorio</code> se le asigna un n\u00famero aleatorio del 1 al 15. La operaci\u00f3n <code>m\u00f3dulo</code> se utiliza para comprobar si el resto es 0 y as\u00ed saber si el n\u00famero es par. Si el resto de la operaci\u00f3n <code>num_aleatorio</code> dividido por 2 da como resultado 0, el n\u00famero es par, en caso contrario es impar.</p> <p> <p> Par o impar</p> <p></p> <p>Con este ejemplo comprobamos que una vez conectada la micro:bit (si no el programa nos indica que no lo est\u00e1 y no funcionar\u00e1), el bloque <code>di</code> muestra como retorno un mensaje que aparece asociado al bloque <code>al empezar</code> en la pantalla del ordenador. Esta es la forma de trabajar de MicroBlocks y hace que el c\u00f3digo se compruebe de manera instant\u00e1nea siempre que los bloques est\u00e9n acoplados a <code>al empezar</code>.</p> <p>Descargar el programa</p> <ul> <li>  Devuelve <code>True</code> si la expesi\u00f3n de entrada del lado izquierdo coincide con la selecci\u00f3n del men\u00fa de tipos de datos realizada en el lado derecho. Los tipos de datos son importantes a la hora de programar. Aunque un entorno como MicroBlocks facilita las cosas a los usuarios principiantes al encargarse de las conversiones de tipos de datos, todav\u00eda es posible enga\u00f1arse visualmente al comparar variables cuyos valores parecen iguales. Este bloque pertenece al grupo de condicionales, pero se describe ahora porque se utiliza en el ejemplo siguiente.</li> </ul> <p> <p> N\u00famero o cadena</p> <p></p> <p>Descargar el programa</p> <p>Desplegando la secci\u00f3n 'Avanzados' vemos algunos bloques que representan operaciones bit a bit. Los operadores bit a bit (bitwise) trabajan sobre representaciones binarias de datos y su utilidad est\u00e1 en cambiar bits individuales en un operando. Los dos operandos asociados al operador bit a bit deben ser enteros. En la imagen vemos los bloques que aparecen en avanzados.</p> <p> <p> Bloques de operadores avanzados</p> <p></p> <ul> <li> Permite modificar el rango de un valor o variable desde un rango origen a un rango destino. Esta funci\u00f3n es especialmente \u00fatil para adaptar los valores le\u00eddos de sensores o para adaptar valores a aplicar en un actuador.</li> <li> Convierte una cadena Hexadecimal en un n\u00famero decimal. Por ejemplo, 5A hex. = 90 dec.</li> <li>  El operador AND compara dos bits y genera un resultado igual a 1 si ambos bits son 1; en caso contrario, devuelve 0. N\u00fameros de mas de un bit son comparados bit a bit. Un ejemplo de aplicaci\u00f3n lo vemos en la imagen siguiente.</li> </ul> <p> <p> bitwise AND</p> <p></p> <p>La tabla siguiente muestra la forma de obtener el resultado de forma te\u00f3rica.</p> <p> <p> </p> <p></p> <ul> <li>  El operador OR compara dos bits y devuelve 1 si uno o ambos bits son 1 y da 0 si ambos bits son 0. Bitwise OR compara todas las posiciones de bits de ambos n\u00fameros e informa de aquellas en las que cualquiera de los dos est\u00e1 a 1.</li> </ul> <p>Un ejemplo de aplicaci\u00f3n lo vemos en la imagen siguiente.</p> <p> <p> bitwise OR</p> <p></p> <p>La tabla siguiente muestra la forma de obtener el resultado de forma te\u00f3rica.</p> <p> <p> </p> <p></p> <ul> <li>  El operador EXCLUSIVE-OR compara dos bits y genera un resultado de 1 si los bits son complementarios (el bit se establece en un operando pero no en ambos); en caso contrario, devuelve 0. Otra forma de pensar en la operaci\u00f3n XOR es que invertir\u00e1 las posiciones de los bits en las que el segundo operando tenga un 1. Todas las dem\u00e1s se copiar\u00e1n igual.</li> </ul> <p>Un ejemplo de aplicaci\u00f3n lo vemos en la imagen siguiente.</p> <p> <p> bitwise XOR</p> <p></p> <p>La tabla siguiente muestra la forma de obtener el resultado de forma te\u00f3rica.</p> <p> <p> </p> <p></p> <ul> <li>  El operador NOT se utiliza para invertir (BIT FLIP) todos los bits del operando Cuando el bit de posici\u00f3n m\u00e1s alta de un n\u00famero se convierte en 1, ese n\u00famero se considera un n\u00famero negativo. La representaci\u00f3n inform\u00e1tica real de un n\u00famero entero con signo en MicroBlocks es de 31 bits. El bit de mayor peso es un bit de signo. Esto permite n\u00fameros en el rango de -1073741824 a 1073741823. Cuando el bit de signo es 0, el n\u00famero es positivo; y cuando es 1, el n\u00famero es negativo.</li> </ul> <p>Un ejemplo de aplicaci\u00f3n lo vemos en la imagen siguiente.</p> <p> <p> bitwise NOT</p> <p></p> <p>La explicaci\u00f3n es sencilla, el n\u00famero 3 (0011) se convierte al binario 1100 y como el bit de mayor peso es 1 indica que es negativo y el n\u00famero es 4, por lo tanto el resultado es -4.</p> <ul> <li> El valor del operando izquierdo se desplaza hacia la izquierda el n\u00famero de bits especificado por el operando derecho. Los bits se desplazan hacia la izquierda, el bit situado m\u00e1s a la izquierda se descarta y al bit situado m\u00e1s a la derecha se le asigna el valor 0. Cada posici\u00f3n de bit desplazada a la izquierda equivale en binario a multiplicar por 2. En la imagen siguiente vemos el funcionamiento del desplazamiento a la izquierda a nivel de bit.</li> </ul> <p> <p> bitwise desplazamiento izquierda</p> <p></p> <ul> <li> El valor del operando izquierdo se desplaza hacia la derecha el n\u00famero de bits especificado por el operando derecho. Los bits se desplazan hacia la derecha, el bit situado m\u00e1s a la derecha se descarta y al bit situado m\u00e1s a la izquierda se le asigna una copia del bit de signo. Esto se denomina desplazamiento aritm\u00e9tico. Por cada posici\u00f3n de bit desplazada a la derecha, esta operaci\u00f3n es el equivalente binario de dividir por 2. En la imagen siguiente vemos el funcionamiento del desplazamiento a la derecha a nivel de bit.</li> </ul> <p> <p> bitwise desplazamiento izquierda</p> <p></p>"},{"location":"programacion/ublocks/#variables","title":"Variables","text":"<p>En MicroBlocks se contemplan dos tipos de variables, las globales y las locales. Cuando hablamos en estos t\u00e9rminos hablamos de \u00e1mbito (scope) de las variables y determina la zona donde se define la variable, que son global y local.</p> <p>Las variables locales son las definidas dentro de una funci\u00f3n y solamente est\u00e1 disponible para el c\u00f3digo que se ejecuta dentro de la funci\u00f3n.</p> <p>Las variables globales se definen en cualquier punto del programa, normalmente al principio, y pueden ser llamadas desde cualquier sitio del programa, incluso desde las funciones.</p> <ul> <li> Este bloque es en realidad un bot\u00f3n que crea una nueva variable global. Si existe una variable con el mismo nombre, se crear\u00e1 una nueva con el mismo nombre y el n\u00famero 2 a\u00f1adido. Cuando creamos una variable se nos pide el nombre de la misma en una ventana emergente y una vez creada aparecer\u00e1 un nuevo bloque para acceder al valor de la variable creada. Adem\u00e1s esta nueva variable estar\u00e1 disponible para su selecci\u00f3n en dos de los bloques que explicaremos despu\u00e9s.</li> <li>  Este bloque es en realidad un bot\u00f3n que sirve para eliminar una variable previamente creada.</li> </ul> <p>En la animaci\u00f3n siguiente vemos el proceso de creaci\u00f3n y eliminaci\u00f3n de variables.</p> <p> <p> Creaci\u00f3n y eliminaci\u00f3n de variables</p> <p></p> <p>La opci\u00f3n de mostrar el nombre de las variables mostrada desde el bloque se puede utilizar para a\u00f1adir variables mientras se edita el c\u00f3digo del programa, sin pasar a las opciones de la categor\u00eda variables.</p> <ul> <li>  Este bloque asigna el valor a cualquier variable, global o local, en la cantidad especificada en el \u00e1rea de entrada. La cantidad que se asigna puede ser un n\u00famero positivo o negativo. Para mostrar los nombres de las variables locales en el men\u00fa de selecci\u00f3n, este bloque debe estar f\u00edsicamente unido a la secuencia de bloques en la que se utiliza el bloque 'Inicializar local' que veremos a continuaci\u00f3n.</li> <li>  Este bloque suma algebraicamente (cambia) el valor de cualquier variable, global o local, en la cantidad especificada en el \u00e1rea de entrada. La cantidad de cambio puede ser un n\u00famero positivo o negativo.</li> <li>  Este bloque se utiliza para crear e inicializar variables locales. El nombre predeterminado de la variable 'var' puede cambiarse por cualquier otro haciendo clic en el nombre y escribiendo un nuevo nombre en el cuadro de di\u00e1logo que se abre. Desp\u00e9s, si es necesario cambiar el valor de la variable local, se puede utilizar el bloque 'asigna valor a' de la categor\u00eda variables. En la animaci\u00f3n siguiente vemos este proceso y la disponibilidad o no de la variable local.</li> </ul> <p> <p> Inicializa variable local</p> <p></p> <p>Una variable global tiene:</p> <ul> <li>Alcance global: Una variable global puede utilizarse en cualquier script que no tenga una variable local del mismo nombre que la anule.</li> <li>Tiempo de vida largo: Una variable global es creada expl\u00edcitamente y vive hasta que es expl\u00edcitamente borrada. Conserva su valor cuando los scripts se inician y detienen e incluso cuando no hay scripts en ejecuci\u00f3n. Sin embargo, al hacer clic en el bot\u00f3n \"Detener\", todas las variables globales se borran e inicializan con el valor cero. Las variables globales tambi\u00e9n se inicializan a cero cuando se crean por primera vez y cuando se carga un proyecto.</li> </ul> <p>Por el contrario, una variable local tiene:</p> <ul> <li>\u00c1mbito local: Una variable local s\u00f3lo puede utilizarse en el script en el que aparece. Si varios scripts utilizan variables locales con el mismo nombre, esas variables son independientes entre s\u00ed. Aunque esta pr\u00e1ctica se desaconseja porque puede inducir a errores.</li> <li>Tiempo de vida limitado: Una variable local de un script se crea cuando se inicia el script y se elimina cuando \u00e9ste finaliza. Se crea una nueva variable local cada vez que se inicia un script (incluyendo un script de funci\u00f3n), y las variables locales de cada invocaci\u00f3n de script son independientes entre s\u00ed.</li> <li>Precedencia sobre las globales: Si una variable local tiene el mismo nombre que una variable global, la variable local prevalece sobre la global en el script en el que aparece la variable local. Una variable es local en todo el script sin importar en qu\u00e9 parte del script aparezca \"inicializar var local a\", aunque es una buena pr\u00e1ctica de codificaci\u00f3n que \"inicializar var local a\" preceda a cualquier otra referencia a esa variable.</li> </ul> <p>Un ejemplo comentado de aplicaci\u00f3n lo vemos en la imagen siguiente.</p> <p> <p> Variables</p> <p></p> <p>Descargar el programa</p>"},{"location":"programacion/ublocks/#bucles","title":"Bucles","text":"<p>En el caso de MicroBlocks los bucles, condicionales y funciones est\u00e1n todos englobados en la categor\u00eda 'Control'. Vamos a ver algunos de ellos en esta ocasi\u00f3n y los que no veamos en esta actividad se ir\u00e1n viendo cuando los necesitemos.</p> <ul> <li>  Los bloques con forma de sombrero forman parte de un grupo de bloques de control que comienzan a ejecutarse cuando se pulsa el icono verde <code>Inicia</code>. Este bloque se activa cuando se cumple la condici\u00f3n de inicio del programa.</li> <li>  Los bloques con forma de \"C\" son un grupo de bloques de control que ejecutan el c\u00f3digo colocado en su interior siempre que se cumplan las condiciones descritas en sus subt\u00edtulos. Estos son los bloques de tipo bucle. Este en particular ejecutar\u00e1 los bloques en su interior indefinidamente.</li> <li>  Este bloque C ejecuta el c\u00f3digo colocado en su interior el n\u00famero especificado de veces. En el ejemplo siguiente veremos tanto en el programa como en la pantalla la suma de los 10 primero n\u00fameros naturales.</li> </ul> <p> <p> Suma de los 10 primeros n\u00fameros</p> <p></p> <p>Descargar el programa</p> <ul> <li> <p>  Este bloque estambi\u00e9n de tipo C y pertenece al grupo de los bucles. Funciona de dos formas distintas en funci\u00f3n del tipo de entrada especificado.</p> </li> <li> <p>Si la entrada es un n\u00famero, los bloques interiores se ejecutar\u00e1n tantas veces como el n\u00famero. En cada iteraci\u00f3n del bucle, empezando por uno, el par\u00e1metro o variable de control es 'i' por defecto y se incrementar\u00e1 en uno. Este valor se puede utilizar en el c\u00f3digo del programa como se crea conveniente.</p> </li> <li>El nombre del par\u00e1metro de control puede cambiarse por otro haciendo clic en la 'i' y escribiendo un nuevo nombre.</li> <li>Si la entrada es una lista, los bloques colocados dentro se ejecutar\u00e1n tantas veces como elementos tenga la lista. En cada iteraci\u00f3n, el par\u00e1metro de control 'i' tomar\u00e1 el valor de cada elemento de la lista de manera secuencia. En el ejemplo siguiente vemos una animaci\u00f3n de un sencillo programa de como hacer un contador con los 5 primeros n\u00fameros y hacer que se muestre en el ordenador y en la pantalla de la micro:bit.</li> </ul> <p> <p> Mostrar los 5 primeros n\u00fameros</p> <p></p> <p>Descargar el programa</p> <ul> <li>  Este bloque pausa el flujo de ejecuci\u00f3n del programa por el tiempo especificado en milisegundos. Se utiliza para pausar y reanudar la ejecuci\u00f3n de c\u00f3digo de forma controlada.</li> <li>  Este bloque pausa el flujo de ejecuci\u00f3n del programa por el tiempo especificado en microsegundos. Se utiliza para pausar y reanudar la ejecuci\u00f3n de c\u00f3digo de forma controlada.</li> <li>  Emite el mensaje especificado. V\u00e9ase en conjunto a . Este bloque env\u00eda el contenido del mensaje especificado. Todos los bloques de mensajes <code>al recibir</code> con el mismo mensaje en su contenido recibir\u00e1n el mensaje y actuar\u00e1n ejecutando su contenido.</li> <li>  Ejecuta cuando se emita el mensaje especificado. Este bloque y su par funcional  se suelen utilizar juntos para conseguir un medio de comunicaci\u00f3n dentro del programa. Cualquier mensaje enviado con el comando <code>env\u00eda</code> es detectado y recibido por este bloque. As\u00ed, los bloques colocados bajo este bloque se ejecutar\u00e1n al recibir el mensaje correspondiente. Los mensajes pueden ser cadenas o n\u00fameros. Adem\u00e1s, el bloque  contiene el \u00faltimo mensaje emitido y recibido.</li> <li>  Devuelve el \u00faltimo mensaje enviado en todo el programa, cronol\u00f3gicamente hablando. N\u00f3tese que NO es el \u00faltimo mensaje recibido por una secuencia de bloques concreta del programa, y es independiente de la ejecuci\u00f3n del bloque <code>al recibir</code>. No hay colas de mensajes en el sistema. Si no hay ning\u00fan <code>al recibir</code> en espera cuando se env\u00eda un mensaje, se perder\u00e1 y ser\u00e1 sobrescrito por el siguiente mensaje.</li> </ul> <p>En el ejemplo siguiente vemos de forma sencilla el funcionamiento de estos tres \u00faltimos bloques.</p> <p> <p> Di el \u00faltimo mensaje</p> <p></p> <p>Descargar el programa</p>"},{"location":"programacion/ublocks/#listas","title":"Listas","text":"<p>Los bloques para trabajar con listas est\u00e1n en el men\u00fa 'Datos' y sus bloques los vemos en la imagen siguiente.</p> <p> <p> Bloques para Listas. Datos</p> <p></p> <ul> <li> Devuelve una lista corta que contiene algunos elementos en ingl\u00e9s. Con las flechas podemos a\u00f1adir o eliminar elementos a la lista aunquw a partir del cuarto se repite siempre el mismo. Para crear una lista vac\u00eda () basta con eliminar el \u00fanico elemento existente cuando se crea una nueva.</li> <li> Une (concatena) cadenas, listas o matrices de bytes y devuelve el resultado.</li> <li> Devuelve el car\u00e1cter Unicode del n\u00famero dado.</li> <li> Devuelve el en\u00e9simo elemento de una lista, cadena o matriz de bytes.</li> <li>  Combina los elementos de una lista en una cadena, opcionalmente se puede usar un car\u00e1cter delimitador.</li> <li>  A\u00f1ade un elemento al final de una lista.</li> </ul> <p>En el ejemplo siguiente vemos el uso de estos bloques. Comenzamos por crear una cadena de caracteres de la que vamos a extraer la palabra un mediante la uni\u00f3n de los elementos 9 y 10 de la cadena. Se crea una lista con cuatros animales y finalmente se muestra la palabra 'un' seguida de la posici\u00f3n 3 de la lista creada.</p> <p> <p> Un pajaro</p> <p></p> <p>Descargar el programa</p> <p>En este otro ejemplo vemos como se generan los caracteres de lat\u00edn b\u00e1sico comenzando por el espacio en blanco (32), diferentes s\u00edmbolos, n\u00fameros, letras may\u00fasculas y letras min\u00fasculas.</p> <p> <p> Caracteres Unicode de Lat\u00edn b\u00e1sico</p> <p></p> <p>Descargar el programa</p> <ul> <li> Devuelve el n\u00famero de elementos de una lista, cadena o matriz de bytes.</li> <li> Sustituye el en\u00e9simo elemento de una lista por el valor dado. Tambi\u00e9n puede sustituir todos los elementos por un valor.</li> <li> Elimina el elemento N de una lista. La lista resultante se reduce de tama\u00f1o. Tambi\u00e9n puede eliminar todos los elementos.</li> </ul> <p>A continuaci\u00f3n vemos un ejemplo en el que se demuestra la funcionalidad de estos tres bloques.</p> <p> <p> Sustituir, eliminar y tama\u00f1o</p> <p></p> <p>Descargar el programa</p> <ul> <li> Devuelve la posici\u00f3n de la primera coincidencia de una subcadena dentro de una cadena o un elemento de una lista. Devuelve -1 si no encuentra coincidencias.</li> </ul> <p>En el ejemplo las variables locales <code>cadena</code> y <code>animales</code> se inicializan como de tipo string y list respectivamente. El primer conjunto de resultados opera sobre la cadena, buscando la posici\u00f3n de la primera apariciones de \"es\". La primera coincidencia se encuentra en el car\u00e1cter n\u00famero uno. La segunda b\u00fasqueda se inicia en el car\u00e1cter n\u00famero tres, y localiza el objetivo de la b\u00fasqueda en el car\u00e1cter n\u00famero seis. La b\u00fasqueda de \"perro\" en la lista 'animales' la encuentra en el elemento n\u00famero dos de la lista. La segunda b\u00fasqueda de \"perro\" en la lista 'animales' comienza en el elemento n\u00famero tres y devuelve -1 porque no lo encuentra. No hay ning\u00fan \"raton\" en la lista, por lo que la b\u00fasqueda devuelve -1.</p> <p> <p> Buscar</p> <p></p> <p>Descargar el programa</p> <ul> <li> Copia una cadena desde/hasta el caracter especificado, o una desde/hasta el elemento indicado. Como ya sabemos para mostrar el par\u00e1metro hasta hay que hacer clic en el tri\u00e1ngulo negro.</li> </ul> <p> <p> Copiar</p> <p></p> <p>Descargar el programa</p> <ul> <li> Devuelve una lista separando la cadena especificada por el delimitador opcional. Si no se especifica ning\u00fan delimitador, la cadena se divide por cada car\u00e1cter.</li> </ul> <p>En la imagen vemos una cadena delimitada por comas que separa los caracteres mediante el delimitador coma en una lista de tres elementos.</p> <p> <p></p> <p></p> <p>A continuaci\u00f3n vemos una cadena que incluye un car\u00e1cter retorno de l\u00ednea despu\u00e9s del ABC y DEF que se separa mediante el caracter unicode de nueva l\u00ednea (return) en una lista de tres elementos.</p> <p> <p></p> <p></p> <p>En este otro caso separamos la URL de la descarga de MicroBlocks en partes mediante el delimitador /.</p> <p> <p></p> <p></p> <ul> <li>  Devuelve el valor Unicode del car\u00e1cter en\u00e9simo de la cadena introducida. El n\u00famero de caracteres introducido debe estar comprendido entre uno y la longitud de la cadena. Este bloque es el opuesto de .</li> </ul> <p> <p></p> <p></p> <ul> <li> Crea una nueva lista del n\u00famero de elementos especificado. Hay que controlar la disponibilidad de memoria. Los elementos de la lista creada se pueden inicializar a cualquier valor utilizando la opci\u00f3n de bloque con todos.</li> <li> Crea una matriz del n\u00famero de elementos especificado en funci\u00f3n de la disponibilidad de memoria. Cada elemento es de tama\u00f1o byte y se le pueden asignar valores en el rango de 0-255 (0-FF).</li> <li> Devuelve una cadena que indica el n\u00famero de palabras de 32 bits de memoria din\u00e1mica disponibles para asignar nuevos objetos (cadenas, listas o matrices de bytes). Al pulsar el bot\u00f3n de parada se libera toda la memoria. Justo despu\u00e9s de pulsar el bot\u00f3n de parada, este bloque informa del total de memoria din\u00e1mica disponible en un dispositivo determinado. Los dispositivos tienen diferentes cantidades de memoria din\u00e1mica, basadas en la cantidad de RAM proporcionada por el hardware. Por ejemplo, la micro:bit v2 tiene mucha m\u00e1s RAM que la micro:bit original.</li> </ul> <p>Un ejemplo de uso.</p> <p> <p> Copiar</p> <p></p> <p>Descargar el programa</p> <ul> <li>  Convierte un byte, una lista o una cadena especificada en una matriz de bytes. Cada elemento es el valor unicode de las letras de la cadena en el rango de 0-255 (0-FF).</li> </ul>"},{"location":"programacion/ublocks/#operadores_1","title":"Operadores","text":"<p>Los operadores a\u00fan no vistos son:</p> <p> <p></p> <p>Operadores aritm\u00e9ticos, de comparaci\u00f3n y booleanos</p> <p></p> <p>Los operadores aritm\u00e9ticos y de comparaci\u00f3n no requieren de mayor explicaci\u00f3n por lo que nos vamos a centrar en los booleanos.</p> <ul> <li> Operador booleano <code>True</code> o <code>False</code>. Devuelve verdadero o falso en funci\u00f3n de la posici\u00f3n del selector, o de la evaluaci\u00f3n binaria de la expresi\u00f3n utilizada como entrada. Este bloque se usa dentro de muchos otros bloques, donde se utiliza para controlar el flujo de las ejecuciones y eventos.</li> </ul> <p>El bloque <code>if</code> es un buen ejemplo para demostrar el uso del bloque verdadero/falso.</p> <p> <p></p> <p>Uso sencillo del operador <code>True/False</code></p> <p></p> <p>Descargar el programa</p> <p>El c\u00f3digo del ejemplo se ejecuta de dos maneras diferentes siempre dentro de un bucle infinito en el que se genera un n\u00famero aleatorio que puede valer 1, 2 o 3:</p> <ul> <li>La primera es la condici\u00f3n de la rama <code>IF</code> que ser\u00e1 verdadera si el n\u00famero generado es 1.</li> <li>La segunda es la rama <code>ELSE IF</code> que se eval\u00faa si la condici\u00f3n del <code>IF</code> no es verdadera y se pone a verdadero, ejecutando su c\u00f3digo.</li> <li> <p>La tercera es la condici\u00f3n <code>ELSE</code> a la que nunca se llega porque si el n\u00famero vale 1 se ejecuta el <code>IF</code> y si no se ejecuta el <code>ELSE IF</code> que siempre es cierto. Es decir, aunque se genere <code>variable = 3</code> la condici\u00f3n <code>ELSE</code> no se ejecuta.</p> </li> <li> <p> Invierte el valor l\u00f3gico asociado a la expresi\u00f3n sobre la que opera. Tal y como se muestra, <code>NOT</code> devolver\u00e1 <code>FALSE</code> si el deslizador se establece en <code>TRUE</code>, y <code>TRUE</code> si se establece en <code>FALSE</code>.</p> </li> </ul> <p>En el ejemplo siguiente, una variable llamada <code>cadena</code> se inicializa como \"MicroBlocks es genial\", y una variable llamada <code>expresion</code> se inicializa en <code>TRUE</code> de una forma peculiar, diciendo que algo es igual a si mismo. Cuando se aplica <code>NOT</code> al resultado de la expresi\u00f3n de igualdad, se cambia a <code>FALSE</code>.</p> <p> <p></p> <p>Uso sencillo del operador <code>NOT</code></p> <p></p> <p>Descargar el programa</p> <ul> <li>  Devuelve verdadero s\u00f3lo si todas sus entradas son verdadero y devuelve falso en caso contrario. Como ambas condiciones tienen que ser verdaderas para obtener un resultado verdadero, si se detecta un falso en la primera condici\u00f3n, no es necesario evaluar la segunda; se devuelve falso inmediatamente.</li> </ul> <p>En el ejemplo tenemos dos variables <code>salir</code> y <code>llueve</code> que se inicializan a verdadero. Se muestran una serie de mensajes y al final se eval\u00faa si \"necesito un paraguas\" comprobando si es voy a salir y si llueve. Ambas condiciones tienen que ser verdaderas para que necesitemos un paraguas. Podemos cambiar el estado de las variables y comprobar lo que ocurre.</p> <p> <p></p> <p>Uso sencillo del operador <code>AND</code></p> <p></p> <p>Descargar el programa</p> <ul> <li>  Devuelve verdadero si uno o ambos operandos son verdaderos y devuelve falso en caso contrario. Similar a <code>AND</code> pero opuesto a \u00e9l, aqu\u00ed s\u00f3lo una de las dos condiciones tiene que ser verdadera para un resultado verdadero. Por lo tanto, si la primera condici\u00f3n es verdadera, no es necesario comprobar la segunda.</li> </ul> <p>En el ejemplo estamos generando aleatoriamente dos n\u00fameros en el rango de 1 a 5. A continuaci\u00f3n, comprobamos si alguno de los dos n\u00fameros es igual al n\u00famero que estamos buscando (3). El bloque <code>OR</code> se utiliza para verificar el resultado de la comparaci\u00f3n.</p> <p> <p></p> <p>Uso sencillo del operador <code>OR</code></p> <p></p> <p>Descargar el programa</p> <p>Cada vez que pulsemos en 'Iniciar' se genera un nuevo resultado.</p>"},{"location":"programacion/ublocks/#bloques-de-control","title":"Bloques de control","text":"<ul> <li>  Los bloques en este bloque de sombrero se ejecutan cuando se pulsan los botones A, B, o A+B. Se dispara una vez por cada pulsaci\u00f3n de bot\u00f3n. Si se mantiene pulsado el bot\u00f3n, no se vuelve a disparar hasta que se suelta el bot\u00f3n y se vuelve a pulsar. Por ejemplo, cuando se pulsa el bot\u00f3n A aparece en pantalla una A.</li> </ul> <p> <p></p> <p>cuando se pulsa el bot\u00f3n</p> <p></p> <ul> <li>  El bloque <code>IF</code> comprueba la condici\u00f3n booleana y ejecuta los bloques de una sola vez si la condici\u00f3n booleana se eval\u00faa como verdadera. El tri\u00e1ngulo negro permite la expansi\u00f3n del bloque <code>IF</code> con m\u00faltiples condiciones <code>ELSE IF</code> a\u00f1adidas. En caso de que las ramas <code>IF</code> o <code>ELSE IF</code> anteriores no sean verdaderas, entonces se eval\u00faan y ejecutan sucesivamente cada una de las siguientes <code>ELSE IF</code>.</li> </ul> <p>En el ejemplo, a la variable <code>aleatorio</code> se le asigna un n\u00famero al azar entre el 1 y el 10. La operaci\u00f3n MOD se utiliza para sondear el estado par/impar del n\u00famero. Si el resto de la operaci\u00f3n num dividido por 2 da como resultado 0, el n\u00famero es par, en caso contrario es impar.</p> <p> <p></p> <p>Sentencia <code>IF</code></p> <p></p> <p>Descargar el programa</p> <p>Cada vez que pulsemos en 'Iniciar' se genera un nuevo resultado.</p> <ul> <li>  El bloque 'cuando' comprueba repetidamente una condici\u00f3n booleana. Cuando la condici\u00f3n se convierte en verdadera, se ejecutan los bloques bajo el sombrero. Si la condici\u00f3n sigue siendo verdadera al final de la ejecuci\u00f3n, entonces los bloques se ejecutar\u00e1n de nuevo, y ese proceso se repite hasta que la condici\u00f3n se convierte en falsa.</li> </ul> <p>Nota: El sombrero 'cuando' incluye una espera de 10 milisegundos entre ciclos. Esto es \u00fatil para eliminar ruido en las entradas, por ejemplo rebotes en los botones, pero limita el rendimiento a un m\u00e1ximo de 100 iteraciones/segundo.</p> <p>Vamos a ver el mismo ejemplo que en el bloque <code>IF</code> pero utilizando este bloque. Los tres bloques del tipo <code>WHEN</code> empiezan a funcionar simult\u00e1neamente cuando se pulsa el icono <code>START</code>. El bloque 'por siempre' debajo de 'al empezar' genera un n\u00famero aleatorio cada segundo. Y de forma simultanea los otros dos bloques evaluan continuamente sus condiciones mostrando el resultado que corresponde a cada uno.</p> <p> <p></p> <p>Bloque 'cuando'</p> <p></p> <p>Descargar el programa</p> <ul> <li>  Este bloque de control pausa la ejecuci\u00f3n del programa y espera hasta que la condici\u00f3n booleana especificada se convierta en verdadera. Se puede utilizar para sincronizar bloques de c\u00f3digo que se ejecutan en paralelo, bas\u00e1ndose en los eventos monitorizados.</li> </ul> <p>En este ejemplo, el nivel de luz ambiental se controla mediante el sensor de luz integrado. El sensor de luz tiene un rango de 0-255, siendo 0 oscuridad total y 255 claridad m\u00e1xima. Cuando se inicia el programa, ambos bloques 'cuando se pulse el boton' comienzan a ejecutarse y a comprobar el estado del bot\u00f3n.</p> <p>Al pulsar el bot\u00f3n A, se inicia la monitorizaci\u00f3n de la luz y el programa espera hasta que los sensores de la micro:bit informen de un nivel de luz &lt; 75. Cuando esa condici\u00f3n se cumple, se emite una alerta para avisar de que hay que encender las luces.</p> <p>El bot\u00f3n B est\u00e1 programado para detener el proceso de monitorizaci\u00f3n. Al pulsarlo, detiene la ejecuci\u00f3n de esa rama del programa.</p> <p> <p></p> <p>Bloque 'cuando se pulsa el boton'</p> <p></p> <p>Descargar el programa</p> <p>El bloque 'nivel de luz' se encuentra en la libreria 'Sensores b\u00e1sicos' y el bloque 'deten las otras tareas' se explica un poco mas abajo.</p> <ul> <li> <p>  El bloque <code>RETURN</code> se utiliza para devolver el valor especificado en su \u00e1rea de entrada. El valor retornado puede ser cualquier tipo de dato. Aunque es posible utilizar el bloque <code>RETURN</code> en cualquier parte de un programa para mostrar un valor, de forma similar al bloque <code>di</code>, su uso correcto y m\u00e1s com\u00fan es en una funci\u00f3n (o bloque personalizado) para devolver un valor como resultado del proceso realizado. Hay que tener en cuenta que los bloques colocados despu\u00e9s del bloque <code>RETURN</code> no se ejecutar\u00e1n.</p> </li> <li> <p>  Este bloque tipo C es un bucle que se utiliza para ejecutar los bloques colocados dentro de \u00e9l, hasta que la condici\u00f3n booleana especificada se convierte en verdadera. En ese momento, se ejecutar\u00e1 el siguiente bloque despu\u00e9s del bloque en forma de C.</p> </li> </ul> <p>En el ejemplo vemos como se monitoriza si se ha pulsado el bot\u00f3n A enviando un mensaje</p> <p> <p></p> <p>Bloque 'repetir hasta que'</p> <p></p> <ul> <li>  Este bloque, y su par relacionado , se utilizan para controlar el hilo de ejecuci\u00f3n del programa. Este bloque detiene la ejecuci\u00f3n de todos los bloques de los que forma parte, o que est\u00e1n bajo el mismo bloque sombrero. Una vez ejecutado este bloque en un grupo de bloques, no se ejecutar\u00e1 nada m\u00e1s en ese grupo.</li> </ul> <p>En el ejemplo, el grupo de bloques de la derecha est\u00e1 en un bucle continuo que cuenta hacia atr\u00e1s y decrementa su variable local <code>numero</code>. El grupo de bloques de la izquierda tambi\u00e9n est\u00e1 en un bucle continuo, contando hacia abajo y decrementando su variable local <code>numero</code>. Cuando la cuenta atr\u00e1s alcanza el valor 7 se cumple la condici\u00f3n del <code>else if</code> y se detiene la cuenta del bloque derecho, mientras que la secuencia del bloque izquierdo continua su ejecuci\u00f3n hasta que se cumpla la condici\u00f3n del <code>if</code> que ser\u00e1 cuando se alcance el n\u00famero 2, momento en que se detiene esta tarea.</p> <p>Podemos comprobar como el \u00faltimo bloque <code>di</code> de la secuencia de la izquierda NUNCA se ejecuta porque una vez que el bloque 'deten esta tarea' se ejecuta, todas las actividades de este bloque izquierdo terminan.</p> <p> <p></p> <p>Bloques 'deten esta tarea' y 'deten las otras tareas'</p> <p></p> <p>Podemos observar como desaparece el marco verde de cada bloque cuando su tarea finaliza indicando precisamente eso, que el bloque no se est\u00e1 ejecutando.</p> <p>Descargar el programa</p>"},{"location":"programacion/ublocks/#bloques-de-entrada-para-los-botones","title":"Bloques de 'Entrada' para los botones","text":"<ul> <li> y   Devuelve el estado del bot\u00f3n A o B. <code>true</code> = pulsado y <code>false</code> = no pulsado.</li> <li> equivalente al bloque  cuando lo configuramos con el pin 26, que es el correspondiente al logotipo .  Devuelve el estado del logo. <code>true</code> si lo tocamos (equivale a pulsador A o B pulsado) y <code>false</code> cuando no lo tocamos. Estos bloques est\u00e1n disponibles dentro la 'Libreria' 'Sensores[ ]' y aparece como 'Touch (microbit)'. El bloque para configurar el n\u00famero de pin tiene su sentido en la existencia de sensores t\u00e1ctiles en el borde de placa, como veremos mas adelante.</li> </ul> <p>En el ejemplo vemos como chequear el estado de los botones mediante la sentencia <code>IF</code>.</p> <p> <p></p> <p>Bloques para chequear el estado de los botones</p> <p></p> <p>Descargar el programa</p>"},{"location":"programacion/ublocks/#graficado-de-datos","title":"Graficado de datos","text":"<p>En MicroBlocks es relativamente sencillo trabajar los datos de forma gr\u00e1fica y para ello disponemos de un bloque para indicar el dato que queremos ver de manera gr\u00e1fica y un icono en el men\u00fa que abre la ventana flotante 'Gr\u00e1fico de datos'.</p> <p> <p> Bloque e icono para mostrar 'Gr\u00e1fico de datos'</p> <p></p>"},{"location":"programacion/ublocks/#bloque","title":"Bloque","text":"<p>Est\u00e1 disponible en el men\u00fa 'Salida'.</p> <ul> <li>. Graficar\u00e1 el valor introducido, en el panel de visualizaci\u00f3n de gr\u00e1ficos de datos. Se puede graficar cualquier tipo de dato: n\u00fameros, valores de pines digitales y anal\u00f3gicos, salidas de sensores, etc. Si tenemos que representar gr\u00e1ficamente m\u00e1s de un dato, hacemos clic en el tri\u00e1ngulo negro para mostrar campos de datos adicionales. Se pueden graficar hasta seis valores simult\u00e1neos con diferentes colores.</li> </ul> <p>La representaci\u00f3n gr\u00e1fica s\u00f3lo es posible en el IDE. Por lo tanto, s\u00f3lo es posible realizar gr\u00e1ficos mientras el microdispositivo est\u00e1 conectado al ordenador. Si intentamos realizar un gr\u00e1fico mientras no est\u00e1 conectado al ordenador, aparecer\u00e1 el mensaje \"Placa no conectada\".</p>"},{"location":"programacion/ublocks/#panel-grafico","title":"Panel gr\u00e1fico","text":"<p>Se activa desde el icono y tiene el siguiente aspecto:</p> <p> <p> Panel 'Gr\u00e1fico de datos'</p> <p></p> <p>El panel Gr\u00e1ficos de datos muestra los valores utilizados con el bloque de gr\u00e1ficos. El eje y del panel puede escalarse utilizando los controles de zoom del propio panel, y el eje x se desplazar\u00e1 lateralmente a medida que se grafiquen m\u00e1s datos.</p> <p>La ventana de visualizaci\u00f3n del gr\u00e1fico se puede redimensionar con el control situado en la esquina inferior derecha y puede colocarse en cualquier lugar de la ventana del IDE.</p> <p>Tras el registro de cualquier dato, la ventana de visualizaci\u00f3n de gr\u00e1ficos puede cerrarse y abrirse, si es necesario, sin que se pierda ning\u00fan dato ni la imagen visualizada, aunque si pierde la reconfiguraci\u00f3n realizada en la misma, como la posici\u00f3n del cero, el tama\u00f1o, etc. Adem\u00e1s, es posible desconectar y volver a conectar el dispositivo en uso, sin perder los datos del gr\u00e1fico.</p> <p>En la animaci\u00f3n vemos como funciona lo indicado. El escalado con la lupa del menos amplia el rango de valores del eje y, con la lupa del mas lo disminuye y la lupa del igual restaura la situaci\u00f3n inicial tras el redimensionado de la ventana.</p> <p> <p> Funcionamiento de 'Gr\u00e1fico de datos'</p> <p></p>"},{"location":"programacion/ublocks/#opciones-del-panel-grafico","title":"Opciones del panel gr\u00e1fico","text":"<p>Se accede haciendo clic con el bot\u00f3n derecho del rat\u00f3n en cualquier zona del panel. Si tenemos el cursor del rat\u00f3n sobre la zona de las lupas no funcionar\u00e1.</p> <p> <p> Opciones de 'Gr\u00e1fico de datos'</p> <p></p> <p>El men\u00fa de opciones del gr\u00e1fico permite controlar la visualizaci\u00f3n de los ejes, as\u00ed como la importaci\u00f3n/exportaci\u00f3n de datos y el ajuste de la frecuencia de muestreo de datos.</p> <ul> <li>limpiar gr\u00e1fico. Borra cualquier gr\u00e1fico de la ventana de visualizaci\u00f3n de datos.</li> <li>cero abajo. Sit\u00faa el punto de origen del eje y en la parte inferior del \u00e1rea de visualizaci\u00f3n del gr\u00e1fico.</li> <li>exportar datos a archivo CSV. Permite guardar los datos del gr\u00e1fico en formato CSV. Se exportan los \u00faltimos diez mil (10000) valores.</li> <li>importar datos desde archivo CSV. Permite cargar datos CSV desde el ordenador en el que se est\u00e1 ejecutando MicroBlocks. Los datos importados se grafican y se muestran en el 'Gr\u00e1fico de datos'. Es posible importar 10000 valores. Si tenemos mas de un dato para graficar, estos no se exportan individualmente sino todos juntos eparados por comas.</li> <li>copiar datos del gr\u00e1fico al portapapeles. Se trata de una funci\u00f3n avanzada que permite copiar en el portapapeles los \u00faltimos 10000 valores utilizados con el bloque gr\u00e1fico.</li> <li>ajustar latencia del puerto serie. Se trata de otro funci\u00f3n avanzada que permite establecer la frecuencia de muestreo de datos o latencia entre 1 y 20ms. Los n\u00fameros m\u00e1s bajos dan como resultado frecuencias de muestreo m\u00e1s altas.</li> </ul> <p>Los archivos CSV (del ingl\u00e9s comma-separated values) son un tipo de documento no estandarizado que tiene la idea b\u00e1sica de separar los campos de datos por una coma, de ah\u00ed su nombre Valores separados por comas</p> <p>Vamos a ver un ejemplo de uso en el que se muestran de forma gr\u00e1fica una serie de n\u00fameros aleatorio entre 1 y 100. El programa y el gr\u00e1fico son:</p> <p> <p> Ejemplo de 'Gr\u00e1fico de datos'</p> <p></p> <p>Descargar el programa</p>"},{"location":"programacion/ublocks/#pines","title":"Pines","text":"<p>En el men\u00fa 'Pines' disponemos de seis bloques que vamos a describir a continuaci\u00f3n.</p> <ul> <li>. Devuelve el valor (verdadero o falso) del pin digital indicado. Podemos acceder a la configuraci\u00f3n pullup 'true/false' haciendo clic en el tri\u00e1ngulo negro del extremo derecho, que se expande a  sin pullup o bien  con pullup. La configuraci\u00f3n pullup a <code>true</code> fuerza la se\u00f1al alta en caso de fluctuaciones de tensi\u00f3n en el pin.</li> </ul> <p>Vamos a ver un ejemplo de uso del bloque. El pin digital P0 lo leemos continuamente y los resultados se muestran y grafican mientras se va mostrando si el pin est\u00e1 en estado cero (false) o uno (true). El pullup est\u00e1 activado por lo que el estado normal de la l\u00ednea es true o alto. El programa es:</p> <p> <p> Ejemplo de uso del bloque 'lectura digital'</p> <p></p> <p>Descargar el programa</p> <p>En la animaci\u00f3n vemos el programa en funcionamiento y podemos observar los cambios de estado tanto en modo texto como en modo gr\u00e1fico.</p> <p> <p> Ejemplo de uso del bloque 'lectura digital'</p> <p></p> <ul> <li>. Devuelve el valor (0 - 1023) del pin anal\u00f3gico indicado. Devuelve el valor del pin anal\u00f3gico especificado como un n\u00famero en el rango 0-1023. Se puede acceder a la configuraci\u00f3n pullup true/false haciendo clic en el tri\u00e1ngulo negro del extremo derecho. El ajuste pullup fuerza la se\u00f1al a alto en caso de fluctuaciones de voltaje en el pin.</li> </ul> <p>Reutilizamos el ejemplo anterior cambiando el bloque por el de lectura anal\u00f3gica. El pin anal\u00f3gico 0 se lee continuamente y los resultados se muestran y se representan gr\u00e1ficamente. El pin 0 no est\u00e1 conectado a nada durante la prueba actuando como antena de la entrada anal\u00f3gica. El Pullup NO est\u00e1 habilitado, lo que significa que el estado de la se\u00f1al de la l\u00ednea fluct\u00faa constantemente.</p> <p> <p> Ejemplo de uso del bloque 'lectura anal\u00f3gica'</p> <p></p> <p>Descargar el programa</p> <p>En la animaci\u00f3n vemos el programa en funcionamiento y podemos observar los cambios de estado tanto en modo texto como en modo gr\u00e1fico.</p> <p> <p> Ejemplo de uso del bloque 'lectura anal\u00f3gica'</p> <p></p> <ul> <li>. Establece el valor (verdadero o falso) del pin digital indicado. Establece el estado del pin digital especificado como verdadero o falso. En un dispositivo de 3.3V, un valor alto pondr\u00e1 3.3V, y un valor bajo pondr\u00e1 0V en el pin.</li> </ul> <p>Se programan dos bucles, uno que se repite cinco veces para cambiar P0 entre 0 y 1 y el otro que se repite indefinidamente leyendo el estado del pin 1 y se representa graficamente. La lectura se hace en P1 porque se hacemos la lectura en P0 mientras est\u00e1 cambiando, podr\u00eda afectar a su estado. El circuito a montar es simplemente conectar con un cable P0 y P1.</p> <p> <p> Circuito para probar 'pon pin digital'</p> <p></p> <p>El programa es el siguiente:</p> <p> <p> Ejemplo de uso del bloque 'pon pin digital'</p> <p></p> <p>Descargar el programa</p> <p>En la animaci\u00f3n vemos el programa en funcionamiento y podemos observar los cambios de estado tanto en modo texto como en modo gr\u00e1fico.</p> <p> <p> Ejemplo de uso del bloque 'lectura anal\u00f3gica'</p> <p></p> <ul> <li>. Establece el valor (0 - 1023) del pin anal\u00f3gico indicado. Genera PWM en el pin indicado con valores de 0 a 1023. El PWM funciona encendiendo y apagando el pin r\u00e1pidamente. La potencia se controla variando el ciclo de trabajo o duty cycle, que es el porcentaje de tiempo durante cada ciclo que el pin est\u00e1 en alto. Un valor de 0 significa que el pin est\u00e1 apagado, mientras que un valor de 1023 significa que est\u00e1 a plena potencia (es decir, el pin est\u00e1 encendido el 100% del tiempo). Un valor de 512 da como resultado un ciclo de trabajo del 50%; que indica que el pin est\u00e1 encendido la mitad del tiempo y apagado la otra mitad.</li> </ul> <p>Cuando veamos alg\u00fan dispositivo anal\u00f3gico ser\u00e1 el momento de ver alg\u00fan ejemplo de uso de este bloque. Por ahora podemos ver este video de la documentaci\u00f3n oficial en el que se aprecia como se controla con PWM la velocidad de giro de un ventilador a partir de las variaciones que hagamos en un potenci\u00f3metro.</p> <ul> <li>. Devuelve el n\u00famero total de pines anal\u00f3gicos soportados por el dispositivo.</li> <li>. Devuelve el n\u00famero total de pines digitales soportados por el dispositivo.</li> </ul> <p>El programa siguiente muestra el tipo de dispositivo conectado y el tipo y n\u00famero de pines de que dispone.</p> <p> <p> Ejemplo de uso de los bloques 'pines anal\u00f3gicos y pines digitales'</p> <p></p>"},{"location":"programas/lista/","title":"Listado de programas","text":"<p>En la tabla siguiente se establecen todos los enlaces de manera individual y al final aparece un archivo zip con todos los programas de cada categoria.</p> <p>  MakeCode  MicroBlocks  Python .hex   Python .py Primer proyecto Primer proyecto Primer proyecto Primer proyecto microbit-A01-Hola_Mundo A01-Hola_Mundo.ubp A01-Hola_Mundo-main A01-Hola_Mundo-main A02-Coraz\u00f3n_latiendo A02-Corazon_latiendo.ubp A02-Corazon_latiendo A02-Corazon_latiendo A03-boton_pulsado A03-boton-pulsado.ubp A03-Boton_pulsado en hexadecimal A03-Boton_pulsado en Python <p>| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | |Comprimido de MakeCode|Comprimido de MicroBlocks|Comprimido de Python| <p></p> <p></p>"},{"location":"programas/lista/#t","title":"t","text":""},{"location":"proyectos/PA03/","title":"Proyecto de ampliaci\u00f3n actividad A03","text":"<p>Como proyecto de ampliaci\u00f3n de la actividad vamos a crear un programa que se est\u00e9 ejecutando en un bucle infinito y que responda, seg\u00fan pulsemos los botones, de la forma siguiente:</p> <ul> <li>Si pulsamos simultaneamente A y B en la pantalla aparecer\u00e1 el s\u00edmbolo siguiente: <ul> <li> check de Ok.</li> </ul> </li> <li>Si pulsamos el bot\u00f3n A mostrar\u00e1 una flecha apuntando a la izquierda</li> <li>Si pulsamos el bot\u00f3n B mostrar\u00e1 una flecha apuntando a la derecha</li> </ul> <p>Para micro:bit V1:</p> <ul> <li>Si no pulsamos ning\u00fan bot\u00f3n en la pantalla veremos un aspa</li> </ul> <p>Para micro:bit V2:</p> <ul> <li>Si disponemos de micro:bit V2 utilizaremos el logo para mostrar un aspa y si no pulsamos nada dejaremos la pantalla en negro</li> </ul>"},{"location":"proyectos/PA03/#micropython","title":"MicroPython","text":"<p>Estos son los enlaces para descargar el programa para micro:bit V1:</p> <ul> <li>PA03_V1 en .hex</li> <li>PA03_V1 en .py</li> </ul> <p>Estos son los enlaces para descargar el programa para micro:bit V2:</p> <ul> <li>PA03_V2 en .hex</li> <li>PA03_V2 en .py</li> </ul>"},{"location":"proyectos/PA03/#makecode","title":"MakeCode","text":"<p>Este es el enlace para descargar el programa para micro:bit V1:</p> <ul> <li>PA03_V1</li> </ul> <p>Este es el enlace para descargar el programa para micro:bit V2:</p> <ul> <li>PA03_V2</li> </ul>"},{"location":"proyectos/PA03/#microblocks","title":"MicroBlocks","text":"<p>Este es el enlace para descargar el programa para micro:bit V1:</p> <ul> <li>PA03_V1</li> </ul> <p>Este es el enlace para descargar el programa para micro:bit V2:</p> <ul> <li>PA03_V2</li> </ul>"}]}