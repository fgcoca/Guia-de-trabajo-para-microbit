{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introducci\u00f3n","text":"<p>Se pretende crear una gu\u00eda para trabajar con la tarjeta micro:bit mediante:</p> <ul> <li>Programaci\u00f3n gr\u00e1fica con: Makecode, Microblocks, Scratch, ...</li> <li>Programaci\u00f3n con MicroPython</li> </ul> <p>Comienzo por mostrar las versiones de placas micro:bit de una forma breve indicando sus principales diferencias y tambi\u00e9n introduzco diferenes accesorios y shield interesantes.</p> <p>Hablar\u00e9 de la soluci\u00f3n cuando tenemos problemas de descarga de los programas por el puerto USB y tambi\u00e9n de como actualizar o reponer el firmware en la placa micro:bit</p>"},{"location":"#descripcion-grafica","title":"Descripci\u00f3n gr\u00e1fica","text":"<p>En la imagen siguiente vemos la descripci\u00f3n del hardware de la micro:bit 1.3.</p> <p> <p> Hardware micro:bit 1.3</p> <p></p> <p>En la siguiente imagen tenemos la descripci\u00f3n de hardware para la versi\u00f3n 2 que incluye importantes novedades ya que incorpora un pulsador t\u00e1ctil como sensor en el logo, un micr\u00f3fono con indicador LED, un altavoz, LED indicador de actividad USB y una LED indicador de alimentaci\u00f3n.</p> <p> <p> Hardware micro:bit 2</p> <p></p> <ul> <li>El conector microUSB nos servir\u00e1 para programar mediante la t\u00e9cnica de arrastrar y soltar, depurar mediante CMSIS-DAP y ello gracias a que integra webUSB para permitir que podamos conectar nuestra micro:bit a la web mediante el puerto USB</li> <li>Los pads con agujero permiten la conexi\u00f3n mediante pinzas de cocodrilo o conectores tipo banana.</li> <li>La antena de 2.4 GHz sirve para BLE (Bluetooth Low Energy) y transmisi\u00f3n de radio.</li> </ul>"},{"location":"#novedades-v2-y-diferencia-con-v1","title":"Novedades V2 y diferencia con V1","text":"<p>La novedad mas importante de la nueva tarjeta micro:bit V2 es que incorpora un procesador mas potente que su predecesora. Tambi\u00e9n incorpora indicador de bater\u00eda,  micr\u00f3fono, altavoz y un sensor t\u00e1ctil en el logotipo que aumentan sus posibilidades de utilizaci\u00f3n. En la imagen siguiente se se\u00f1alan los nuevos elementos.</p> <p> <p> Novedades micro:bit 2</p> <p></p> <p>Las principales diferencias con micro:bit V1 quedan descritas a continuaci\u00f3n:</p> <ul> <li> <p>El logo es un bot\u00f3n t\u00e1ctil. Se trata de un bot\u00f3n t\u00e1ctil capacitivo que nos da la posibilidad de pulsar de cuatro maneras diferentes, bot\u00f3n A, bot\u00f3n B, bot\u00f3n A y bot\u00f3n B a la vez y bot\u00f3n t\u00e1ctil.</p> </li> <li> <p>Micr\u00f3fono. Se trata de un micro digital MEMS al que se asocia un indicador LED con el icono de un micr\u00f3fono. El t\u00e9rmino MEMS, del ingl\u00e9s MicroElectroMechanical Systems, se refiere a la tecnolog\u00eda electromec\u00e1nica de dispositivos microsc\u00f3picos o sistemas microelectromec\u00e1nicos.</p> </li> <li> <p>Modo ahorro de energ\u00eda. Esta nueva funci\u00f3n de ahorro o modo de espera detendr\u00e1 el programa que se est\u00e9 ejecutando en la micro:bit hasta que se pulse el bot\u00f3n de reinicio.</p> </li> <li> <p>Altavoz. Permite incorporar sonidos a nuestros proyectos.</p> </li> </ul> <p>La microbit v2 tiene cuatro veces mas posibilidades de procesamiento y ocho veces mas memoria RAM que micro:bit V1, y esto gracias a la incorporaci\u00f3n de un procesador nRF52833 ARM Cortex de 64 MHz.</p> <p>Incorpora 512 KB de memoria Flash y 128 KB de memoria RAM.</p>"},{"location":"#hardware-microbit-v2","title":"Hardware micro:bit V2","text":"<p>En la imagen siguiente tenemos una descripci\u00f3n gr\u00e1fica de todos los elementos que integra la micro:bit v2 en sus vistas frontal y posterior.</p> <p> <p> Hardware micro:bit 2</p> <p></p>"},{"location":"#procesador-nrf52","title":"Procesador nRF52","text":"<p>Es donde se ejecutan los programas de usuario. El nRF52 proporciona todos los pines GPIO accesibles para el usuario. Hay integrado un perif\u00e9rico de radio de 2.4GHz que se utiliza para proporcionar capacidades de radio y de Bluetooth. En la tabla siguiente vemos sus principales caracter\u00edsticas.</p> <p> Item Detalles Modelo Nordic nRF52833 Variante del n\u00facleo Procesador Arm Cortex-M4 de 32 bit con FPU Memoria Flash ROM 512 KB Memoria RAM 128 KB Velocidad 64 MHz <p></p>"},{"location":"#comunicacion-inalambrica-bluetooth","title":"Comunicaci\u00f3n inal\u00e1mbrica Bluetooth","text":"<p>El dispositivo integrado de 2,4 GHz Nordic S113 admite comunicaciones Bluetooth a trav\u00e9s del dispositivo de bajo consumo (BLE), permitiendo comunicar la micro:bit con dispositivos Bluetooth como tel\u00e9fonos inteligentes y tabletas.</p> <p> Item Detalles Pila (stack) Bluetooth 5.1 con Bluetooth de bajo consumo (BLE) Banda 2.4GHz ISM (Industrial, Scientific and Medical) 2.4GHz..2.41GHz Canales 50 de 2MHz. Uitilizados del 0 al 39 Sensibilidad -93 dBm en modo BLE Potencia de transmisi\u00f3n -40 dBm a 4 dBm Perfiles BBC micro:bit profile Mas informaci\u00f3n Bluetooth <p></p>"},{"location":"#radiocomunicaciones-de-bajo-nivel","title":"Radiocomunicaciones de bajo nivel","text":"<p>El transceptor integrado de 2,4 GHz soporta una serie de est\u00e1ndares de comunicaciones por radio sobre los que est\u00e1 construido el protocolo de radio micro:bit. Este protocolo proporciona una interfaz de radio sencilla de transmisi\u00f3n de peque\u00f1os paquetes con otros dispositivos que lo admiten, como por ejemplo, otras micro:bit.</p> <p> Item Detalles Protocolo Radio micro:bit Banda de frecuencia 2.4GHz Velocidad de canal 1 Mbps o 2 Mbps Encriptaci\u00f3n Ninguna Canales 80 (0...80) C\u00f3digos de grupo 255 Potencia de transmisi\u00f3n Ocho valores configurables por el usuario, 0 (-30 dbm) a 7 (+4 dbm) Tama\u00f1o de carga 32 (est\u00e1ndar) o 255 (si se configura) Mas informaci\u00f3n Radio micro:bit <p></p>"},{"location":"#botones","title":"Botones","text":"<p>Los dos botones de la parte frontal y el bot\u00f3n de la parte posterior son botones pulsadores normales. El bot\u00f3n de la parte posterior est\u00e1 conectado al procesador de interfaz KL27 y al procesador NRF52 para reiniciar el sistema. De esta forma se garantiza que la aplicaci\u00f3n se reiniciar\u00e1 independientemente de si se alimenta desde USB o desde una bater\u00eda.</p> <p>Los botones frontales A y B se pueden programar en la aplicaci\u00f3n de usuario con cualquier prop\u00f3sito. Los rebotes de A y B se eliminan por software, y tambi\u00e9n incluyen pulsaci\u00f3n corta, pulsaci\u00f3n larga y detecci\u00f3n de pulsaci\u00f3n simultanea de A y B. Los botones funcionan en modo el\u00e9ctrico invertido t\u00edpico, donde una resistencia pull-up asegura un '1' l\u00f3gico cuando se suelta el bot\u00f3n y un '0' l\u00f3gico cuando se pulsa el bot\u00f3n. Ambos botones est\u00e1n conectados a pines GPIO que tambi\u00e9n son accesibles en el conector de borde.</p> <p> Item Detalles Tipo Dos pulsadores de usuario y un pulsador de sistema Rebotes Se eliminan por software con periodos de 54 ms Pullup Los botones A y B con resistencias externas de 4K7 y el de sistema con 10K <p></p>"},{"location":"#pantalla","title":"Pantalla","text":"<p>La pantalla es una matriz de LED de 5x5. El software en tiempo de ejecuci\u00f3n actualiza repetidamente esta matriz a alta velocidad, de modo que est\u00e1 dentro del rango de persistencia visual del usuario y no se detecta parpadeo. Esta matriz de LED tambi\u00e9n se utiliza para detectar luz ambiental.</p> <p> Item Detalles Tipo LED rojo miniatura de montaje Estructura f\u00edsica Matriz de 5x5 Estructura el\u00e9ctrica 5x5 Control de intensidad Control de hasta 255 pasos por software Sensibilidad Estimaci\u00f3n de luz ambiente por algoritmo de software Rango de sensibilidad 10 niveles, de apagado a luminosidad total Sensibilidad de color centro del rojo (700 nm) <p></p>"},{"location":"#sensor-de-movimiento","title":"Sensor de movimiento","text":"<p>La micro:bit dispone de un chip que combina aceler\u00f3metro y magnet\u00f3metro proporcionando as\u00ed detecci\u00f3n de movimiento en 3 ejes y de campo magn\u00e9tico. Incluye detecci\u00f3n de gestos en el hardware (como por ejemplo de ca\u00eddas) y detecci\u00f3n adicional de gestos (por ejemplo, logotipo arriba, logotipo abajo, agitaci\u00f3n) a trav\u00e9s de software. Un algoritmo de software en tiempo de ejecuci\u00f3n utiliza el aceler\u00f3metro integrado para convertir las lecturas en una br\u00fajula independiente de la orientaci\u00f3n de la placa. La br\u00fajula debe calibrarse antes de su uso, y el software en tiempo de ejecuci\u00f3n inicia autom\u00e1ticamente el proceso de calibraci\u00f3n. Este dispositivo est\u00e1 conectado al procesador a trav\u00e9s del bus I2C.</p> <p> Item Detalles Modelo LSM303AGR Caracter\u00edsticas 3 campos magn\u00e9ticos y aceleraci\u00f3n en e ejes. Rangos 2/4/8/16g Resoluci\u00f3n 8/10/12 bits Gestos \"on board\" Ca\u00edda libre Otros gestos Se implementan por software en tiempo de ejecuci\u00f3n <p></p>"},{"location":"#deteccion-de-temperatura","title":"Detecci\u00f3n de temperatura","text":"<p>El procesador NRF52 tiene un sensor de temperatura integrado. Este se expone por software en tiempo de ejecuci\u00f3n y proporciona una estimaci\u00f3n de la temperatura ambiente.</p> <p> Item Detalles Rango de sensibilidad -40 \u00baC ... 105 \u00baC Resoluci\u00f3n Pasos de 0.25 \u00baC Precisi\u00f3n \u00b1 5 \u00baC (sin calibrar) Mas informaci\u00f3n Term\u00f3metro DAL <p></p>"},{"location":"#altavoz","title":"Altavoz","text":"<p>Adem\u00e1s de poder emitir sonido v\u00eda PWM por los pines, la micro:bit v2 incorpora un altavoz ya montado en la placa donde se puede reproducir sonido.</p> <p> Item Detalles Tipo JIANGSU HUANENG MLT-8530 SPL (Sound Pressure Level) 80dB @ 5V, 10cm Frecuencia de resonancia propia 2700Hz Mas informaci\u00f3n Datasheet <p></p>"},{"location":"#microfono","title":"Micr\u00f3fono","text":"<p>Un micr\u00f3fono MEMS (Micro -o nano- Electrical-Mechanical System) incorporado proporciona una entrada de sonido a la micro:bit y un indicador LED integrado en la parte frontal de la placa muestra al usuario cuando est\u00e1 encendido.</p> <p> Item Detalles Tipo Knowles SPU0410LR5H-QB-7 MEMS Sensibilidad -38dB \u00b13dB @ 94dB SPL Relaci\u00f3n se\u00f1al ruido (SNR) 63dB M\u00e1xima ganancia digital (AOP) 118dB SPL Rango de frecuencia 100Hz ... 80kHz Patr\u00f3n polar Omnidireccional Mas informaci\u00f3n Datasheet <p></p>"},{"location":"#pines-gpio","title":"Pines GPIO","text":"<p>Son pines de prop\u00f3sito general de entrada/salida (General Purpose Input/Output). En el conector de borde est\u00e1n muchos de los circuitos GPIO del procesador. Algunos de estos circuitos se comparten con otras funciones de la micro:bit, pero muchos pueden reasignarse para uso de prop\u00f3sito general si se desactivan algunas funciones del software.</p> <p> Item Detalles Anillos 3 de entrada/salida y 2 de alimentaci\u00f3n compatibles con banana de 4mm y pinza de cocodrilo Funciones GPIO 19 pines asignables GPIO 2 para interfaz I2C externa 6 para la pantalla o detecci\u00f3n de luz 2 para detectar los botones de la placa 1 reservado para interfaz de accesibilidad Los 19 se pueden asignar como entrada o salida digital Los 19 pueden asignarse para hasta 3 canales PWM simult\u00e1neos Los 19 se pueden asignar para transmisi\u00f3n serie y un canal de recepci\u00f3n serie 6 pueden asignarse como entrada anal\u00f3gica 3 pueden asignarse para comunicaci\u00f3n SPI 3 se pueden asignar para hasta 3 entradas de detecci\u00f3n t\u00e1ctil Resoluci\u00f3n conversor A/D 10 bits (0...1023). 2\u00b9\u2070=1024 Distancia entre pines 1.27mm, 80 vias a doble cara <p></p>"},{"location":"#alimentacion","title":"Alimentaci\u00f3n","text":"<p>La alimentaci\u00f3n de la micro:bit puede ser a trav\u00e9s de los 5V del conector USB o mediante una bater\u00eda de 3V enchufada al conector JST. Tambi\u00e9n es posible alimentar a la micro:bit desde los anillos 3V/GND en el conector de borde. Los anillos 3V/GND se pueden usar para suministrar energ\u00eda a circuitos externos. La placa utiliza un regulador de baja ca\u00edda o LDO especificado hasta 300 mA con corte t\u00e9rmico para protecci\u00f3n contra cortocircuitos.</p> <p> Item Detalles Rango de operaci\u00f3n 1.8V ... 3.6V Consumo de corriente 300mA m\u00e1ximo Asignado a perif\u00e9erico \"on board\" 90mA Conector de bater\u00eda JST X2B-PH-SM4-TB M\u00e1xima corriente prevista para el conector de borde 190mA Mas informaci\u00f3n Power Supply <p></p> <p>Especialmente cuando conectamos elementos externos a nuestra micro:bit es importante tener presentes los valores l\u00edmite de corriente debido a la m\u00e1xima corriente que puede suministrar la placa de manera segura.</p> <ul> <li>Corriente m\u00e1xima para el conector de borde es de 190 mA.</li> </ul>"},{"location":"#interface","title":"Interface","text":"<p>El chip de interfaz maneja la conexi\u00f3n USB y se usa para actualizar el c\u00f3digo nuevo en la micro:bit, enviar y recibir datos en serie de forma bidireccional.</p> <p> Item Detalles Modelo MKL27Z256VFM4 N\u00facleo Arm Cortex-M0+ Flash ROM 256KB (128KB reservados para uso como almacenamiento) RAM 16KB Velocidad 48MHz Depuraci\u00f3n SWD Mas informaci\u00f3n DAPLinkManual del KL27 datasheet KL27 <p></p>"},{"location":"#comunicaciones-usb","title":"Comunicaciones USB","text":"<p>La placa micro:bit tiene una pila de comunicaciones USB incorporada integrada en el firmware del chip de interface. Esta pila brinda la capacidad de arrastrar y soltar archivos en la unidad MICROBIT para cargar c\u00f3digo en el procesador. Tambi\u00e9n permite que los datos en serie se transmitan desde y hacia el procesador de micro:bit a trav\u00e9s de USB a un ordenador externo, y es compatible con el protocolo CMSIS-DAP para la depuraci\u00f3n de programas de aplicaci\u00f3n en el host.</p> <p> Item Detalles Conector USB micro, MCR-B-S-RA-SMT-CS5-TR Versi\u00f3n USB Dispositivo a velocidad completa 2.0 Velocidad 12Mbit/s Clases USB soportadas Clase de almacenamiento masivo (MSC) Clase dispositivo de comunicaciones (CDC) Mas informaci\u00f3n DAPLink <p></p>"},{"location":"#depuracion","title":"Depuraci\u00f3n","text":"<p>El procesador de interface se puede utilizar con herramientas de host especiales para depurar el c\u00f3digo que se ejecuta en el procesador de la aplicaci\u00f3n. Se conecta al procesador de aplicaciones a trav\u00e9s de 4 cables de se\u00f1al. El c\u00f3digo del procesador de la interfaz KL27 tambi\u00e9n se puede depurar a trav\u00e9s de su interfaz de depuraci\u00f3n del software SWD integral, por ejemplo, para cargar el c\u00f3digo del cargador de arranque inicial en este procesador en el momento de la fabricaci\u00f3n, o para recuperarlo si se ha perdido.</p> <p> Item Detalles Protocolo CMSIS-DAP Opciones JLink/OB (via different firmware) Mas informaci\u00f3n Mbed debugging micro:bit <p></p>"},{"location":"#mecanicos","title":"Mec\u00e1nicos","text":"<p>Hay disponibles algunos dibujos CAD 2D y 3D y modelos de la micro:bit que incluyen todas las dimensiones importantes. Estos modelos se pueden utilizar como base para generar im\u00e1genes de proyecto y marketing de micro:bit, pero tambi\u00e9n como base para la fabricaci\u00f3n precisa de accesorios, por ejemplo, mediante impresi\u00f3n 3D.</p> <p> Item Dimensiones Ancho 51,60 mm Alto 42,00 mm Profundidad 11,65 mm Altura del bot\u00f3n a la placa 4,55 mm Altura del altavoz 3 mm Conector JST 5,50 mm <p></p>"},{"location":"#conector-de-borde","title":"Conector de borde","text":"<p>Hay 25 pistas/patillas que incluyen 5 agujeros para usar con clavijas tipo banana de 4 mm o pinzas de cocodrilo. Tres de estos anillos son para entrada y salida de prop\u00f3sito general (GPIO) y tambi\u00e9n sirven para detecci\u00f3n anal\u00f3gica, PWM y t\u00e1ctil, y dos est\u00e1n conectados a la alimentaci\u00f3n de la micro:bit.</p> <p>Las pistas mas finas est\u00e1n separadas 1,27 mm, algunas son utilizadas por micro:bit y otras est\u00e1n disponibles para su uso mediante cualquiera de los conectores externos existentes.</p> <p>Solamente tienen conexi\u00f3n las pistas frontales, las posteriores est\u00e1n sin conexi\u00f3n y los anillos posteriores est\u00e1n conectados a los delanteros.</p> <p>En la imagen siguiente tenemos la descripci\u00f3n de pines de la micro:bit v2 a la izquierda y de la v1 a la derecha para poder comparar y establecer las diferencias de una forma sencilla.</p> <p> <p> Pinout micro:bit V2 y V1</p> <p></p> <p>En microbit.pinout.xyz tenemos un fant\u00e1stico recurso para obtener m\u00e1s informaci\u00f3n sobre los pines de la micro:bit y de c\u00f3mo los utilizan algunos accesorios.</p> <p>En en enlace tenemos una guia de accesorios para micro:bit</p>"},{"location":"#protectores","title":"Protectores","text":"<p>Existen en el mercado protectores para las micro:bit realizados en metacrilato transparente, silicona de distintos colores y formas y otros materiales. Estos elementos son f\u00e1ciles de encontrar en las tiendas que comercializan la placa.</p> <p>Aqu\u00ed daremos toda la informaci\u00f3n necesaria para personalizar e imprimir en 3D nuestros propios protectores.</p>"},{"location":"#microbit-v1","title":"micro:bit V1","text":"<p>Carcasa de protecci\u00f3n para la versi\u00f3n 1 de la tarjeta micro:bit basada en un dise\u00f1o de tatan.</p> <p>La base tiene el siguiente aspecto en fase de dise\u00f1o y montada:</p> <p> <p> Protector micro:bit V1</p> <p></p> <p>A continuaci\u00f3n se da el listado de ficheros de dise\u00f1o y de impresi\u00f3n 3D listos para descargar.</p> <p> Descripci\u00f3n Archivo Enlace Archivo de dise\u00f1o proteccionV1.FCStd Fuente Base en STL base.stl Base Tapa en STL tapa.stl Tapa Base STEP base.step Base Tapa STEP tapa.step Tapa <p></p>"},{"location":"#microbit-v2","title":"micro:bit V2","text":"<p>El modelo se inspira en el dise\u00f1o para microbit v1 de crozes ga\u00ebtan (tatan) y tiene el aspecto final que vemos en la animaci\u00f3n siguiente:</p> <p> <p> Partes del modelo 3D</p> <p></p> <p>En las im\u00e1genes siguientes vemos el aspecto que tiene la base por sus dos caras.</p> <p> Parte delantera de la base Parte trasera de la base <p></p> <p>En las im\u00e1genes siguientes vemos el aspecto que tiene la tapa por sus dos caras.</p> <p> Parte delantera de la tapa Parte trasera de la tapa <p></p> <p>En la tabla siguiente tenemos los archivos del proyecto listos para descargar.</p> <p> Descripci\u00f3n STL AMF STEP Base baseV2.stl baseV2.amf baseV2.step Tapa tapaV2.stl tapaV2.amf tapaV2.step <p></p> <p>Este es el enlace al archivo de dise\u00f1o en FreeCAD y este a la TTF utilizada para crear los letreros.</p> <p>El aspecto del protector una vez montado lo tenemos en la imagen siguiente.</p> <p> <p> Partes del modelo 3D</p> <p></p>"},{"location":"#enlaces","title":"Enlaces","text":"<p>Antes de poner un listado de enlaces interesantes diremos que BBC micro:bit es una placa programable de 4x5 cm de c\u00f3digo abierto que permite aprender a programar de una forma f\u00e1cil y divertida que est\u00e1 al alcance de todos.</p> <p>Dado que incorpora muchos sensores es posible realizar una cantidad importante de proyectos disponiendo solamente de la placa.</p> <p>BBC micro:bit se puede programar de muchas formas,</p> <ul> <li>De forma visual o por bloques mediante:<ul> <li>MakeCode de Microsoft, un editor gr\u00e1fico online gratuito.</li> <li>MicroBlocks, un lenguaje de programaci\u00f3n por bloques para aprender computaci\u00f3n f\u00edsica.</li> <li>Scratch (a\u00f1adiendo una extensi\u00f3n).</li> <li>Open Roberta Lab, un entorno de programaci\u00f3n en l\u00ednea para robots con el lenguaje de programaci\u00f3n gr\u00e1fico NEPO.</li> </ul> </li> <li>Mediante c\u00f3digo:<ul> <li>JavaScript, un lenguaje de programaci\u00f3n o de secuencias de comandos que permite implementar funciones complejas en p\u00e1ginas web din\u00e1micas.</li> <li>MicroPython, un peque\u00f1o pero eficiente interprete del lenguaje de programaci\u00f3n Python, optimizado para funcionar en microcontroladores.</li> <li>Python, lenguaje de programaci\u00f3n de alto nivel que no se compila, sino que se interpreta.</li> </ul> </li> </ul> <p>El c\u00f3digo interpretado necesita de un interprete, que se define como la capa l\u00f3gica de software que se pone entre el c\u00f3digo y el hardware, es decir, el interprete es el encargado de procesar el c\u00f3digo de programa y hacer posible que el hardware lo ejecute.</p> <p>Aqu\u00ed vamos a usar principalmente MakeCode, MicroBlocks y MicroPython, aunque se dar\u00e1n pinceladas con otros entornos. Tambi\u00e9n abordaremos en su momento el tema IoT utiliando la placa micro:bit.</p> <p>Enlaces muy importantes son:</p> <ul> <li>Web en ingl\u00e9s</li> <li>Web en espa\u00f1ol</li> <li>Comunidad micro:bit en espa\u00f1ol</li> <li>Github de microbit</li> <li>Comunidad de desarrollo de micro:bit. Wiki de la comunidad con informaci\u00f3n t\u00e9cnica de micro:bit.</li> <li>Editor gr\u00e1fico Makecode estable.</li> <li>Web de MicroBlocks</li> <li>Editor online de MicroBlocks</li> <li>Editor Python de micro:bit. Sencillo editor de c\u00f3digo basado en navegador.</li> <li>Mu. Sencillo editor de c\u00f3digo sin conexi\u00f3n.</li> <li>uFlash. Herramienta de l\u00ednea de comandos para mostrar secuencias de comandos de Python sin procesar en un micro:bit.</li> <li>IDLE. Un IDE de c\u00f3digo abierto multiplataforma que se instala por defecto con Python.</li> <li>BBC Micro:bit MicroPython documentation.</li> <li>Instalaci\u00f3n de Mu-editor en Linux, OSX y Window.</li> <li>Bot de programaci\u00f3n Open Roberta Lab.</li> <li>Thonny. Sencillo IDE para Python.</li> </ul>"},{"location":"configura/","title":"Configurar nuestra micro:bit","text":"<p>Para poder continuar le tenemos que decir a la micro:bit lo que queremos que haga. Esto es dar a la micro:bit una serie de instrucciones contenidas en programas. Estos programas, en el caso de micro:bit, se pueden escribir de diferentes maneras y nosotros vamos a ver fundamentalmente como hacerlo en los editores online de bloques MakeCode y MicroBlocks o Python de texto.</p> <p>Debemos disponer de un ordenador, un tel\u00e9fono o una tableta para escribir el c\u00f3digo, conectar la micro:bit a nuestro dispositivo lo que haremos de alguna de estas formas:</p> <ul> <li>Con ordenador. Es la forma mas usual y sencilla y consiste en utilizar un cable microUSB para realizar la conexi\u00f3n de la micro:bit al ordenador. Esta forma la vamos a describir de manera mas extensa a continuaci\u00f3n.</li> <li>Tel\u00e9fono o tableta. En este caso debemos utilizar Bluetooth para conectar ambos dispositivos de manera inal\u00e1mbrica. Podemos consultar mas detalles en Transferir desde la aplicaci\u00f3n m\u00f3vil, web que adem\u00e1s nos va a servir de referencia para el resto de este apartado.</li> </ul>"},{"location":"configura/#transferir-desde-ordenador","title":"Transferir desde ordenador","text":"<p>Los programas de usuario se copian en la memoria flash (no volatil) de la micro:bit por lo que a esta operaci\u00f3n se le suele conocer como flasheo. La V1 tiene 256 KB de memoria flash y la V2 512 KB</p> <p>Cuando se est\u00e1 flasheando un programa la micro:bit pausa la ejecuci\u00f3n del programa que tenga en memoria y el LED amarillo de la cara posterior estar\u00e1 parpadeando mientras se est\u00e9 copiando el nuevo programa. Una vez finalizada la copia, el nuevo programa comienza a ejecutarse en la micro:bit.</p>"},{"location":"configura/#arrastrar-y-soltar","title":"Arrastrar y soltar","text":"<p>El proceso es exactamente igual que cuando transferimos un archivo desde el ordenador a un pendrive o memoria USB y funciona en cualquier ordenador. Lo que tenemos que hacer es:</p> <ul> <li>Descargar el programa como un archivo .hex desde el editor de c\u00f3digo al ordenador, habitualmente al directorio de descargas. Finalmente se arrastra y suelta el archivo .hex en la unidad MICROBIT.</li> <li>Despu\u00e9s de transferir el archivo .hex, la unidad MICROBIT se desconectar\u00e1 y reconectar\u00e1 seg\u00fan la micro:bit se reinicia. El archivo .hex no aparecer\u00e1 en la unidad MICROBIT dado que la micro:bit no es un dispositivo de almacenamiento flash, aunque el ordenador lo muestra como tal para facilitar la transferencia de archivos .hex.</li> </ul> <p>En el enlace Transferir desde la aplicaci\u00f3n m\u00f3vil hay disponibles videos que muestran c\u00f3mo funciona este sistema. Simplemente elegimos nuestro sistema operativo (Windows, Mac, Chromebook o Linux/Raspberry Pi) y vemos el proceso.</p> <p>En la animaci\u00f3n siguiente (descarga de la web citada en el p\u00e1rrafo anterior) vemos el proceso completo en el caso de Linux.</p> <p> <p> Flasheo mediante arrastrar y soltar</p> <p></p>"},{"location":"configura/#flasheo-directo","title":"Flasheo directo","text":"<p>Se pueden enviar programas directamente desde los editores de c\u00f3digo en l\u00ednea a la micro:bit sin necesidad de descargar el archivo .hex y seguir el proceso anterior, lo que resulta f\u00e1cil y r\u00e1pido.</p> <p>El flasheo directo solamente funciona en los navegadores Chrome o Edge que soportan webUSB. Tambi\u00e9n es necesario tener actualizado el firmware de la micro:bit, especialmente si es un modelo que tiene mucho tiempo.</p> <p>IMPORTANTE: EL flasheo directo es r\u00e1pido y f\u00e1cil, y excelente para la depuraci\u00f3n, pero no SE guarda una copia del programa en el ordenador. Si pra nosotros es importante mantener una copia del c\u00f3digo, es preferible utilizar el m\u00e9todo de arrastrar y soltar, o en su defecto tener siempre la precauci\u00f3n de descargar el archivo .hex o .py o .ubp cuando se ha completado exit\u00f3samente el proyecto aunque durante el proceso se relicen pruebas del funcionamiento o depuraci\u00f3n del c\u00f3digo mediante este m\u00e9todo.</p> <p>En la web de referencia tenemos disponibles videos demostrativos de como se realiza el proceso.</p>"},{"location":"plantilla/","title":"Titulo","text":""},{"location":"plantilla/#t","title":"t","text":""},{"location":"plantilla/#t_1","title":"t","text":"<p> <p> xx</p> <p></p> <p>- Consejo: </p>"},{"location":"problemas/","title":"Soluci\u00f3n de problemas","text":"<p>Hay veces que surgen problemas con la descarga webUSB porque no se consigue emparejar la micro:bit y tambi\u00e9n pueden surgir problemas cuando intentamos hacerer drag &amp; drop (arrastrar y soltar) el archivo .hex en la unidad MICROBIT montada, o incluso puede que no se monte dicha unidad.</p> <p>Cuando el intento de conexi\u00f3n nos devuelve un error en el rango 500-599, normalmente se puede corregir reintentsando el envio del .hex nuevamente o borrar enviando el archivo hexadecimal de nuevo, o enviando el software original \"Out of box experience\", traducido literalmente como \"Fuera de la caja\" pero que se traduce como Experiencia inmediata. Al final de este tambi\u00e9n se da informaci\u00f3n sobre la herramienta de flasheo online que tenemos disponible.</p> <p>Despu\u00e9s de cualquier error de transferencia siempre es buena idea desconectar el cable USB y la alimentaci\u00f3n desde bater\u00eda, para volver a conectar el USB y volver a intentarlo.</p> <p>Todas las indicaciones van a estar basadas siempre en Ubuntu 22.04.2 LTS, navegador Google Chrome o Chromium que es la versi\u00f3n open-source de Chrome y que tiene que estar instalado desde la tienda Snap.</p> <p> <p> Chromium instalado desde tienda Snap</p> <p></p> <p>La informaci\u00f3n va a estar basada, adem\u00e1s de las web citadas en webgrafia, fundamentalmente en los siguientes enlaces:</p> <ul> <li>WebUSB Troubleshooting de micro:bit Help &amp; Support.</li> <li>Ticket #64940 error: The transfer timed out. type: transient, user error 504 de micro:bit Help &amp; Support.</li> <li>En este post de Matthew Oppenheim se resuelve el problema con '50-microbit.rules' y los permisos de los directorios afectados, como por ejemplo \"media\" que normalmente es propiedad del superusuario root y no del usuario habitual. En el mismo post hay un enlace a una primera versi\u00f3n donde expone la configuraci\u00f3n de mu-editor en Linux.</li> </ul>"},{"location":"problemas/#paso-a-paso-inicial","title":"Paso a paso inicial","text":""},{"location":"problemas/#paso-1-comprobar-el-cable","title":"Paso 1: Comprobar el cable","text":"<p>Conectamos la placa micro:bit a un puerto USB mediante un cable microUSB. Debemos ver que se monta un dispositivo de nombrre MICROBIT y que est\u00e1 activo, como en la imagen siguiente:</p> <p> <p> Unidad MICROBIT montada</p> <p></p> <p>La forma de ver la unidad montada depender\u00e1 de nuestro sistema operativo.</p> <p>Si podemos ver la unidad MICROBIT montada podemos pasar al paso 2 y si no procedemos a:</p> <ul> <li>Asegurarnos que el cable no est\u00e1 da\u00f1ado. Podemos probarlo en otro ordenador o utilizar un cable diferente. Hay que tener presente que algunos cables comerciales solo conectan alimentaci\u00f3n y no tienen realizadas las conexiones de transmisi\u00f3n de datos.</li> <li>Probar en otro puerto USB del ordenador.</li> </ul> <p>Si podemos asegurar que el cable est\u00e1 bien pero no aparece la unidad MICROBIT, es posible que tengamos un problema con la micro:bit. Hay que probar los pasos adicionales descritos en la p\u00e1gina de b\u00fasqueda de fallos en microbit.org. Si esto tampoco nos ayuda, podemos crear un New support ticket para notificar el problema a la Fundaci\u00f3n Micro:bit y esperar obtener una respuesta. Si estamos en este caso hay que omitir el resto de pasos hasta obtener la respuesta.</p>"},{"location":"problemas/#paso-2-verificar-la-version-de-firmware","title":"Paso 2: Verificar la versi\u00f3n de firmware","text":"<p>Es posible que el firmware de la micro:bit necesite una actualizaci\u00f3n. Vamos a comprobarlo:</p> <ul> <li>Accedemos a la unidad MICROBIT montada.</li> <li>Abrimos con un editor de texto el archivo de solo lectura DETAILS.TXT.</li> <li>Comprobamos el n\u00famero que pone junto a Interface Version.</li> </ul> <p> <p> Comprobaci\u00f3n de la versi\u00f3n de firmware</p> <p></p> <p>Si la versi\u00f3n 0234, 0241 o 0243 es necesario actualizar el fimware de esa micro:.bit siguiendo el proceso que vamos a indicar en el paso 3. En la imagen anterior observamos que la versi\u00f3n del firmware es Interface Version: 0249.</p> <p>Si tenemos la versi\u00f3n 0249, 0250 o mayor trabajamos con el firmaware correcto y podemos saltar al paso 4.</p>"},{"location":"problemas/#paso-3-actualizar-firmware","title":"Paso 3: Actualizar firmware","text":"<p>Si se requiere una actualizaci\u00f3n del firmware para acceder a nuevas caracter\u00edsticas o para solucionar alg\u00fan problema, debemos proceder as\u00ed:</p> <ul> <li>Desconectar la micro:bit de cualquier tipo de alimentaci\u00f3n, ya sea por USB o por bateria.</li> <li>Con el pulsador de reset de la parte posterior accionado conectamos la micro:bit a un puerto USB y esperamos a que se monte una unidad llamada MAINTENANCE (en lugar de MICROBIT) como observamos en la figura siguiente.</li> </ul> <p> <p> Micro:bit en modo MAINTENANCE</p> <p></p> <p>La forma de ver la unidad montada depender\u00e1 de nuestro sistema operativo.</p> <ul> <li>Descargamos el archivo .hex apropiado para nuestra versi\u00f3n de micro:bit. El n\u00famero de versi\u00f3n est\u00e1 impreso en la parte inferior derecha de la cara trasera del dispositivo. Existen unas cuantas formas de distinguir que versi\u00f3n de placa tenemos.</li> </ul>"},{"location":"problemas/#identificar-el-numero-de-version","title":"Identificar el n\u00famero de versi\u00f3n","text":"<p>Actualmente hay dos versiones oficiales de BBC micro:bit, la V1 y la V2.</p> <p>Ambas versiones trabajan de la misma forma por lo que podemos continuar utilizando las versiones previas de la forma habitual.</p> <p>La primera forma de saber el n\u00famero de versi\u00f3n (V2.20, V2, V1.5, V1.3B) es mirar en la esquina inferior derecha de la cara posterior (figura siguiente). Si no podemos ver el n\u00famero es muy probable que tengamos una micro:bit 1.3 en la que el n\u00famero de versi\u00f3n serigrafiado se quedaba debajo de la pintura negra.</p> <p> <p> N\u00famero de versi\u00f3n serigrafiado</p> <p></p> <p>Como segunda forma, si en la parte posterior del dispositivo en versiones V2, veremos una etiquetara identifica MICROPHONE (MICR\u00d3FONO) y otra otra para el SPEAKER (ALTAVOZ), y adem\u00e1s la ANTENA BLE es de color dorado.</p> <p> <p> N\u00famero de versi\u00f3n seg\u00fan la antena</p> <p></p> <p>Para la tercer forma nos fijaremos en si el conector de borde tiene muescas que ser\u00e1n \u00fatiles para facilitar el uso de pinzas de cocodrilo o no dispone de dichas muescas. En la figura siguiente vemos la diferencia.</p> <p> <p> N\u00famero de versi\u00f3n seg\u00fan el conector de borde</p> <p></p> <p>y la cuarta forma es el logototipo de micro:bit en la parte frontal del dispositivo, que en la versi\u00f3n V2 es dorado como el conector de borde y adem\u00e1s es un pulsador t\u00e1ctil que se puede usar como un pin de entrada. En la figura vemos las diferencias.</p> <p> <p> N\u00famero de versi\u00f3n seg\u00fan el logotipo de micro:bit</p> <p></p>"},{"location":"problemas/#microbit-v1","title":"Micro:bit V1","text":"<p>Si tenemos una micro:bit V1 (sin altavoz ni micr\u00f3fono), todas las placas usan el mismo firmware.</p> <p> <p>Firmware para V1</p> <p></p>"},{"location":"problemas/#microbit-v2","title":"Micro:bit V2","text":"<p>Si tenemos una micro:bit V2 (con altavoz y micr\u00f3fono), existen dos posibles versiones de firmware; la V2.00 y la V2.20/2.21. Debemos seleccionar el firmware apropiado para nuestra placa.</p> <p> <p>Firmware para V2.00 --- Firmware para V2.20/2.21</p> <p></p> <ul> <li>Arrastramos y soltamos el fichero .hex que hemos descargado en la unidad montada como MAINTENANCE y esperamos a que el LED amarillo de la cara posterior deje de parpadear. Cuando la actualizaci\u00f3n se ha completado la micro:bit se resetear\u00e1, se expulsar\u00e1 del ordenador y volver\u00e1 a aparecer en modo MICROBIT.</li> <li>Finalmente debemos comprobar el archivo DETAILS.TXT para asegurarnos que la versi\u00f3n de firmware descargada se ha flsheado en el chip de interface.</li> <li>Si tenemos cualquier problema con el proceso de actualizaci\u00f3n del firmware debemos contactar con micro:bit support que es la p\u00e1gina de soporte en ingl\u00e9s.</li> <li>Todas las versiones de firmware, actuales, anteriores y beta est\u00e1n disponibles en previous firmware versions.</li> </ul>"},{"location":"problemas/#paso-4-comprobar-la-version-del-navegador","title":"Paso 4: Comprobar la versi\u00f3n del navegador","text":"<p>WebUSB es una caracter\u00edstica muy actual y puede requerir que el navegador est\u00e9 actualizado. Verifiquemos que el navegador coincida con los descritos navegadores soportados. Est\u00e1n soportados diferentes navegadores como Microsoft Edge, Google Chrome o Chromium, Mozilla Firefox y Safari para los distintos sistemas operativos y versiones.</p>"},{"location":"problemas/#paso-5-emparejar-dispositivo","title":"Paso 5: Emparejar dispositivo","text":"<p>Una vez que hemos actualizado el firmware, abrimos nuestro navegador compatible, vamos al editor que estemos utilizando para programar y procedemos a Emparejar dispositivo. Ya estamos preparados para comenzar a trabajar siguiendo los pasos iniciales que se describen en Configurar nuestra micro:bit.</p>"},{"location":"problemas/#flasheo-directo","title":"Flasheo directo","text":"<p>Vamos a ver que necesitamos para poder grabar firmware en la micro:bit desde la p\u00e1gina web del editor que estemos utilizando mediante webUSB para posteriormente atajar los posibles problemas. Comenzamos por un resumen de las condiciones en las que se documenta esto, que son:</p> <ul> <li>Sistema operativo Ubuntu 22.04.2 LTS de 64 bits.</li> <li>Inicialmente el navegador utilizado ha sido Chromium Versi\u00f3n 114.0.5735.198 (Build oficial) snap (64 bits). Tambi\u00e9n se realizan pruebas con el navegador Google Chrome Versi\u00f3n 115.0.5790.110 (Build oficial) (64 bits).</li> <li>El flasheo directo solamente funciona en los navegadores Chrome o Edge que soportan webUSB.</li> <li>Recordemos que tambi\u00e9n es necesario tener actualizado el firmware de la micro:bit.</li> </ul> <p>La micro:bit nos debe aparecer en el navegador como BBC micro:bit CMSIS-DAP aunque es posible que la primera vez nos aparezca como LPC1768.</p> <p>Si nos estamos cambiando entre editores, por ejemplo MakeCode y Python, seguramente la actualizaci\u00f3n de programas mediante webUSB requiere mas tiempo del habitual ya que la micro:bit contiene un programa creado con un editor diferente.</p> <p>Si tenemos problemas cuando tenemos conectada alimentaci\u00f3n externa, procedemos a desconectar esta alimentaci\u00f3n y el cable microUSB garantizando asi el total apagado de la placa. Conectamos solamente el cable microUSB tanto a la micro:bit como al ordenador e intentamos de nuevo el flasheo. Es indiferente para esto conectar la bateria tras conectar el cable microUSB o hacerlo en otro momento.</p> <p>Si estamos en un sistema Linux y se ha instalado Chromium desde snap store, que es la tienda oficial de software de Ubuntu, no podremos acceder a dispositivos webUSB. En distribuciones como Ubuntu suele solucionar el problema declarar una regla udev. A continuaci\u00f3n se indica como hacerlo.</p> <p>Cuando trabajamos con distribuciones Linux en general o Ubuntu en particular hay que declarar una regla 'udev' y para hacerlo debemos seguir una serie de pasos que describimos a continuaci\u00f3n:</p> <ul> <li>Cerramos el navegador Chrome o Chromium.</li> <li>Abrimos una terminal de comandos</li> <li>Comprobamos si existe un grupo de usuaraios llamado 'plugdev' utilizando el comando 'getent', que nos devuelve las entradas de la base de datos administrativa del sistema. Se puede solicitar de 'passwd, group, hosts, services, protocols, o networks'. En nuestro caso nos interesa de 'gropu', por lo que hacemos:</li> </ul> <pre><code>getent group\n</code></pre> <p>En el resultado debemos buscar el grupo y si existe aparecer\u00e1 listado. En caso de que no exista lo creamos con:</p> <pre><code>getent group plugdev &gt;/dev/null || sudo groupadd -r plugdev\n</code></pre> <p>Si resulta necesario porque el grupo lo cre\u00f3 un usuario distinto a nosotros, deberemos agregar nuestro usuario al grupo 'plugdev' seg\u00fan vemos a continuaci\u00f3n. Debemos reemplazar  con el nombre real de nuestro usuario. <pre><code>sudo usermod -a -G plugdev &lt;tu-nombre-de-usuario&gt;\n</code></pre> <ul> <li>Creamos un archivo en el directorio '/etc/udev/rules.d' que llamaremos '50-microbit.rules' haciendo:</li> </ul> <pre><code>sudo nano/etc/udev/rules.d/50-microbit.rules\n</code></pre> <p>En el editor escribimos:</p> <p>'SUBSYSTEM==\"usb\", ATTR{idVendor}==\"0d28\", MODE=\"0664\", GROUP=\"plugdev\"'</p> <p>y ya podemos guardar el archivo en el directorio indicado y con el nombre citado.</p> <p>Salimos del editor y podemos continuar. El siguiente comando nos ayuda a mostrar si hemos creado bien la regla ya que nos muestra el contenido del archivo creado.</p> <pre><code>cat /etc/udev/rules.d/50-microbit.rules\n</code></pre> <p> <p> Comando Cat</p> <p></p> <p>El comando 'Cat' toma su nombre de concatenar y permite crear, unir y consultar el contenido del archivo que le indiquemos.</p> <p>Es IMPORTANTE saber que el archivo de reglas de estar creado por un usuario root, o incluso el propio root del sistema. No voy a entrar en detalles sobre el tema del superusuario en Linux debido a los peligros que conlleva trabajar con este nivel de permisos sin ser un experto. Algunas de sentencias que hemos puesto van precedidas de 'sudo', que indica que lo que se va a hacer se har\u00e1 como usuario con privilegios de root, pero este no es exactamente el superusuario. En la entrada Tipos de permisos en Linux de la introducci\u00f3n a Python hay mas informaci\u00f3n sobre el tema. Se advierte que trabajar con estos temas sin ser experto puede crear da\u00f1os irreversibles en el sistema. Para asegurar estos cambios, si se han realizado, es conveniente reiniciar siempre el sistema.</p> <ul> <li>Cerramos o reiniciamos el ordenador.</li> <li>Abrimos el navegador.</li> <li>Comprobamos si se ha establecido la conexi\u00f3n mediante los comandos siguientes:</li> </ul> <pre><code>snap connections  | grep -v \".*-$\nmount | grep MICROBIT\n</code></pre> <p>El comando 'snap' permite instalar, configurar, actualizar y eliminar paquetes y mediante 'grep' buscamos si dentro del fichero connections el navegador ha establecido la conexi\u00f3n y si la misma est\u00e1 realizada. Si todo es correcto devolver\u00e1 Plug = chromium:raw-usb y connector = raw-usb. El segundo nos ayuda a montar la unidad \"MICROBIT\" si no se monta al conectar una placa micro:bit. En la figura siguiente vemos un posible resultado.</p> <p> <p> Comandos snap connections y mount</p> <p></p> <p>En el bug de Chromium citado en la parte de Linux indica, antes de entrar en la creaci\u00f3n de reglas lo siguiente:</p> <ul> <li>Si Chromium se ha instalado desde la tienda snap no se podr\u00e1 acceder a los dispositivos WebUSB. En este caso, WebUSB se puede habilitar utilizando la interfaz 'raw-usb', que permite el acceso a todos los dispositivos USB conectados a trav\u00e9s de una interfaz sin formato que no tiene una conexi\u00f3n autom\u00e1tica. Se habilita desde la l\u00ednea de comandos as\u00ed:</li> </ul> <pre><code> snap connect chromium:raw-usb\n</code></pre> <p>que deber\u00eda servir para versiones de Chromium posteriores a julio de 2020.</p> <ul> <li>Si en alg\u00fan momento dudamos si se est\u00e1 aplicando la nueva regla tras alg\u00fan cambio realizado podemos reiniciar las mismas haciendo:</li> </ul> <pre><code>sudo udevadm control --reload-rules\n</code></pre> <p>Si al hacer clic en los tres puntos para realizar la conexi\u00f3n se genera un error como el que vemos en la imagen siguiente es evidente que no vamos a poder flashear el firmware en esas condiciones.</p> <p> <p> Errores de conexi\u00f3n en MakeCode y Python</p> <p></p> <p>Si hemos dado todos los pasos anteriores y no funciona puede deberse a diversas causas y una muy probable es que los permisos dados en el navegador para el dispositivo est\u00e9n emparejados para otra aplicaci\u00f3n o dispositivo y esto no permite continuar. A la izquierda en la barra de navegaci\u00f3n podemos ver un peque\u00f1o candado que es un bot\u00f3n que nos da informaci\u00f3n del sitio y que permite borrar los emparejamientos. En la imagen vemos la situaci\u00f3n.</p> <p> <p> Borrar emparejamiento</p> <p></p> <p>Si seguimos el orden num\u00e9rico indicado, tras borrar el emparejamiento debemos cerrar la ventana abierta al clicar el candado y veremos la siguiente situaci\u00f3n:</p> <p> <p> Recargar la p\u00e1gina</p> <p></p> <p>Esta acci\u00f3n restablece el estado del navegador. Si esto no nos funciona a la primera debemos probar a repetirlo un par de veces mas dado que a veces webUSB se desincroniza. Tambi\u00e9n es conveniente combinarlo con desconectar y conectar el USB.</p>"},{"location":"problemas/#pruebas-finales","title":"Pruebas finales","text":"<p>Para comprobar que todos los cambios propuestos anteriormente se han realizado correctamente vamos a ejecutar desde una terminal los comandos siguientes:</p> <pre><code>groups\ncat /etc/udev/rules.d/50-microbit.rules\nls -l /etc/udev/rules.d\n</code></pre> <p>Como vemos en la imagen siguiente, el primer comando nos indica que el usuario est\u00e1 en el grupo requerido, el segundo nos muestra la sintaxis de la regla creada y con el tercero simplemente comprobamos que el fichero creado efectivamente est\u00e1 y adem\u00e1s en el directorio correspondiente.</p> <p> <p> Creaci\u00f3n regla udev</p> <p></p> <p>En la imagen se ha indicado la existencia del archivo de reglas udev creado con la instalaci\u00f3n del navegador Chromium, pero en este no existe ninguna regla para micro:bit y personalmente no he querido tocar el mismo.</p>"},{"location":"problemas/#makecode","title":"MakeCode","text":"<p>Iniciamos el navegador Chromium o Google Chrome, este \u00faltimo preferiblemente desde un perfil sin cuenta o con una cuenta que tenga poca actividad.</p> <p>Conectamos nuestra micro:bit a un puerto USB y procedemos a emparejarla con el navegador. Si nos da alg\u00fan tipo de error debemos probar a desconectar y volver a conectar la micro:bit del USB y repetir la operaci\u00f3n.</p> <p>Para el caso de Chromium ser\u00e1 algo similar a lo siguiente:</p> <p> <p> Flasheo directo en Chromium</p> <p></p> <p>Para el caso de Chrome ser\u00e1 algo similar a lo siguiente:</p> <p> <p> Flasheo directo en Chrome</p> <p></p>"},{"location":"problemas/#python","title":"Python","text":"<p>Para el caso de Chromium ser\u00e1 algo similar a lo siguiente:</p> <p> <p> Flasheo directo en Chromium</p> <p></p> <p>Para el caso de Chrome ser\u00e1 algo similar a lo siguiente:</p> <p> <p> Flasheo directo en Chrome</p> <p></p> <p>Tenemos que recordar siempre archivar nuestro trabajo.</p>"},{"location":"problemas/#mas-reglas-udev","title":"Mas reglas udev","text":"<p>Vamos a instalar en el sistema una nueva regla propuesta por Martin Williams en el ticket Ticket #64940 error: The transfer timed out. type: transient, user error 504. En este caso enfocado al sistema de grabaci\u00f3n de firmware drag &amp; drop. Si seguimos viendo el error 504, vamos a trabajar con otra regla udev que podemos eliminar si nos ocasiona problemas secundarios.</p> <p>Ser\u00eda conveniente tener un historial de pruebsas anterior a la instalaci\u00f3n de la nueva regla para poder comparalas con las que hagamos despu\u00e9s de instalarla. Con una micro:bit conectada ejecutamos el comando:</p> <pre><code>mount | grep MICROBIT\n</code></pre> <p>En mi caso devuelve lo siguiente:</p> <p> <p> Antes de la nueva regla udev</p> <p></p> <p>Para los siguientes pasos desconectamos la micro:bit del ordenador y reiniciamos las reglas udev.</p> <p>Nos descargamos el archivo 99-microbit-udisks.zip y lo descomprimimos en un directorio aparte. Hacemos una copia del archivo descomprimido en el directorio de reglas '/etc/udev/rules.d'. Para ello hacemos:</p> <pre><code>sudo cp 99-microbit-udisks.rules /etc/udev/rules.d\n</code></pre> <p>Hacemos la comprobaci\u00f3n de quien es el propietario, los permisos y el grupo al que pertenece el nuevo archivo. Esto lo podemos hacer con el comando:</p> <pre><code>ls -l /etc/udev/rules.d\n</code></pre> <p>Reiniciamos udev:</p> <pre><code>sudo udevadm control --reload-rules\nsudo udevadm trigger\n</code></pre> <p>Volvemos a conectar la micro:bit y comprobamos de nuevo con:</p> <pre><code>mount | grep MICROBIT\n</code></pre> <p> <p> Despu\u00e9s de la nueva regla udev</p> <p></p> <p>La \u00fanica diferencia deber\u00eda ser que se ha a\u00f1adido \"sync\".</p>"},{"location":"problemas/#sistema-de-prueba","title":"Sistema de prueba","text":"<p>Mediante el hilo indicado en la webgrafia y utilizando la informaci\u00f3n obtenida de WebUSB Troubleshooting ha quedado resuelto el tema de utilizar webUSB con Chromium y se propone un m\u00e9todo de prueba de errores que a mi entender nos puede resultar bastante \u00fatil en un momento determinado.</p> <p>Cuando estamos teniendo problemas para grabar firmware mediante la t\u00e9cnica de arrastrar y soltar (drag &amp; drop) y/o flasheando desde la web del editor, nos resultar\u00e1 \u00fatil disponer de una colecci\u00f3n de archivos que permitan ir realizando pruebas al tiempo que llevamos la cuenta de las pruebas realizadas.</p> <p>Es Martin Williams de Micro:bit Educational Foundation quien propone el sistema y el procedimiento a seguir.</p> <ul> <li>Siempre que tengamos un error tenemos que desconectar y volver a conectar el USB antes de probar de nuevo con el mismo archivo.</li> <li>Crear un script de Python en el que podamos ir cambiando el n\u00famero de intento cuando el programa se flashea o graba correctamente.</li> </ul> <p>El script de Python propuesto lo he modificado y queda as\u00ed:</p> <pre><code># Las importaciones al principio\n\"\"\"En Python, se utiliza la palabra clave import \npara hacer que el c\u00f3digo de un m\u00f3dulo est\u00e9 \ndisponible en otro.\"\"\"\nfrom microbit import *\n\ndisplay.show(Image.HEART)\nsleep(1000)\n\n# El c\u00f3digo en'while True:' se repite indefinidamente\nwhile True:\n    display.show(0) #Contamos cambiando el valor aqu\u00ed\n    sleep(1000)\n</code></pre> <p>En el fichero 10_archivos_hex_python.zip tenemos los 10 archivos hexadecimal generados y probados. El primero de los cuales (python0-main.py) tambi\u00e9n lo tenemos en formato texto.</p> <p>Probamos arrastrando cada archivo de manera sucesiva. Si se produce alg\u00fan fallo volvemos a desconectar y conectar el USB y probamos de nuevo el mismo archivo. Podemos ir anotando el n\u00famero de fallos que se producen al transferir los 10 archivos.</p> <p>Tambi\u00e9n probamos a cargar el archivo '0' en el Editor Python, y lo flasheamos directamente desde el editor a la unidad micro:bit y hacemos el procerso de reconectar si es necesario. Vamos cambiando el n\u00famero cuando tenemos \u00e9xito, hasta que he lleguemos al n\u00famero 9. Cambiando el n\u00famero se comprueba que el archivo se est\u00e1 transfiriendo realmente, \u00a1y ayuda a no perder la cuenta!</p>"},{"location":"Miscelanea/about/","title":"Autor","text":"<p>Federico Coca</p> <ul> <li> <p>GitHub</p> </li> <li> <p>Twitter</p> </li> <li> <p>Instagram</p> </li> <li> <p>Mas informaci\u00f3n</p> </li> </ul>"},{"location":"Miscelanea/lic/","title":"Licencias","text":"<ul> <li> <p>Licencia MIT incluida en la creaci\u00f3n del repositorio.</p> </li> <li> <p>Creative Commons Atribuci\u00f3n-CompartirIgual 4.0 International (\"CC BY-SA\"). CC BY-SA 4.0 </p> </li> </ul> <p> <p> </p> <p></p>"},{"location":"Miscelanea/soft/","title":"Software utilizado","text":"<ul> <li> <p>Sistema operativo: Ubuntu 22.04</p> </li> <li> <p>Paquete ofim\u00e1tico de referencia: LibreOffice</p> </li> <li> <p>Libreria Material para MkDocs</p> </li> <li> <p>Visual Studio Code</p> </li> <li> <p>Creaci\u00f3n de GIF animados para Ubuntu Peek</p> </li> <li> <p>Sistema principal de capturas de pantalla: Shutter</p> </li> <li> <p>Dibujo 2D vectorial Inkscape</p> </li> <li> <p>Retoque de im\u00e1genes GIMP</p> </li> <li> <p>Editor gr\u00e1fico Makecode estable.</p> </li> <li> <p>Editor de MicroBlocks</p> </li> <li> <p>Editor Python de micro:bit.</p> </li> <li> <p>Mu.</p> </li> <li> <p>IDLE.</p> </li> <li> <p>Thonny. Sencillo IDE para Python.</p> </li> <li> <p>Compilador online de Python de Programiz</p> </li> </ul>"},{"location":"Miscelanea/webgrafia/","title":"Webgraf\u00eda y bibliograf\u00eda","text":"<ul> <li> <p>Wikipedia</p> </li> <li> <p>Web en ingl\u00e9s</p> </li> <li>Web en espa\u00f1ol</li> <li>Comunidad micro:bit en espa\u00f1ol</li> <li>Github de microbit</li> <li>Comunidad de desarrollo de micro:bit. Wiki de la comunidad con informaci\u00f3n t\u00e9cnica de micro:bit.</li> <li>Editor gr\u00e1fico Makecode estable.</li> <li>Web de MicroBlocks</li> <li>Editor online de MicroBlocks</li> <li>Editor Python de micro:bit. Sencillo editor de c\u00f3digo basado en navegador.</li> <li>Mu. Sencillo editor de c\u00f3digo sin conexi\u00f3n.</li> <li>uFlash. Herramienta de l\u00ednea de comandos para mostrar secuencias de comandos de Python sin procesar en un micro:bit.</li> <li>IDLE. Un IDE de c\u00f3digo abierto multiplataforma que se instala por defecto con Python.</li> <li>BBC Micro:bit MicroPython documentation.</li> <li>Instalaci\u00f3n de Mu-editor en Linux, OSX y Window.</li> <li>Bot de programaci\u00f3n Open Roberta Lab.</li> <li> <p>Thonny. Sencillo IDE para Python.</p> </li> <li> <p>Gu\u00eda Programiz para aprender Python programando. Incluye un interesante compilador online y otros muchos recursos.</p> </li> <li> <p>Invent to Learn. Making, Tinkering, and Engineering in the Classroom por Sylvia Libow Martinez &amp; Gary Stager</p> </li> <li> <p>Web Ardutaller de Francisco Soldado.</p> </li> <li> <p>MicroBlocks Wiki</p> </li> <li> <p>micro:bit Micropython API</p> </li> <li>Gu\u00eda de micro:bit paso a paso para principiantes de Bricogeek.</li> <li>Recursos sobre micro:bit de Pedro Ruiz.</li> <li> <p>Retos de Micro:bit con Python por Pedro Ruiz</p> </li> <li> <p>Consulta realizada en \u00bfC\u00f3mo podemos ayudarte? de micro:bit Help &amp; Support con el ticket 64940 referente a un error 504 con una BBC micro:bit V2.00 sobre Ubuntu 22.04.2 LTS con navegador Chromium 114.0.5735.198 version.</p> </li> <li> <p>Tutorial Freenove Ultimate Starter Kit for Micro:bit</p> </li> <li> <p>Otros tutoriales de Freenove</p> </li> </ul>"},{"location":"actividades/A01/","title":"A01. Hola mundo","text":"<p>La manera habitual de comenzar a programar en un nuevo lenguaje es hacer que el ordenador o dispositivo programable nos salude con un \"\u00a1Hola, mundo!\". Pues hagamos esto en los tres sistemas elegidos: MicroPython, MakeCode y MicroBlocks. Animamos a probar otros programas de los citados en la webgraf\u00eda.</p>"},{"location":"actividades/A01/#micropython","title":"MicroPython","text":"<p>El programa de la actividad lo vamos a hacer utilizando algunas de las cosas descritas y comentando las l\u00edneas para que se entienda mejor. El c\u00f3digo del programa es el siguiente:</p> <pre><code># Las importaciones van a la cabeza\nfrom microbit import * #Usar todo de la biblioteca microbit\ndisplay.clear() #Borra pantalla\ndisplay.scroll('\u00a1Hola Mundo!', delay=100) #Desplaza el texto por pantalla\nsleep(1000) #Espera 1s\ndisplay.show(Image.HAPPY) #Muestra carita alegre\nsleep(1000)\ndisplay.clear()\ndisplay.set_pixel(0,0,3) #Encendemos pixel al brillo establecido\ndisplay.set_pixel(2,2,9)\ndisplay.set_pixel(4,0,3)\n</code></pre> <p>En la animaci\u00f3n vemos el funcionamiento en el simulador y el efecto de cambiar el valor del delay y del valor del brillo de uno de los LED.</p> <p> <p> Funcionamiento del programa</p> <p></p> <p>Si observamos bien, al principio del texto aparecen unas interrogaciones en lugar de el signo de abrir admiraci\u00f3n. Esto es debido a que micro:bit no muestra caracteres especiales como \u00a1, \u00bf, \u00f1, acentos, etc.</p> <p>El programa lo podemos descargar de:</p> <ul> <li>A01-Hola_Mundo-main en hexadecimal</li> <li>A01-Hola_Mundo-main en Python</li> </ul>"},{"location":"actividades/A01/#makecode","title":"MakeCode","text":"<p>El programa de la actividad lo vamos a hacer utilizando los bloques descritos y comentando algunas de las l\u00edneas para que se entienda mejor. El programa es el siguiente:</p> <p> <p> Programa de la actividad A01 en MakeCode</p> <p></p> <p>En la animaci\u00f3n vemos el funcionamiento en el simulador.</p> <p> <p> Funcionamiento del programa</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>microbit-A01-Hola_Mundo</li> </ul>"},{"location":"actividades/A01/#microblocks","title":"MicroBlocks","text":"<p>Se explican los bloques utilizados de los men\u00fas de bloques por defecto y de la libreria a\u00f1adida. Referencia a Blocks Reference.</p> <p>El programa de la actividad lo vamos a hacer utilizando los bloques descritos. El programa es el siguiente:</p> <p> <p> Programa de la actividad A01 en MicroBlocks</p> <p></p> <p>En el caso de MicroBlocks no disponemos de simulador pero los botones Iniciar/parar nos permiten estar viendo en la placa real todo lo que ocurre mientra elaboramos nuestro programa.</p> <p>El programa lo podemos descargar de:</p> <ul> <li>A01-Hola_Mundo.ubp</li> </ul>"},{"location":"actividades/A02/","title":"A02. Im\u00e1genes","text":"<p>Vamos a entrar en las posibilidades art\u00edsticas que nos puede ofrecer una matriz cuadrada de 5x5 LEDs.</p>"},{"location":"actividades/A02/#micropython","title":"MicroPython","text":"<p>Vamos a hacer el ejemplo del coraz\u00f3n que late. Resulta muy f\u00e1cil de resolver pues ya est\u00e1n predise\u00f1adas las im\u00e1genes de un coraz\u00f3n grande y peque\u00f1o.</p> <pre><code>from microbit import *\ndisplay.clear()\nwhile True:\n    display.show(Image.HEART_SMALL)\n    sleep(300)\n    display.show(Image.HEART)\n    sleep(300)\n</code></pre> <p>En la animaci\u00f3n vemos su funcionamiento.</p> <p> <p> Coraz\u00f3n latiendo</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>A02-Corazon_latiendo en hexadecimal</li> <li>A02-Corazon_latiendo en Python</li> </ul>"},{"location":"actividades/A02/#makecode","title":"MakeCode","text":"<p>El programa de corazon latiendo es el siguiente:</p> <p> <p> Programa de la actividad A02 en MakeCode</p> <p></p> <p>En la animaci\u00f3n vemos el funcionamiento en el simulador.</p> <p> <p> Funcionamiento del programa</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>A02-Coraz\u00f3n_latiendo</li> </ul>"},{"location":"actividades/A02/#microblocks","title":"MicroBlocks","text":"<p>Todos los bloques que se requieren para resolver el problema del coraz\u00f3n latiendo se han explicado y no se requiere nada nuevo. Pero en MicroBlocks no tenemos una definici\u00f3n previa de los corazones por lo que tendremos que crearla nosotros a partir del bloque \"pantalla\", tal y como vemos en la imagen siguiente.</p> <p> <p> Dibujos de los corazones en el bloque pantalla</p> <p></p> <p>El programa de la actividad lo vamos a hacer utilizando los bloques descritos. El programa es el siguiente:</p> <p> <p> Programa de la actividad A02 en MicroBlocks</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>A02-Corazon_latiendo.ubp</li> </ul>"},{"location":"actividades/A03/","title":"A03. Botones on board","text":"<p>Los ejemplos vistos hasta ahora han permitido que la micro:bit nos muestre algo. Esto es lo que se conoce como salida. Ahora bien, es evidente que necesitamos tambi\u00e9n que la micro:bit reaccione a cosas externas, y estas cosas se denominan entradas. Para que sea f\u00e1cil de recordar:</p> <ul> <li>Salida es lo que micro:bit nos muestra</li> <li>Entrada es lo que recibe la micro:bit para procesarlo</li> </ul> <p>Aunque existen otros sistemas, por ahora nos vamos a centrar en los botones de la micro:bit. Si trabajamos con versiones anteriores a la V2 disponemos de dos botones etiquetados como A y B. Si trabajamos con alguna versi\u00f3n V2 disponemos adem\u00e1s de un tercer bot\u00f3n, en este caso tactil, que est\u00e1 en el logo de la placa. En la imagen vemos estos botones.</p> <p> <p> Botones en las micro:bit V1 y V2</p> <p></p>"},{"location":"actividades/A03/#micropython","title":"MicroPython","text":"<p>El programa que vamos a crear como ejemplo nos va a mostrar en la pantalla el bot\u00f3n que estamos pulsando mientras lo mantengamos accionado.</p> <p>El c\u00f3digo del programa 'Boton_pulsado' es el siguiente:</p> <pre><code>from microbit import *\n\nwhile True:\n    if button_a.is_pressed():\n        display.scroll('A')\n    elif button_b.is_pressed():\n        display.scroll('B')\n</code></pre> <p>El funcionamiento lo vemos en la animaci\u00f3n siguiente:</p> <p> <p> Muestra 'Boton_pulsado' funcionando</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>A03-Boton_pulsado en hexadecimal</li> <li>A03-Boton_pulsado en Python</li> </ul>"},{"location":"actividades/A03/#makecode","title":"MakeCode","text":"<p>El programa que vamos a crear como ejemplo nos va a mostrar en la pantalla el bot\u00f3n que estamos pulsando mientras lo mantengamos accionado. El programa es el siguiente:</p> <p> <p> </p> <p></p> <p>En la animaci\u00f3n vemos el funcionamiento en el simulador.</p> <p> <p> </p> <p>Funcionamiento del programa</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>A03-boton_pulsado</li> </ul>"},{"location":"actividades/A03/#microblocks","title":"MicroBlocks","text":"<p>El programa que vamos a crear como ejemplo nos va a mostrar en la pantalla el bot\u00f3n que estamos pulsando mientras lo mantengamos accionado. El programa es el siguiente:</p> <p> <p> Programa de la actividad A03 en MicroBlocks</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>A03-boton-pulsado.ubp</li> </ul>"},{"location":"actividades/A03/#ampliacion-de-la-actividad","title":"Ampliaci\u00f3n de la actividad","text":"<p>Como proyecto de ampliaci\u00f3n de la actividad vamos a crear un programa que se est\u00e9 ejecutando en un bucle infinito y que responda, seg\u00fan pulsemos los botones, de la forma siguiente:</p> <ul> <li>Si pulsamos simultaneamente A y B en la pantalla aparecer\u00e1 el s\u00edmbolo siguiente: <ul> <li> check de Ok.</li> </ul> </li> <li>Si pulsamos el bot\u00f3n A mostrar\u00e1 una flecha apuntando a la izquierda</li> <li>Si pulsamos el bot\u00f3n B mostrar\u00e1 una flecha apuntando a la derecha</li> </ul> <p>Para micro:bit V1:</p> <ul> <li>Si no pulsamos ning\u00fan bot\u00f3n en la pantalla veremos un aspa</li> </ul> <p>Para micro:bit V2:</p> <ul> <li>Si disponemos de micro:bit V2 utilizaremos el logo para mostrar un aspa y si no pulsamos nada dejaremos la pantalla en negro</li> </ul>"},{"location":"actividades/A03/#solucion-micropython","title":"Soluci\u00f3n MicroPython","text":"<p>Estos son los enlaces para descargar el programa para micro:bit V1:</p> <ul> <li>PA03_V1 en .hex</li> <li>PA03_V1 en .py</li> </ul> <p>Estos son los enlaces para descargar el programa para micro:bit V2:</p> <ul> <li>PA03_V2 en .hex</li> <li>PA03_V2 en .py</li> </ul>"},{"location":"actividades/A03/#solucion-makecode","title":"Soluci\u00f3n MakeCode","text":"<p>Este es el enlace para descargar el programa para micro:bit V1:</p> <ul> <li>PA03_V1</li> </ul> <p>Este es el enlace para descargar el programa para micro:bit V2:</p> <ul> <li>PA03_V2</li> </ul>"},{"location":"actividades/A03/#solucion-microblocks","title":"Soluci\u00f3n MicroBlocks","text":"<p>Este es el enlace para descargar el programa para micro:bit V1:</p> <ul> <li>PA03_V1</li> </ul> <p>Este es el enlace para descargar el programa para micro:bit V2:</p> <ul> <li>PA03_V2</li> </ul>"},{"location":"actividades/A04/","title":"Pines de entrada/salida","text":"<p>En el borde inferior de la BBC micro:bit hay unos pads (tiras o pines) de color dorado, met\u00e1licos que constituyen los pines de entrada/salida (E/S para abreviar).</p> <p> <p> Pines de E/S para las micro:bit versiones V1 y V2</p> <p></p> <p>Como podemos observar, las patillas serigrafiadas (0, 1, 2, 3V y GND) son m\u00e1s grandes que las otras. Esto se hace as\u00ed para poder sujetar en las mismas cables con pinzas de cocodrilo. Para poder acceder al resto de patillas ser\u00e1 necesario conectar una placa de extensi\u00f3n de conectores al dispositivo micro:bit, y as\u00ed hacer posible la conexi\u00f3n de cables a esos pines m\u00e1s peque\u00f1os. Describiremos estas placas mas adelante en este apartado</p> <p>En la micro:bit V2 el logo tambi\u00e9n se puede utilizar como entrada t\u00e1ctil, es decir, es un pin de entrada, en concreto el 26.</p>"},{"location":"actividades/A04/#informacion-tecnica","title":"Informaci\u00f3n t\u00e9cnica","text":"<p>Fuente: Edge Connector &amp; micro:bit pinout.</p> <p>El conector de borde del micro:bit se utiliza para conectar circuitos y componentes externos.</p> <p>Hay en total 25 pads o pines que incluyen 5 orificios para usar con conectores tipo banana de 4mm o pinzas de cocodrilo. Tres de estos pines son para E/S de prop\u00f3sito general y tambi\u00e9n pueden ser entradas anal\u00f3gicas, PWM y sensores t\u00e1ctiles, est\u00e1ndo dos de ellas conectadas a la fuente de alimentaci\u00f3n de micro:bit.</p> <p>Las tiras m\u00e1s peque\u00f1as est\u00e1n distanciadas a 1,27 mm (50 mils) en el conector de borde y algunas est\u00e1n utilizadas por la micro:bit, mientras que otras quedan libres para su utilizaci\u00f3n.</p> <p>Aunque los pines est\u00e1n en ambas caras realmente s\u00f3lo los de la cara frontal est\u00e1n conectados a se\u00f1ales. Los agujeros si conectan ambas caras entre si pero no as\u00ed los pines mas delgados.</p>"},{"location":"actividades/A04/#pines-del-conector-de-borde","title":"Pines del conector de borde","text":"<p>La imagen siguiente muestra la asignaci\u00f3n de los pines de la micro:bit para ambas versiones de placa. En las placas V2, el pin 9 ya no se comparte con la pantalla LED. Aunque la caracter\u00edstica est\u00e1 dfesactivada por defecto, los pines 8 y 9 pueden configurarse para NFC (Near-field communication) o comunicaci\u00f3n de campo cercano, que es una tecnolog\u00eda de comunicaci\u00f3n inal\u00e1mbrica, de corto alcance y alta frecuencia que permite el intercambio de datos entre dispositivos. Esto es lo que se conoce como comunicaciones por radio en placas micro:bit.</p> <p> <p> Pinout micro:bit V2 y V1</p> <p></p> <p>Hay disponible un recurso externo fant\u00e1stico para obtener m\u00e1s informaci\u00f3n sobre los pines de la micro:bit y c\u00f3mo los utilizan algunos accesorios, se trata de microbit.pinout.xyz.</p> <p>En la imagen siguiente se muestran mas datos sobre cada uno de los pines del conector de borde de la micro:bit V1.</p> <p> <p> Informaci\u00f3n de pines micro:bit V1</p> <p></p> <p>En la imagen siguiente se muestran mas datos sobre cada uno de los pines del conector de borde de la micro:bit V2.</p> <p> <p> Informaci\u00f3n de pines micro:bit V2</p> <p></p> <p>Las siguientes notas est\u00e1n referidas a las dos figuras anteriores:</p> <ul> <li>Las resistencias de pull-up o pull-down se especifican, por ejemplo como e10Mu que significa: externa de 10Mohm en pullup o bien i12Kd, que significa: interna de 12K en pulldown.</li> </ul> <p>En las figuras del borde de placa se espcifican los valores y tipos de resistencia disponibles en el caso de micro:bit.</p> <ul> <li>Los anillos para 0, 1, 2, 3V y GND tambi\u00e9n est\u00e1n conectados a los respectivos anillos de la parte posterior del conector de borde.</li> <li>Los anillos de 3V y GND tienen unos pines protectores a ambos lados de los mas grandes, para evitar cualquier degradaci\u00f3n del rendimiento del dispositivo debido al deslizamiento de las conexiones de las pinzas de cocodrilo. Se debe tener precauci\u00f3n en los anillos 0, 1 y 2 para evitar cortocircuitar las pinzas de cocodrilo con los pines adyacentes.</li> <li>Los pines de entrada digital est\u00e1n configurados por defecto con resistencias pull down internas.</li> <li>El pin marcado como Accesibilidad se utiliza para activar/desactivar el modo de acceso a configuraciones de f\u00e1brica y no debe ser utilizado para otra cosa, a pesar de que puede ser utilizado como un GPIO para pruebas.</li> <li>En cuanto a la alimentaci\u00f3n de la placa existe un punto clave a tener en cuenta, que son los dos diodos BAT60A que hay, uno de la alimentaci\u00f3n de 3,3V del chip de interface y otro del conector de la bater\u00eda externa. Hay que tener en cuenta que el anillo de 3V en el conector de borde es V_TGT, que significa que est\u00e1 conectado al suministro en bruto proporcionado a todos los chips de la placa.</li> </ul>"},{"location":"actividades/A04/#cambiar-la-funcionalidad-por-defecto","title":"Cambiar la funcionalidad por defecto","text":"<ul> <li>pines P3, P4, P6, P7, P9, P10</li> </ul> <p>Estos pines est\u00e1n dedicados a la pantalla matriz de LEDs, y tambi\u00e9n a su modo asociado de detecci\u00f3n de luz ambiental. Para desactivar la funci\u00f3n de controlador de pantalla (que autom\u00e1ticamente desactivar\u00e1 la funci\u00f3n de detecci\u00f3n de luz) se invoca a la funci\u00f3n 'display.enable(false)'. Para volver a activar el controlador de pantalla, se invoca a la funci\u00f3n 'display.enable(true)'.</p> <ul> <li>pines P5, P11</li> </ul> <p>Estos pines est\u00e1n asignados a los dos botones A y B de la placa. En su configuraci\u00f3n por defecto con todos los lenguajes de alto nivel est\u00e1ndar, hay una instancia uBit global que contiene: uBit.buttonA, uBit.buttonB y uBit.buttonAB.</p> <p>Los botones est\u00e1n conectados con al temporizador del sistema en su construcci\u00f3n. Sin embargo, si necesitamos eliminar completamente esta caracter\u00edstica y utilizar los pines f\u00edsicos para otros fines, se pueden eliminar uBit.buttonA llamando al destructor de C++. Hay que tener en cuenta, sin embargo, que hay resistencias pull-up externas de 10K instaladas en la placa micro:bit.</p> <ul> <li>pines P19, P20</li> </ul> <p>Estos pines est\u00e1n asignados al bus I2C, que es utilizado tanto por el sensor de movimiento integrado. Se recomienda evitar el uso de estos pines para cualquier funci\u00f3n que no sea I2C.</p>"},{"location":"actividades/A04/#alimentacion","title":"Alimentaci\u00f3n","text":"<p>A la micro:bit se le puede suministrar alimentaci\u00f3n por:</p> <ul> <li>USB a trav\u00e9s del chip de interface que incorpora su propio regulador en la placa.</li> <li>Una bater\u00eda conectada al conector tipo JST que est\u00e1 junto al bot\u00f3n de reset.</li> <li>Los pines de 3V y GND en el conector de borde.</li> <li>Los dos pads ovalados (rectangulares redondeados) en la parte posterior derecha de la placa.</li> <li>La micro:bit puede suministrar alimentaci\u00f3n desde los pines 3V y GND a peque\u00f1os circuitos externos.</li> </ul> <p>Es importante respetar los par\u00e1metros m\u00e1ximos para los que est\u00e1 dise\u00f1ada la placa:</p> <ul> <li>Cuando se alimenta desde USB, el chip de interface de la placa, en V1 la versi\u00f3n (KL26) utiliza su regulador para proporcionar la energ\u00eda, y este chip puede entregar como m\u00e1ximo 120mA.</li> <li>El consumo de corriente de la placa variar\u00e1 en funci\u00f3n del uso de la pantalla, el Bluetooth, el micr\u00f3fono, el altavoz y otros perif\u00e9ricos. En el peor de los casos, tenemos que prever una demanda de 30 mA cuando se utilizan todos los perif\u00e9ricos integrados, dejando para el conector de borde 90 mA en el caso de V1 y 270 mA en el de V2.</li> <li>Cuando se alimenta desde una bater\u00eda, el chip KL no interviene y el LED indicador de USB no se ilumina.</li> <li>Se utiliza un diodo de baja tensi\u00f3n directa o Vf para conmutar entre fuentes. El diodo evita la retroalimentaci\u00f3n de cualquier fuente desde otra fuente, lo que significa que se puede tener un cable USB y un pack de bater\u00edas conectados simult\u00e1neamente.</li> </ul> <p>El rango de tensiones de alimentaci\u00f3n depende de la versi\u00f3n concreta, vienen impuestas por la circuiter\u00eda que utilizan, y son:</p> <ul> <li>Variantes de V1.3: 1.95V min y 3.6V max</li> <li>Variantes de V1.5: 1.8V min y 3.6V max</li> <li>Revisi\u00f3n V2.00: 1.7V min y 3.6V max</li> <li>Revisi\u00f3n V2.2x: 1.7V min y 3.6V max</li> </ul> <p>A continuaci\u00f3n se dan algunos detalles pr\u00e1cticos sobre alimentaci\u00f3n por USB:</p> <ul> <li>Cuando alimentamos desde USB V1 entrega los 3.3V a trav\u00e9s de un regulador integrado en la interface. La \u00faltima revisi\u00f3n de V2 utiliza un regulador separado.</li> <li>Para tener un margen de seguridad adecuado, en placas V1 no debemos superar los 90 mA de consumo mientras que en V2, al tener su propio regulador, podemos alcanzar los 190 mA. Si necesitamos corriente mayores podemos retroalimentar la micro:bit a partir de los pads 3V y GND, pero asegurando que la alimentaci\u00f3n es regulada y utilizando un diodo de protecci\u00f3n. Para esto no se recomienda el uso de baterias USB ya que pueden generar tensiones fuera del rango permitido y da\u00f1ar a la micro:bit.</li> </ul> <p>En el caso de alimentaci\u00f3n con baterias:</p> <ul> <li>Cuando se alimenta desde una bater\u00eda conectada al JST, el chip de interface y el de sistema en la versi\u00f3n V1 no se encienden. En la micro:bit V2 la energ\u00eda de la bater\u00eda pasa a trav\u00e9s del regulador y alimenta tambi\u00e9n el chip de interface. Si la placa micro:bit no est\u00e1 en modo reposo, el LED rojo (a la izquierda del conector USB) deber\u00eda estar encendido.</li> <li>Una bater\u00eda LiPo de una celda completamente cargada est\u00e1 especificada para entregar 4,2V Esto es m\u00e1s de los 3,6V m\u00e1ximos indicados.</li> </ul> <p>La micro:bit puede ser alimentada desde los pads 3V/GND del conector de borde. Tambi\u00e9n hay dos pads en la parte derecha de la cara posterior de la PCB que se pueden utilizar para suministrar energ\u00eda, por ejemplo, desde un soporte con pilas 2xAAA o 2XAA que podemos soldar en esos pads. En la imagen se destacan estos pads.</p> <p> <p> Extension board de Freenove</p> <p></p>"},{"location":"actividades/A04/#micropython","title":"MicroPython","text":"<p>En MicroPython, cada pin en la BBC micro:bit est\u00e1 representado por un objeto llamado pinN, donde N es el n\u00famero del pin.</p> <p>Por ejemplo, para usar el pin etiquetado 0 (cero), puedes usar el objeto llamado pin0 en tu script. El pin del logo V2 utiliza pin_logo.</p> <p>Estos objetos tienen varios m\u00e9todos asociados dependiendo de lo que el pin espec\u00edfico es capaz de hacer, por ejemplo, leer, escribir o tocar.</p> <p>Quiz\u00e1 lo mas sencillo que podemos hacer es comprobar que los pines 0, 1 y 2 del borde de placa son t\u00e1ctiles. Haremos como ejemplo que al tocar cualquiera de ellos la micro:bit sonria y si no se toca ning\u00fano que est\u00e9 triste. Le hacemos cosquillas a la micro:bit. El programa es:</p> <pre><code>from microbit import *\n\"\"\"\npin0.set_touch_mode(pin0.CAPACITIVE)\npin1.set_touch_mode(pin0.CAPACITIVE)\npin2.set_touch_mode(pin0.CAPACITIVE)\n\"\"\"\nwhile True:\n    if (pin0.is_touched() or pin1.is_touched() or pin2.is_touched()):\n        display.show(Image.HAPPY)\n    else:\n        display.show(Image.SAD)\n</code></pre> <p>En la animaci\u00f3n vemos el funcionamiento del programa.</p> <p> <p> Pines t\u00e1ctiles en el borde de placa</p> <p></p> <p>Si descargamos firmware en una placa para probar el programa debemos saber que no basta con tocar alguno de los pines con una mano, hay que tocarlo simultaneamente con la otra mano en GND para cerrar el circuito el\u00e9ctrico.</p> <p>En la \u00faltima versi\u00f3n de micro:bit V2 es posible cambiar el comportamiento predeterminado de la patilla, de modo que no sea necesario tocar GND. En los programas siguientes el c\u00f3digo que hace esto est\u00e1 comentado por lo que si queremos probarlo debemos eliminar esos comentarios. Recordemos que por defecto los pines del conector de borde son sensores t\u00e1ctiles resistivos mientras que el pin logo V2 es capacitivo.</p> <ul> <li>Descargar el programa .hex</li> <li>Descargar el programa .py</li> </ul>"},{"location":"actividades/A04/#circuito","title":"Circuito","text":"<p>Los diodos LEDs no deben conectarse directamente a la fuente de alimentaci\u00f3n, sino con una resistencia en serie que se calcula como hemos visto. No hacerlo suele acabar con el componente da\u00f1ado de manera irreversible.</p> <p>Al realizar el conexionado, es conveniente desconectar todas las fuentes de alimentaci\u00f3n y, a continuaci\u00f3n, montar el circuito seg\u00fan el esquema concreto. La placa micro:bit no se puede insertar al rev\u00e9s.</p> <p>El positivo del LED o \u00e1nodo (patilla larga) debe conectarse a la resistencia (el otro extremo va al positivo de alimentaci\u00f3n), mientras que su polo negativo o c\u00e1todo (patilla corta) debe ir a GND. Una vez construido el circuito y verificado que es correcto, utilizamos el cable USB para conectar la micro:bit al ordenador y as\u00ed alimentar el circuito.</p> <p>El esquema del circuito a montar lo vemos a continuaci\u00f3n.</p> <p> <p> Esquema de montaje de una LED</p> <p></p> <p>Un sencillo c\u00e1culo del valor de la resistencia es el siguiente:</p> <p> <p>R_{red} = \\dfrac{3.3 - 1.5}{15mA} = \\dfrac{1.8V}{15mA}=0.12K = 120 \\Omega \\sim 220 \\Omega</p> <p></p> <p>Se adopta un valor de resitencia de 220 ohmios para mayor seguridad.</p> <p>El conexionado deber\u00e1 parecerse al siguiente:</p> <p> <p> Conexionado real del esquema de montaje de una LED</p> <p></p>"},{"location":"actividades/A04/#programa","title":"Programa","text":"<p>El programa para el circuito anterior va a consistir en hacer parpadear al LED a intervalos de un segundo.</p> <p>Se trata de un programa muy simple pero que requiere un montaje externo que ya no podremos ver como funciona en el simulador del programa. As\u00ed que toca realizar montaje, conectar la micro:bit a una extension board y probar en la pr\u00e1ctica. El programa es:</p> <pre><code>from microbit import *\n\nwhile True:\n    pin0.write_digital(1)\n    sleep(1000)\n    pin0.write_digital(0)\n    sleep(1000)\n</code></pre> <p>El programa lo podemos descargar de:</p> <ul> <li>A04-parpadeo .hex</li> <li>A04-parpadeo .py</li> </ul> <p>Vamos a realizar una ampliaci\u00f3n del programa aplicando los conocimientos de PWM y de bucles. Se trata de hacer que el diodo LED se encienda y se apague de manera progresiva realizando una escritura anal\u00f3gica del valor PWM del pin P0 (0 a 255). Para ello utilizaremos dos bucles for, uno con cuenta ascendente de 0 a 255 y otro con cuenta descendente tambi\u00e9n de 0 a 255. El programa es:</p> <pre><code>from microbit import *\n\nwhile True:\n    for i in range(255):\n        pin0.write_analog(i)\n        sleep(10)\n    #bucle decreciente: \n        #se antepone al rango reversed\n    for j in reversed(range(255)):\n        pin0.write_analog(j)\n        sleep(10)\n</code></pre> <p>El programa lo podemos descargar de:</p> <ul> <li>A04-Encendido y apagado por PWM .hex</li> <li>A04-Encendido y apagado por PWM .py</li> </ul>"},{"location":"actividades/A04/#makecode","title":"MakeCode","text":"<p>Para hacer el ejemplo de parpadeo de un LED externo utilizamos el mismo circuito que el visto en Python. El programa es el siguiente:</p> <p> <p> Programa pardeo de LED externo</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>A04-parpadeo</li> </ul> <p>Realizamos la ampliaci\u00f3n del programa controlando el encendido y apagado progresivo por PWM.</p> <p> <p> Programa pardeo de LED externo</p> <p></p> <p>Dos cosas a observar:</p> <ol> <li>El contador hacia atr\u00e1s se realiza restando al valor inicial de cuenta la variable en un bucle de 0 a xx</li> <li>Como hemos establecido el valor m\u00e1ximo posible anal\u00f3gico como l\u00edmite, el retardo lo hemos puesto de 3ms para que tarde aproximadamente 3 segundos (3ms x 1023 = 3069ms = 3,069s) en realizar la cuenta (o decontaje) completo.</li> </ol> <p>El programa lo podemos descargar de:</p> <ul> <li>A04-parpadeo PWM</li> </ul> <p>Resulta interesante observar el funcionamiento del programa en el simulador, donde se aprecia a la perfecci\u00f3n tanto la cuenta ascendente como la descendente. En la animaci\u00f3n lo vemos.</p> <p> <p> Simulaci\u00f3n del programa pardeo de LED externo</p> <p></p>"},{"location":"actividades/A04/#microblocks","title":"MicroBlocks","text":"<p>SPara hacer el ejemplo de parpadeo de un LED externo utilizamos el mismo circuito que el visto en Python. El programa es el siguiente:</p> <p> <p> Programa pardeo de LED externo</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>A04-parpadeo</li> </ul> <p>Realizamos la ampliaci\u00f3n del programa de la misma forma que en MakeCode.</p> <p> <p> Programa pardeo de LED externo</p> <p></p> <p>En este caso tambi\u00e9n tenemos dos cosas a observar:</p> <ol> <li>El contador hacia atr\u00e1s se realiza restando al valor inicial de cuenta la variable en un bucle de 0 a xx</li> <li>Como hemos establecido el valor m\u00e1ximo posible anal\u00f3gico como l\u00edmite, el retardo lo hemos puesto de 3ms para que tarde aproximadamente 3 segundos (3ms x 1023 = 3069ms = 3,069s) en realizar la cuenta (o decontaje) completo.</li> </ol> <p>El programa lo podemos descargar de:</p> <ul> <li>A04-parpadeo PWM</li> </ul>"},{"location":"actividades/A05/","title":"Bot\u00f3n pulsador","text":"<p>En esta actividad vamos a realizar el control de un diodo LED externo mediante un pulsador tambi\u00e9n externo. Este circuito, aunque sencillo, es lo que se conoce como sistema de control y lo vamos a definir en este momento.</p> <p>Lo mas simple como sistema de control autom\u00e1tico es considerar que tiene tres partes esenciales que se denominan: Entrada, Salida y Control. Hasta ahora hemos estado utilizando dos de ellos, como sistema de control la micro:bit y como sistema de salida el LED. En la pr\u00e1ctica lo habitual es que alg\u00fan dispositivo detecte variables del entorno, que el sistema de control detecte los cambios y decida la acci\u00f3n que tiene que realizar con la salida. Si consideramos a estas tres partes como cajas que contienen los elementos de cada uno de ellos, un diagrama en bloques de un primer sistema de control autom\u00e1tico es:</p> <p> <p> Diagrama de un sistema de control autom\u00e1tico</p> <p></p>"},{"location":"actividades/A05/#circuito","title":"Circuito","text":"<p>Como elemento de entrada vamos a utilizar un pulsador, lo que nos obliga a escoger uno de los dos circuitos posibles para obtener una se\u00f1al de control a partir del mismo. Vamos a trabajar escogiendo el que por defecto nos entrega un nivel alto y cuando pulsamos un nivel bajo y lo vamos a conectar al pin P0 que actuar\u00e1 como entrada. Vamos a realizar un peque\u00f1o cambio respecto al circuito gen\u00e9rico visto y es que vamos a colocar una resistencia en serie con el pin P0, para de esta forma no conectar el pin directamente a GND cuando accionemos el pulsador. El circuito de salida es el del diodo LED que lo conectaremos en el pin P1.</p> <p> <p> Esquematico del circuito</p> <p></p> <p>El montaje puede ser similar al siguiente:</p> <p> <p> Montaje del circuito</p> <p></p>"},{"location":"actividades/A05/#micropython","title":"MicroPython","text":"<p>El programa es el siguiente:</p> <pre><code>from microbit import *\n\nwhile True:\n    #Estado_boton = pin0.read_digital()\n    #if Estado_boton == 0:\n    if pin0.read_digital() == 0:\n        pin1.write_digital(1)\n    else:\n        pin1.write_digital(0)\n</code></pre> <p>Se han puesto las dos l\u00edneas comentadas porque quiz\u00e1 sea la forma mas apropiada de hacer lo que se hace en la l\u00ednea <code>if pin0.read_digital() == 0:</code>, es decir asignar a variable el estado del pin y preguntar por el estado de la variable. El programa funciona exactamente igual como est\u00e1 que si lo cambiamos a este otro:</p> <pre><code>from microbit import *\n\nwhile True:\n    Estado_boton = pin0.read_digital()\n    if Estado_boton == 0:\n    #if pin0.read_digital() == 0:\n        pin1.write_digital(1)\n    else:\n        pin1.write_digital(0)\n</code></pre> <p>El programa lo podemos descargar de:</p> <ul> <li>A05-pulsador_LED</li> <li>A05-pulsador_LED</li> </ul>"},{"location":"actividades/A05/#makecode","title":"MakeCode","text":"<p>El programa es el siguiente:</p> <p> <p> A05-pulsador_LED</p> <p></p> <p>Aunque es bastante sencillo se ha explicado paso a paso en los comentarios.</p> <p>El programa lo podemos descargar de:</p> <ul> <li>A05-pulsador_LED</li> </ul>"},{"location":"actividades/A05/#microblocks","title":"MicroBlocks","text":"<p>Antres de nada vamos a repasar brevemente el funcionamiento del operador de igualdad. Al contrario que en otros programas en MicroBlocks no se dintingue un operador de asignaci\u00f3n (=) y un operador condicional de igualdad (==), sino que se hace en funci\u00f3n de los datos de los operandos del operador. En la imagen siguiente se expone lo que es correcto y lo que no.</p> <p> <p> Operador =</p> <p></p> <p>El programa funcionando tiene el siguiente aspecto:</p> <p> <p> A05-pulsador_LED</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>A05-pulsador_LED</li> </ul>"},{"location":"actividades/A05/#ampliacion-de-la-actividad","title":"Ampliaci\u00f3n de la actividad","text":"<p>Antes de nada vamos a indicar que solamente se aportan las soluciones de forma gr\u00e1fica, quedando como propuesta la actividad de crear los programas reales en cada aplicaci\u00f3n, montar el circuito y realizar la comprobaci\u00f3n del funcionamiento.</p> <p>El circuito utilizado en esta actividad es perfecto para crear un programa que tenga en cuenta la eliminaci\u00f3n de rebotes en pulsadores. De paso tambi\u00e9n servir\u00e1 como una forma de ver en que consiste la tarea de anidar sentencias condicionales.</p> <p>Los componentes y circuitos utilizados son los mismos que antes, pero va mos a establecer un funcionamiento diferente: Partiendo de la situaci\u00f3n inicial del LED apagado, cada vez que pulsemos el bot\u00f3n el LED cambiar\u00e1 su estado, encendiendose si estaba apagado o apagandose si estaba encendido. De esta forma la acci\u00f3n del interruptor ya no es moment\u00e1nea (como un pulsador normal), sino que permanece en uno de los estados sin necesidad de pulsar continuamente sobre el mismo. El funcionamiento es bastante cl\u00e1sico para muchas aplicaciones, como encender/apagar una l\u00e1mpara. Ver el funcionamiento del programa mas abajo, despu\u00e9s de las soluciones.</p>"},{"location":"actividades/A05/#solucion-micropython","title":"Soluci\u00f3n MicroPython","text":"<p> <p> A05_ampliaci\u00f3n-Interruptor para l\u00e1mpara</p> <p></p>"},{"location":"actividades/A05/#solucion-makecode","title":"Soluci\u00f3n MakeCode","text":"<p> <p> A05_ampliaci\u00f3n-Interruptor para l\u00e1mpara</p> <p></p>"},{"location":"actividades/A05/#solucion-microblocks","title":"Soluci\u00f3n MicroBlocks","text":"<p> <p> A05_ampliaci\u00f3n-Interruptor para l\u00e1mpara</p> <p></p>"},{"location":"actividades/A05/#funcionamiento-del-programa","title":"Funcionamiento del programa","text":"<p>Recordemos que el estado de la salida del circuito del pulsador con este en reposo es alto, por lo que detectar si se ha pulsado es comprobar si se ha puesto a estado bajo. El funcionamiento del programa es el siguiente:</p> <ul> <li>Primer if. Cuando el programa detecta que se pulsa el bot\u00f3n por primera vez, se establece un retardo de 10 ms para detectar si se vuelve a pulsar. Esto se hace con el fin de saltarse los rebotes de la pulsaci\u00f3n.</li> <li>Segundi if. Si transcurridos los 10 ms se sigue detectando el bot\u00f3n como pulsado ya podemos considerar de forma estable que el bot\u00f3n ha sido pulsado. En caso contrario, se considerar\u00e1 como un rebote y el programa dejar\u00e1 de detectar.</li> <li>Tercer if. Cuando se determina que la tecla est\u00e1 pulsada, se cambia el valor de la variable, que se utiliza para guardar el estado del LED. Tras cambiar el estado de la variable se realiza la escritura en P1 con su nuevo valor.</li> <li>While. Si se cumple la condici\u00f3n es que hemos dejado de accionar el pulsador por lo que se mientras se cumpla la condici\u00f3n se genera un retardo de 10 ms para eliminar el retardo de liberaci\u00f3n del pulsador. primero eliminar\u00e1 el rebote del bot\u00f3n.</li> </ul>"},{"location":"actividades/A06/","title":"Matriz de de barras de LEDs","text":"<p>Vamos a hacer un proyecto sencillo que haga que los LEDs se enciendan y apaguen simulando un desplazamiento del LED encendido. Jugaremos un poco con el valor de los retardos para dar sensaci\u00f3n de aceleraci\u00f3n.</p> <p>Lo primero que tenemos que hacer es recurrir al pinout del borde de placa y realizar una asignaci\u00f3n de pines de borde a cada diodo y as\u00ed saber en que orden trabajar con los mismos. Esto nos permitir\u00e1, en el caso de Python y MicroBlocks, crear una lista con los pines de borde de placa elegidos y ordenados como nos interese. En el caso de MakeCode lo haremos de manera manual. En la imagen vemos el orden asignado.</p> <p> <p> Asignaci\u00f3n de pines a diodos de la barra de LEDs</p> <p></p>"},{"location":"actividades/A06/#circuito","title":"Circuito","text":"<p>El esquema del circuito que tenemos que montar con esa asignaci\u00f3n de pines es:</p> <p> <p> Esquema del circuito</p> <p></p> <p>El montaje en protoboard tendr\u00e1 un aspecto similar al siguiente.</p> <p> <p> Montaje del circuito</p> <p></p>"},{"location":"actividades/A06/#micropython","title":"MicroPython","text":"<p>El c\u00f3digo es:</p> <pre><code>from microbit import *\n\n#Permite usar los pines de pantalla como entradas externas\ndisplay.off() \n\n#Creamos la lista de pines reasignando el 5 a pin0\npines_salida =[pin1,pin2,pin3,pin4,pin0,pin6,pin7,pin8,pin9,pin10]\n\nwhile True:\n    for pin in pines_salida:\n        pin.write_digital(1)\n        sleep(150)\n        pin.write_digital(0)\n        sleep(5)\n</code></pre> <p>El programa lo podemos descargar de:</p> <ul> <li>A06-barra_10_LEDs</li> <li>A06-barra_10_LEDs</li> </ul>"},{"location":"actividades/A06/#makecode","title":"MakeCode","text":"<p>El programa lo hemos dividido en tres sectores para ponerlo en horizontal y que se vea en una sola imagen. El bloque 'activar led' hay que ponerlo en <code>False</code> para poder utilizar como pines de salida los que est\u00e1n asignados por defecto a los LEDs de la pantalla. El pin P5 se ha asignado a P0 porque en P5 est\u00e1 el bot\u00f3n A de la placa y por tanto es una entrada.</p> <p> <p> LED que se desplaza con barra de 10 LEDs</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>microbit-A06-barra_10_LEDs</li> </ul>"},{"location":"actividades/A06/#microblocks","title":"MicroBlocks","text":"<p>En la animaci\u00f3n vemos el programa funcionando.</p> <p> <p> LED que se desplaza con barra de 10 LEDs</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>A06-barra_10_LEDs</li> </ul>"},{"location":"actividades/A07/","title":"Diodo LED RGB","text":"<p>Utilizaremos un LED RGB de \u00e1nodo com\u00fan para desarrollar la actividad, lo que significa que los LED se iluminar\u00e1n cuando llevemos el pin de cada color a GND y tengamos el \u00e1nodo a 3.3V. La actividad va a consistir en hacer que el LED parpadee a intervalos de un segundo entre un color aleatorio y estar apagado.</p>"},{"location":"actividades/A07/#circuito","title":"Circuito","text":"<p>El esquema del circuito que vamos a utilizar es el siguiente:</p> <p> <p> Esquema del circuito</p> <p></p> <p>Los pines van a trabajar como pines de salida anal\u00f3gicos.</p> <p>\u00bfHay que colocar una resistencia para cada diodo? La respuesta es que SI, porque internamente son tres diodos individuales que lo \u00fanico que tienen en com\u00fan es el encapsulado y que se han unidos sus \u00e1nodos en un solo pin.</p> <p>El montaje a realizar es el siguiente:</p> <p> <p> Montaje del circuito</p> <p></p>"},{"location":"actividades/A07/#micropython","title":"MicroPython","text":"<p>El c\u00f3digo del programa es:</p> <pre><code>from microbit import *\n\n#Importamos m\u00f3dulo random\nimport random\n\nwhile True:\n    #Generamos RGB aleatorio\n    R=random.randint(0,1023)\n    G=random.randint(0,1023)\n    B=random.randint(0,1023)\n\n    #Escribe RGB aleatorio en pines\n    pin2.write_analog(R)\n    pin1.write_analog(G)\n    pin0.write_analog(B)\n    sleep(1000)\n\n    #Apaga los tres LED\n    pin2.write_analog(1023)\n    pin1.write_analog(1023)\n    pin0.write_analog(1023)\n    sleep(1000)\n</code></pre> <p>El programa lo podemos descargar de:</p> <ul> <li>A07-parpadeo_aleatorio_RGB</li> <li>A07-parpadeo_aleatorio_RGB</li> </ul>"},{"location":"actividades/A07/#makecode","title":"MakeCode","text":"<p>En la animaci\u00f3n tenemos una captura del programa y del simulador, donde podemos apreciar como cambian los n\u00fameros aleatorios cada segundo y como tambi\u00e9n como todos los pines toman el valor m\u00e1ximo que equivale a LED apagado.</p> <p> <p></p> <p>Parpadeo color aleatorio LED RGB</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>A07-parpadeo_aleatorio_RGB</li> </ul>"},{"location":"actividades/A07/#microblocks","title":"MicroBlocks","text":"<p>En la imagren vemos el programa en un instante de su funcionamiento.</p> <p> <p></p> <p>Parpadeo color aleatorio LED RGB</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>A07-parpadeo_aleatorio_RGB</li> </ul>"},{"location":"actividades/A08/","title":"Diodos LEDs RGB direccionables","text":"<p>En el apartado correspondiente de teor\u00eda se han visto muchos ejemplos para MakeCode, vamos a trabajar con un ejemplo sencillo en los tres programas que estamos viendo.</p> <p>La actividad va a consistir en encender, progresivamente el tono del color, los 8 LED en los colors base RGB, despu\u00e9s hacer que se enciendan uno a uno en un color aleatorio y finalemente hacer que cambien de color de forma aleatoria durante un tiempo.</p>"},{"location":"actividades/A08/#circuito","title":"Circuito","text":"<p>El esquema del circuito que vamos a utilizar es el siguiente:</p> <p> <p> Esquema del circuito</p> <p></p> <p>El montaje a realizar es el siguiente:</p> <p> <p> Montaje del circuito</p> <p></p>"},{"location":"actividades/A08/#micropython","title":"MicroPython","text":"<p>El programa es el siguiente:</p> <pre><code>from microbit import *\nimport neopixel\nfrom random import randint\n\n# Configuramos los Neopixel en pin0 y tira de 8 pixeles\nneo = neopixel.NeoPixel(pin0, 8)\nnum_pixel = 0\n\nwhile True:\n\n    #Iteramos el color rojo\n    for rojo in range(0,255):\n        for num_pixel in range(0, len(neo)):\n            neo[num_pixel] = (rojo,0,0)\n            sleep(1/1000) #retardo de 1us\n            neo.show()\n\n    #Iteramos el color verde\n    for verde in range(0,255):\n        for num_pixel in range(0, len(neo)):\n            neo[num_pixel] = (0,verde,0)\n            sleep(1/1000)\n            neo.show()\n\n    #Iteramos el color azul\n    for azul in range(0,255):\n        for num_pixel in range(0, len(neo)):\n            neo[num_pixel] = (0,0,azul)\n            sleep(1/1000)\n            neo.show()\n\n    #Iteramos sobre cada LED con color aleatorio\n    neo.clear()\n    for num_pixel in range(0, len(neo)):\n        R = randint(0, 255)\n        G = randint(0, 255)\n        B = randint(0, 255)\n        neo[num_pixel] = (R,G,B)\n        sleep(500)\n        neo.show()   \n\n  #Iteramos todos los LEDs con un color diferente y aleatorio para cada uno\n    neo.clear()\n    for color in range(0,255):\n        for num_pixel in range(0, len(neo)):\n            R = randint(0, color)\n            G = randint(0, color)\n            B = randint(0, color)\n            neo[num_pixel] = (R,G,B)\n            sleep(1)\n            neo.show()\n</code></pre> <p>El programa lo podemos descargar de:</p> <ul> <li>A08-Neopixels_python</li> <li>A08-Neopixels_python</li> </ul>"},{"location":"actividades/A08/#makecode","title":"MakeCode","text":"<p>El programa es el siguiente:</p> <p> <p> Trabajo con Neopixels</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>A08-Neopixels</li> </ul>"},{"location":"actividades/A08/#microblocks","title":"MicroBlocks","text":"<p>Aspecto del programa en MicroBlocks:</p> <p> <p> A08-Neopixels</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>A08-Neopixels</li> </ul>"},{"location":"actividades/A09/","title":"Zumbador o buzzer","text":"<p>En este caso la actividad va a estar compuesta por cuatro proyectos y se har\u00e1n todos montando elementos externos a la micro:bit. Si disponemos de una versi\u00f3n V2 las tres actividades primeras o bien funcionan directamente en el altavoz que incorpora o bien son facilmente adaptables. La \u00faltima actividad no es realizable sin una micro:bit V2.</p>"},{"location":"actividades/A09/#circuito","title":"Circuito","text":"<p>El esquema del circuito que vamos a utilizar es el siguiente:</p> <p> <p> Esquema del circuito</p> <p></p> <p>El montaje a realizar es el siguiente:</p> <p> <p> Montaje del circuito</p> <p></p>"},{"location":"actividades/A09/#a09-1-buzzer-activo","title":"A09-1. Buzzer activo","text":"<p>El programa repetir\u00e1 5 veces sucesivas un pitido durante 200 ms, realizar\u00e1 una pausa de 2 segundos y volver\u00e1 a repetirse indefinidamente.</p>"},{"location":"actividades/A09/#micropython","title":"MicroPython","text":"<p>El programa es:</p> <pre><code>from microbit import *\n\nwhile True:\n    for i in range(5):\n        pin0.write_digital(1)\n        sleep(200)\n        pin0.write_digital(0)\n        sleep(200)\n    sleep(2000)\n</code></pre> <p>El programa lo podemos descargar de:</p> <ul> <li>A09-1_Buzzer_activo</li> <li>A09-1_Buzzer_activo</li> </ul>"},{"location":"actividades/A09/#makecode","title":"MakeCode","text":"<p>El programa es:</p> <p> <p> A09-1. Buzzer activo</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>microbit-A09-1_Buzzer_activo</li> </ul>"},{"location":"actividades/A09/#microblocks","title":"MicroBlocks","text":"<p>Este es el programa:</p> <p> <p> A09-1. Buzzer activo</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>A09-1_Buzzer_activo</li> </ul>"},{"location":"actividades/A09/#a09-2-buzzer-pasivo-notas","title":"A09-2. Buzzer pasivo. Notas","text":"<p>El programa va a consistir en que cuando pulsamos la tecla A se reproduce la escala normal y cuando se pulsa la B la escala con las notas en sostenido.</p>"},{"location":"actividades/A09/#micropython_1","title":"MicroPython","text":"<p>El programa es:</p> <pre><code>from microbit import *\nimport music\n\nnotas = ['C','D','E','F','G','A','B']\nnotasS = ['C#','D#','E','F#','G#','A#','B']\nwhile True:\n    if button_a.is_pressed():\n        music.play(notas)\n    if button_b.is_pressed():\n        music.play(notasS)\n</code></pre> <p>El programa lo podemos descargar de:</p> <ul> <li>A09-2_Buzzer-pasivo_Notas</li> <li>A09-2_Buzzer-pasivo_Notas</li> </ul>"},{"location":"actividades/A09/#makecode_1","title":"MakeCode","text":"<p>El programa es:</p> <p> <p> A09-2. Buzzer pasivo. Notas</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>A09-2_Buzzer pasivo_Notas</li> </ul>"},{"location":"actividades/A09/#microblocks_1","title":"MicroBlocks","text":"<p>Este es el programa:</p> <p> <p> A09-2. Buzzer pasivo. Notas</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>A09-2_Buzzer-pasivo_Notas</li> </ul>"},{"location":"actividades/A09/#a09-3-buzzer-pasivo-melodia","title":"A09-3. Buzzer pasivo. Melodia","text":"<p>En este caso haremos sonar una melodia de las que acompa\u00f1an a los diferentes programas cuando pulsamos el bot\u00f3n A y otra cuando pulsamos el B. En el caso de MakeCode ser\u00e1 una melodia y un tono RTTTL y en el caso de MicroBlocks ser\u00e1n dos tonos RTTTL.</p>"},{"location":"actividades/A09/#micropython_2","title":"MicroPython","text":"<p>El programa es:</p> <pre><code>from microbit import *\nimport music\n\nwhile True:\n    if button_a.is_pressed():\n        music.play(music.BIRTHDAY)\n    if button_b.is_pressed():\n        music.play(music.ODE)\n</code></pre> <p>El programa lo podemos descargar de:</p> <ul> <li>A09-3_Buzzer_pasivo_Melodia</li> <li>A09-3_Buzzer_pasivo_Melodia</li> </ul>"},{"location":"actividades/A09/#makecode_2","title":"MakeCode","text":"<p>El programa es:</p> <p> <p> A09-3_Buzzer_pasivo_Melodia</p> <p></p> <p>En este caso hemos utilizado el bloque \"convert RTTTL \" \" to melody\":</p> <p> <p></p> <p></p> <p>En el que hemos pegado un trozo del politono de la Marcha Imperial de Star Wars:</p> <pre><code>StarWars:d=4,o=5,b=112:8d.,16p,8d.,16p,8d.,16p,8a#4,16p,16f,8d.,16p, 8a#4,16p,16f,\n\nd.,8p,8a.,16p,8a.,16p,8a.,16p,8a#,16p,16f,8c#.,16p,8a#4,16p,16f,d.,8p,8d.6,16p,8d,\n\n16p,16d,8d6,8p,8c#6,16p,16c6,16b,16a#,8b,8p,16d#,16p,8g#,8p,8g,16p,16f#,16f,16e,8f,\n\n8p,16a#4,16p,8c#,8p,8a#4,16p,16c#,8f.,16p,8d,16p,16f,a.,8p,8d.6,16p,8d,16p,16d,8d6,\n\n8p,8c#6,16p,16c6,16b,16a#,8b,8p,16d#,16p,8g#,8p,8g,16p,16f#,16f,16e,8f,8p,16a#4,16p,8c#\n</code></pre> <p>La cadena de texto debe ir toda seguida sin espacios ni retornos de l\u00ednea.</p> <p>El programa lo podemos descargar de:</p> <ul> <li>A09-3_Buzzer_pasivo_Melodia</li> </ul>"},{"location":"actividades/A09/#microblocks_2","title":"MicroBlocks","text":"<p>Este es el programa:</p> <p> <p> A09-3_Buzzer_pasivo_Melodia</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>A09-3_Buzzer_pasivo_Melodia</li> </ul>"},{"location":"actividades/A09/#a09-4-brujula","title":"A09-4. Br\u00fajula","text":""},{"location":"actividades/A09/#micropython_3","title":"MicroPython","text":"<p>El programa es:</p> <pre><code>from microbit import *\nimport music\n\nwhile True:\n    display.scroll(display.read_light_level())\n    sleep(1000)   \n    if display.read_light_level() &gt;= 80:\n        #H = High- nivel de iluminaci\u00f3n alto\n        display.show(\"H\")\n        music.play(music.ENTERTAINER)\n        display.show(Image.CHESSBOARD)\n    else:\n        display.clear()\n        #L = Low- nivel de iluminaci\u00f3n bajo\n        display.show(\"L\")\n        music.play(music.NYAN)\n        display.show(Image.DIAMOND_SMALL)\n</code></pre> <p>El programa lo podemos descargar de:</p> <ul> <li>Avisador_nivel_iluminacion</li> <li>Avisador_nivel_iluminacion</li> </ul>"},{"location":"actividades/A09/#makecode_3","title":"MakeCode","text":"<p>El programa es:</p> <p> <p> A09-4. Avisador nivel iluminaci\u00f3n</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>Avisador_nivel_iluminacion</li> </ul>"},{"location":"actividades/A09/#microblocks_3","title":"MicroBlocks","text":"<p>Este es el programa:</p> <p> <p> A09-4. Avisador nivel iluminaci\u00f3n</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>Avisador_nivel_iluminacion</li> </ul>"},{"location":"actividades/A10/","title":"Comunicaci\u00f3n serie","text":"<p>Utilizaremos el puerto serie para enviar y recibir datos.</p>"},{"location":"actividades/A10/#circuito","title":"Circuito","text":"<p>No se requiere de ning\u00fan elemento externo por lo que o bien conectamos la micro:bit directamente o bien a trav\u00e9s de la placa de expansi\u00f3n.</p> <p> <p> Conexionado de la micro:bit</p> <p></p>"},{"location":"actividades/A10/#micropython","title":"MicroPython","text":"<p>Un programa como el siguiente:</p> <pre><code>from microbit import *\n\ncuenta=0\n# Code in a 'while True:' loop repeats forever\nwhile True:\n    uart.write('Contador: '+str(cuenta)+\"\\r\\n\")\n    sleep(1000)\n    cuenta=cuenta+1\n</code></pre> <p>Es la forma de crear un contador en MicroPython y enviar los datos via serie.</p> <p>En la animaci\u00f3n siguiente vemos el resultado en el simulador y su consola serie.</p> <p> <p> Simulador. Contador en el puerto serie</p> <p></p> <p>A continuaci\u00f3n vemos el resultado en la realidad.</p> <p> <p> Dispositivo. Contador en el puerto serie</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>A10-Contador_puerto_serie</li> <li>A10-Contador_puerto_serie</li> </ul>"},{"location":"actividades/A10/#makecode","title":"MakeCode","text":"<p>El programa que vamos a hacer es simplemente crear un contador infinito e ir escribiendo el valor que toma cada segundo en el puerto serie.</p> <p> <p> Contador en el puerto serie</p> <p></p> <p>Ya conocemos algunas formas de visualizar el dato que se est\u00e1 escribiendo en el puerto serie. Veamos ahora los dos disponibles mediante webUSB. Debajo de la imagen de la microbit hay disponibles dos botones grandes:</p> <ul> <li>Show data Simulador. Nos abre a la derecha, sustituyendo la ventana de programa, una ventana dividia en dos partes, en la superior se va graficando el dato enviado por el bloque de escritura y en la inferior se va mostrando en forma de texto. Siempre referido a los datos enviados por el simulador En la animaci\u00f3n siguiente lo vemos funcionando.</li> </ul> <p> <p> Simulador. Contador en el puerto serie</p> <p></p> <ul> <li>Show data Dispositivo. Nos abre a la derecha, sustituyendo la ventana de programa, una ventana dividia en dos partes, en la superior se va graficando el dato enviado por el bloque de escritura y en la inferior se va mostrando en forma de texto. Ahora los datos que vemos son los enviados por la placa micro:bit conectada y en la que se ejecuta el programa. En la animaci\u00f3n siguiente lo vemos funcionando.</li> </ul> <p> <p> Dispositivo. Contador en el puerto serie</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>A10-Contador_puerto_serie</li> </ul>"},{"location":"actividades/A10/#microblocks","title":"MicroBlocks","text":"<p>Con los bloques que implementa MicroBlocks no me ha sido posible realizar una escritura y lectura correctas del puerto serie. Un programa como el siguiente:</p> <p> <p> Programa contador en el puerto serie</p> <p></p> <p>Nos devuelve un resultado poco claro.</p> <p> <p> Consola PuTTY para el programa contador en el puerto serie</p> <p></p> <p>Aunque si aparecen algunos n\u00fameros al cabo de un tiempo todas las tareas se detienen y ya no se recibe nada.</p> <p>En la wiki de MicroBlocks podemos encontrar la entrada How Does Serial Communications Work? si se quiere profundizar en el tema, pero para el nivel que tenemos en este momento esto queda fuera de nuestro alcance. En cualquier caso, en esa misma entrada se aconseja, para trabajar con la uart, que escribamos nuestro propio c\u00f3digo.</p> <p>Para no dejar vac\u00eda la secci\u00f3n realizaremos el programa de la actividad con el editor Mu que incorpora REPL. El programa es:</p> <pre><code>from microbit import *\n\ncuenta = 0\n\nwhile True:\n    uart.write(\"Contador: \" + str(cuenta) + \"\\r\\n\")\n    sleep(1000)\n    cuenta = cuenta + 1\n</code></pre> <p>Una vez flasheado el programa abrimos PERL y vemos como el contador est\u00e1 funcionando sin problemas.</p> <p> <p> PERL en Mu  para el programa contador en el puerto serie</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>A10-Contador_puerto_serie-Mu</li> </ul>"},{"location":"actividades/A11/","title":"Magnet\u00f3metro","text":"<p>Magnet\u00f3metro Aceler\u00f3metro</p> <p>La actividad va a consistir en crear una br\u00fajula electr\u00f3nica que nos muestre una flecha que siempre apunte al norte geogr\u00e1fico. Dividimos la actividad en dos partes, la primera hacemos que encuentre el rumbo y nos muestre una letra que indique si la orientaci\u00f3n es al norte (N), al sur (S), al este (E), o al oeste (O).</p>"},{"location":"actividades/A11/#circuito","title":"Circuito","text":"<p>No se requiere de ning\u00fan elemento externo por lo que o bien conectamos la micro:bit directamente o bien a trav\u00e9s de la placa de expansi\u00f3n.</p> <p> <p> Conexionado de la micro:bit</p> <p></p> <p>Volver </p>"},{"location":"actividades/A11/#-magnetometro-","title":"- Magnet\u00f3metro -","text":""},{"location":"actividades/A11/#micropython","title":"MicroPython","text":""},{"location":"actividades/A11/#a11-brujula-nseo","title":"A11-Br\u00fajula N,S,E,O","text":"<p>El programa, de muy poca precisi\u00f3n es el siguiente:</p> <pre><code>from microbit import *\n\ncompass.calibrate()\nwhile True:\n    angulo = compass.heading()\n    if angulo &lt; 45:\n        display.show(\"N\")\n    elif angulo &lt; 135:\n        display.show(\"E\")\n    elif angulo &lt; 225:\n        display.show(\"S\")\n    elif angulo &lt; 315:\n        display.show(\"O\")\n    else:\n        display.show(\"N\")\n</code></pre> <p>El programa lo podemos descargar de:</p> <ul> <li>A11-Br\u00fajula-NSEO</li> <li>A11-Br\u00fajula-NSEO</li> </ul>"},{"location":"actividades/A11/#a11-brujula-a-45o","title":"A11-Br\u00fajula a 45\u00ba","text":"<p>Lo que vamos a hacer ahora es localizar las siguientes ocho direcciones, separadas entre si un \u00e1ngulo de 45\u00ba: noroeste (NE), oeste (O), suroeste (SO), sur (S), sureste (SE), este (E), noreste (NE), norte (N). El margen o \u00e1ngulo que va a englobar cada direcci\u00f3n estar\u00e1 ajustado dentro de otro \u00e1ngulo de 45\u00ba dividido en dos iguales de 22.5\u00ba respecto a la direcci\u00f3n principal. Un gr\u00e1fico nos aclara mejor la idea.</p> <p> <p> Direcciones a 45\u00ba</p> <p></p> <p>En lugar de letras ahora utilizaremos las flechas predefinidas.</p> <p>El programa es:</p> <pre><code>from microbit import *\n\ncompass.calibrate()\nwhile True:\n    angulo = compass.heading()\n    if angulo &gt; 22.5 and angulo &lt;= 67.5:\n        display.show(Image.ARROW_NE)\n    elif angulo &gt; 67.5 and angulo &lt;= 112.5:\n        display.show(Image.ARROW_E)\n    elif angulo &gt; 112.5 and angulo &lt;= 157.5:\n        display.show(Image.ARROW_SE)\n    elif angulo &gt; 157.5 and angulo &lt;= 202.5:\n        display.show(Image.ARROW_S)\n    elif angulo &gt; 202.5 and angulo &lt;= 247.5:\n        display.show(Image.ARROW_SW)\n    elif angulo &gt; 247.5 and angulo &lt;= 292.5:\n        display.show(Image.ARROW_W)\n    elif angulo &gt; 292.5 and angulo &lt;= 337.5:\n        display.show(Image.ARROW_NW)\n    elif angulo &gt; 337.5 and angulo &lt;= 22.5:\n        display.show(Image.ARROW_N)\n</code></pre> <p>El programa lo podemos descargar de:</p> <ul> <li>A11-Br\u00fajula a 45\u00ba</li> <li>A11-Br\u00fajula a 45\u00ba</li> </ul>"},{"location":"actividades/A11/#makecode","title":"MakeCode","text":""},{"location":"actividades/A11/#a11-brujula-nseo_1","title":"A11-Br\u00fajula N,S,E,O","text":"<p>El programa, de muy poca precisi\u00f3n es el siguiente:</p> <p> <p> Br\u00fajula N,S,E,O</p> <p></p> <p>Podemos ver el funcionamiento tanto en el simulador como en la realidad y apreciar la poca precisi\u00f3n que nos ofrece.</p> <p>El programa lo podemos descargar de:</p> <ul> <li>A11-Br\u00fajula-NSEO</li> </ul>"},{"location":"actividades/A11/#a11-brujula-a-45o_1","title":"A11-Br\u00fajula a 45\u00ba","text":"<p>Lo que vamos a hacer ahora es localizar las siguientes ocho direcciones, separadas entre si un \u00e1ngulo de 45\u00ba: noroeste (NE), oeste (O), suroeste (SO), sur (S), sureste (SE), este (E), noreste (NE), norte (N). El margen o \u00e1ngulo que va a englobar cada direcci\u00f3n estar\u00e1 ajustado dentro de otro \u00e1ngulo de 45\u00ba dividido en dos iguales de 22.5\u00ba respecto a la direcci\u00f3n principal. Un gr\u00e1fico nos aclara mejor la idea.</p> <p> <p> Direcciones a 45\u00ba</p> <p></p> <p>En lugar de letras ahora utilizaremos las flechas predefinidas en el bloque correspondiente.</p> <p>El programa es:</p> <p> <p> Br\u00fajula con direcciones a 45\u00ba</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>A11_brujula45</li> </ul>"},{"location":"actividades/A11/#editor-mu","title":"Editor Mu","text":""},{"location":"actividades/A11/#a11-brujula-nseo_2","title":"A11-Br\u00fajula N,S,E,O","text":"<p>El programa, de muy poca precisi\u00f3n es el siguiente:</p> <pre><code>from microbit import *\n\ncompass.calibrate()\nwhile True:\n    angulo = compass.heading()\n    if angulo &lt; 45:\n        display.show(\"N\")\n    elif angulo &lt; 135:\n        display.show(\"E\")\n    elif angulo &lt; 225:\n        display.show(\"S\")\n    elif angulo &lt; 315:\n        display.show(\"O\")\n    else:\n        display.show(\"N\")\n</code></pre> <p>El programa lo podemos descargar de:</p> <ul> <li>A11-Br\u00fajula-NSEO</li> </ul>"},{"location":"actividades/A11/#a11-brujula-a-45o_2","title":"A11-Br\u00fajula a 45\u00ba","text":"<p>Lo que vamos a hacer ahora es localizar las siguientes ocho direcciones, separadas entre si un \u00e1ngulo de 45\u00ba: noroeste (NE), oeste (O), suroeste (SO), sur (S), sureste (SE), este (E), noreste (NE), norte (N). El margen o \u00e1ngulo que va a englobar cada direcci\u00f3n estar\u00e1 ajustado dentro de otro \u00e1ngulo de 45\u00ba dividido en dos iguales de 22.5\u00ba respecto a la direcci\u00f3n principal. Un gr\u00e1fico nos aclara mejor la idea.</p> <p> <p> Direcciones a 45\u00ba</p> <p></p> <p>En el editor Mu tambi\u00e9n son v\u00e1lidas las definiciones predefinidas para las flechas.</p> <p>El programa es:</p> <pre><code>from microbit import *\n\ncompass.calibrate()\nwhile True:\n    angulo = compass.heading()\n    if angulo &gt; 22.5 and angulo &lt;= 67.5:\n        display.show(Image.ARROW_NE)\n    elif angulo &gt; 67.5 and angulo &lt;= 112.5:\n        display.show(Image.ARROW_E)\n    elif angulo &gt; 112.5 and angulo &lt;= 157.5:\n        display.show(Image.ARROW_SE)\n    elif angulo &gt; 157.5 and angulo &lt;= 202.5:\n        display.show(Image.ARROW_S)\n    elif angulo &gt; 202.5 and angulo &lt;= 247.5:\n        display.show(Image.ARROW_SW)\n    elif angulo &gt; 247.5 and angulo &lt;= 292.5:\n        display.show(Image.ARROW_W)\n    elif angulo &gt; 292.5 and angulo &lt;= 337.5:\n        display.show(Image.ARROW_NW)\n    elif angulo &gt; 337.5 and angulo &lt;= 22.5:\n        display.show(Image.ARROW_N)\n</code></pre> <p>El programa lo podemos descargar de:</p> <ul> <li>A11-Br\u00fajula a 45\u00ba</li> </ul> <p>Volver </p>"},{"location":"actividades/A11/#-acelerometro-","title":"- Aceler\u00f3metro -","text":"<p>Vamos a obtener las medidas de acelaraci\u00f3n y ver los resultados en la consola serie. Una segunda actividad va a consistir en implementar un gradi\u00f3metro, que es un dispositivo que permite medir una componente del gradiente de un campo magn\u00e9tico. Cuando hablamos de campos magn\u00e9ticos, gradiente hace referencia a las variaciones de los mismos en periodos de tiempo muy cortos.</p>"},{"location":"actividades/A11/#micropython_1","title":"MicroPython","text":""},{"location":"actividades/A11/#a11-aceleraciones","title":"A11-Aceleraciones","text":"<p>El programa lo vamos a hacer en el editor Mu para aprovechar su trazador gr\u00e1fico.</p> <pre><code>from microbit import *\n\nwhile True:\n    uart.write(str(accelerometer.get_values()) + \"\\r\\n\")\n    sleep(1000)\n</code></pre> <p>Ponemos en marcha el trazador, y la comunicaci\u00f3n serie REPL despu\u00e9s de flashear el programa. Hacemos reset de la micro:bit y podemos ver la evoluci\u00f3n de las lecturas con los movimientos de la placa.</p> <p> <p> Aceleraciones en x, y, z</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>A11_aceleraciones</li> </ul>"},{"location":"actividades/A11/#a11-gradiometro","title":"A11-Gradi\u00f3metro","text":"<p>El programa es:</p> <pre><code>from microbit import *\n# El brillo estara entre 0 y 9\nbrillo = 9 \n# La funcion mapear ajusta los valores \n# leidos y los lleva al rango 0-4.\ndef mapear(valor):   \n    if valor &lt; -500:\n        valor=-500\n    elif valor &gt; 500:\n        valor=500\n    valor=(valor+500)/250\n    return int(valor)\n\nwhile True:\n    # Lee la aceleraci\u00f3n en x e y con un\n    #rango que va de -2000 a 2000.\n    roll_x = accelerometer.get_x()\n    pitch_y = accelerometer.get_y()\n    # No necesitamos un rango tan amplio por\n    # eso lo bajamos de -500 a 500\n    x=mapear(roll_x)\n    y=mapear(pitch_y)\n    display.clear()\n    display.set_pixel(x, y, brillo)\n    sleep(500)\n</code></pre> <p>El programa lo podemos descargar de:</p> <ul> <li>A11-A11_gradiometro</li> <li>A11-A11_gradiometro</li> </ul>"},{"location":"actividades/A11/#makecode_1","title":"MakeCode","text":""},{"location":"actividades/A11/#a11-aceleraciones_1","title":"A11-Aceleraciones","text":"<p>El programa para medir la aceleraci\u00f3n en los tres ejes es:</p> <p> <p> Aceleraciones en x, y, z</p> <p></p> <p>Pero lo mejor del programa no es \u00e9l en si mismo sino ver los resultados tanto de forma gr\u00e1fica como num\u00e9rica. Aqu\u00ed los vemos en la simulaci\u00f3n.</p> <p> <p> Aceleraciones en x, y, z. Simulaci\u00f3n</p> <p></p> <p>Estos otros corresponden a una placa real.</p> <p> <p> Aceleraciones en x, y, z. Realidad</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>A11_aceleraciones</li> </ul>"},{"location":"actividades/A11/#a11-gradiometro_1","title":"A11-Gradi\u00f3metro","text":"<p>El programa lo vemos en la figura siguiente.</p> <p> <p> Gradi\u00f3metro</p> <p></p> <p>En la animaci\u00f3n vemos el funcionamiento en el simulador.</p> <p> <p> Gradi\u00f3metro en el simulador</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>A11_gradiometro</li> </ul>"},{"location":"actividades/A11/#microblocks","title":"MicroBlocks","text":""},{"location":"actividades/A11/#a11-aceleraciones_2","title":"A11-Aceleraciones","text":"<p>El programa para medir la aceleraci\u00f3n en los tres ejes es:</p> <p> <p> Aceleraciones en x, y, z</p> <p></p> <p>El programa en funcionamiento es el siguiente:</p> <p> <p> Aceleraciones en x, y, z</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>A11_aceleraciones</li> </ul>"},{"location":"actividades/A11/#a11-gradiometro_2","title":"A11-Gradi\u00f3metro","text":"<p>El programa es:</p> <p> <p> Gradi\u00f3metro</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>A11_gradiometro</li> </ul>"},{"location":"actividades/A12/","title":"Entrada anal\u00f3gica. El potenci\u00f3metro","text":"<p>Leer diferentes tensiones anal\u00f3gicas obtenidas a partir de un potenci\u00f3metro.</p>"},{"location":"actividades/A12/#circuito","title":"Circuito","text":"<p>El esquema del circuito a montar es:</p> <p> <p> Esquema de montaje</p> <p></p> <p>El conexionado del potenci\u00f3metro es:</p> <p> <p> Conexionado de la micro:bit</p> <p></p>"},{"location":"actividades/A12/#micropython","title":"MicroPython","text":"<p>El programa para mostrar datos de forma num\u00e9rica es el siguiente:</p> <pre><code>from microbit import *\n\nwhile True:\n    lectura_ADC = pin0.read_analog()\n    ADC_voltios = lectura_ADC/1024*3.3\n    uart.write(\"Voltaje: \" + str(ADC_voltios))\n    uart.write(\"\\r\\n\")\n    sleep(1000)\n</code></pre> <p>Que arroja estos resultados en PuTTY:</p> <p> <p> A12-Entrada_analogica_potenciometro en PuTTY</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>A12-potenci\u00f3metro</li> <li>A12-potenci\u00f3metro</li> </ul>"},{"location":"actividades/A12/#makecode","title":"MakeCode","text":"<p>El programa para mostrar datos de forma gr\u00e1fica y num\u00e9rica es el siguiente:</p> <p> <p> A12-Entrada_analogica_potenciometro</p> <p></p> <p>En la animaci\u00f3n vemos el resultado pr\u00e1ctico del programa.</p> <p> <p> A12-Entrada_analogica_potenciometro</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>A12-potenci\u00f3metro</li> </ul> <p>Si tan solo necesitamos ver los datos de forma num\u00e9rica el programa ser\u00e1:</p> <p> <p> A12-Entrada_analogica_potenciometro</p> <p></p>"},{"location":"actividades/A12/#microblocks","title":"MicroBlocks","text":"<p>El programa lo haremos de la forma siguiente:</p> <p> <p> A12-Entrada_analogica_potenciometro</p> <p></p> <p>Una captura en un momento del funcionamiento es la siguiente:</p> <p> <p> A12-Entrada_analogica_potenciometro</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>A12-potenci\u00f3metro</li> </ul>"},{"location":"actividades/A13/","title":"Control con potenci\u00f3metro de LED, LED RGB y Neopixel","text":"<p>Dividiremos la actividad en tres, una para cada tipo de elemento.</p> <p></p> <p>Diodo LED Diodo LED RGB LED RGB direccionable. Neopixel</p> <p>Volver </p> <p> <p>Diodo LED</p> <p></p>"},{"location":"actividades/A13/#circuito","title":"Circuito","text":"<p>Vamos a montar el siguiente esquema:</p> <p> <p> Esquema de montaje A13-1 LED</p> <p></p>"},{"location":"actividades/A13/#micropython","title":"MicroPython","text":"<p>El programa es:</p> <pre><code>from microbit import *\n\nwhile True:\n    pin1.write_analog(pin0.read_analog())\n</code></pre> <p>El programa lo podemos descargar de:</p> <ul> <li>A13-1_control_LED_pot</li> <li>A13-1_control_LED_pot</li> </ul>"},{"location":"actividades/A13/#makecode","title":"MakeCode","text":"<p>Leemos el valor anal\u00f3gico de tensi\u00f3n que entrega el pin P0 e indicamos que ese mismo valor se escriba en el pin P1. El programa es:</p> <p> <p> Programa control LED con potenci\u00f3metro</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>A13-1_control_LED_potenciometro</li> </ul>"},{"location":"actividades/A13/#microblocks","title":"MicroBlocks","text":"<p>El programa tiene este aspecto:</p> <p> <p> Programa control LED con potenci\u00f3metro</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>A13-1_control_LED_potenciometro</li> </ul> <p></p> <p>Volver </p> <p> <p>Diodo LED RGB</p> <p></p>"},{"location":"actividades/A13/#circuito_1","title":"Circuito","text":"<p>Vamos a montar el siguiente esquema:</p> <p> <p> Esquema de montaje A13-2 LED RGB</p> <p></p> <p>Vamos a mapear el valor anal\u00f3gico del pin P3 de 0-1023 a 0-270 (\u00e1ngulo de giro del potenci\u00f3metro) de manera que durante los primeros 60\u00ba de recorrido los LEDs permacer\u00e1n apagados, para posteriormente ir encendiendo un color cada 70\u00ba, es decir, azul entre 60 y 130, verde entre 130 y 200 y rojo para el resto del recorrido.</p>"},{"location":"actividades/A13/#micropython_1","title":"MicroPython","text":"<p>El programa es:</p> <pre><code>from microbit import *\n\ndisplay.off() #Necesario para poder leer Pin 3\ndef mapeo(valor,deBajo,deAlto,aBajo,aAlto):\n    return (aAlto-aBajo)*(valor-deBajo) / (deAlto-deBajo) + aBajo \ndef RGB(grados):\n    if grados &lt; 60:\n        R = 0\n        G = 0\n        B = 0\n    elif grados &lt; 130:\n        R = 0\n        G = 0\n        B = 255\n    elif grados &lt; 200:\n        R = 0\n        G = 255\n        B = 0\n    else:\n        R = 255\n        G = 0\n        B = 0\n    return R,G,B\n\nwhile True:\n    valor=mapeo(pin3.read_analog(),0,1023,0,270)\n    rojo,verde,azul=RGB(valor)\n    print(rojo,verde,azul)\n    rojo=mapeo(rojo,0,255,1023,0)\n    verde=mapeo(verde,0,255,1023,0)\n    azul=mapeo(azul,0,255,1023,0)\n    pin2.write_analog(int(rojo))\n    pin1.write_analog(int(verde))\n    pin0.write_analog(int(azul))\n    sleep(50)\n</code></pre> <p>El programa lo podemos descargar de:</p> <ul> <li>A13-2_control_RGB_pot</li> <li>A13-2_control_RGB_pot</li> </ul>"},{"location":"actividades/A13/#makecode_1","title":"MakeCode","text":"<p>Leemos el valor anal\u00f3gico de tensi\u00f3n que entrega el pin P3, lo mapeamos y seg\u00fan el valor obtenido los escribimos de manera anal\u00f3gica en los pines P0, P1 y P2. El programa es:</p> <p> <p> Programa control color LED RGB con potenci\u00f3metro</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>A13-2_control_RGB_pot</li> </ul>"},{"location":"actividades/A13/#microblocks_1","title":"MicroBlocks","text":"<p>El programa tiene este aspecto:</p> <p> <p> Programa control LED RGB con potenci\u00f3metro</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>A13-2_control_RGB_pot</li> </ul> <p></p> <p>Volver </p> <p> <p>LED RGB direccionable. Neopixel</p> <p></p>"},{"location":"actividades/A13/#circuito_2","title":"Circuito","text":"<p>Vamos a montar el siguiente esquema:</p> <p> <p> Esquema de montaje A13-3. Neopixel</p> <p></p>"},{"location":"actividades/A13/#micropython_2","title":"MicroPython","text":"<p>El programa es:</p> <pre><code>from microbit import *\nimport neopixel\n\n# Establecemos el n\u00famero de LEDs\nneop = neopixel.NeoPixel(pin0, 8)\n# Funci\u00f3n para convertir color HSL en color RGB\n# devuelve el valor RGB correspondiente al \u00e1ngulo del matiz actual.\n\ndef HSL_RGB(grados):\n    grados=grados/360*255\n    if grados &lt; 85:\n        red = 255 - grados * 3\n        green = grados * 3\n        blue = 0\n    elif grados &lt; 170:\n        grados = grados - 85\n        red = 0\n        green = 255 - grados * 3\n        blue = grados * 3\n    else:\n        grados = grados - 170\n        red = grados * 3\n        green = 0\n        blue = 255 - grados * 3\n    return int(red),int(green),int(blue)\n\nwhile True:\n    for i in range(0, 8):\n        # La lectura analogica se convierte al angulo del matiz actual.\n        # La diferencia de tono entre cada dos led es de 45\n        valor=pin1.read_analog()/1023*360+i*45\n        if valor &gt; 360 :\n            valor = valor-360\n        # Los colores ser\u00e1n los del arcoiris\n        red,green,blue=HSL_RGB(valor)\n        neop[i] = (red,green,blue)\n    neop.show()\n</code></pre> <p>El programa lo podemos descargar de:</p> <ul> <li>A13-3_control_Neo_pot</li> <li>A13-3_control_Neo_pot</li> </ul>"},{"location":"actividades/A13/#makecode_2","title":"MakeCode","text":"<p>Leemos el valor anal\u00f3gico de tensi\u00f3n que entrega el pin P0 e indicamos que ese mismo valor se escriba en el pin P1. El programa es:</p> <p> <p> Programa control Neopixel con potenci\u00f3metro</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>A13-3_control_Neopixel_pot</li> </ul>"},{"location":"actividades/A13/#microblocks_2","title":"MicroBlocks","text":"<p>En este caso vamos a realizar un ejemplo algo diferente para seguir mostrando el potencial del programa. Por un lado vamos a estar viendo de manera continua el valor leido del potenci\u00f3metro y por otro vamos a estar moviendo el color de los LEDs con los colores del arcoiris de una forma sencilla y autom\u00e1tica. La idea es que tendremos dos bloques \"al empezar\" y otros dos bloques \"por siempre\" cada pareja haciendo un trabajo diferente.</p> <p>En la imagen siguiente vemos el programa y la explicaci\u00f3n se da en los comentarios.</p> <p> <p> Programa control Neopixel con potenci\u00f3metro</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>A13-3_Neo_y_pot</li> </ul> <p></p>"},{"location":"actividades/A14/","title":"Nivel de luz con micro:bit. La LDR","text":"<p>En primer lugar vamos a ver como utilizar la micro:bit como detector de luz, cosa que es bastante sencilla por la pantalla de LEDs que puede actuar como sensor.</p> <p>Despu\u00e9s veremos como detectar el nivel de luminosidad con un elemento externo como la LDR.</p>"},{"location":"actividades/A14/#luminosidad-con-la-microbit","title":"Luminosidad con la micro:bit","text":"<p>Luminosidad con la micro:bit Luminosidad con la LDR</p> <p>Volver </p> <p>Luminosidad con la micro:bit"},{"location":"actividades/A14/#micropython","title":"MicroPython","text":"<p>El programa es:</p> <pre><code>from microbit import *\n\nwhile True:\n    nivel_luz = display.read_light_level()\n    uart.write(str(nivel_luz) + \"\\r\\n\")\n    sleep(1000)\n</code></pre> <p>El programa lo podemos descargar de:</p> <ul> <li>A14-1-Midiendo el nivel de luz</li> <li>A14-1-Midiendo el nivel de luz</li> </ul>"},{"location":"actividades/A14/#makecode","title":"MakeCode","text":"<p>El programa que vamos a crear es el siguiente:</p> <p> <p> Programa para la actividad</p> <p></p> <p>El resultado en el simulador es:</p> <p> <p> Programa para la actividad. Simulador</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>A14-1-Midiendo el nivel de luz</li> </ul>"},{"location":"actividades/A14/#microblocks","title":"MicroBlocks","text":"<p>El programa es el siguiente:</p> <p> <p> Programa para la actividad</p> <p></p> <p>El programa est\u00e1 dise\u00f1ado para solucionar el problema que se suele dar de que la sensibilidad de los sensores de luz de la micro:bit varia de unas placas a otras.</p> <p>El programa lo podemos descargar de:</p> <ul> <li>A14-1-Midiendo el nivel de luz</li> </ul>"},{"location":"actividades/A14/#luminosidad-con-la-ldr","title":"Luminosidad con la LDR","text":"<p>Volver </p> <p>Luminosidad con la LDR <p>Vamos a montar el t\u00edpico circuito de un interruptor crepuscular.</p> <p> <p> Circuito del interruptor crepuscular</p> <p></p>"},{"location":"actividades/A14/#micropython_1","title":"MicroPython","text":"<p>El programa es:</p> <pre><code>from microbit import *\n\nwhile True:\n    nivel_luz = pin0.read_analog()\n    # Con luz incidiendo en la LDR se obtienen valores bajos.\n    # Con la LDR iluminada el valor estar\u00e1 en torno a 1000.\n    # Podemos establecer el valor de la comparaci\u00f3n \n    # teniendo esto en cuenta.\n    uart.write(str(nivel_luz) + \"\\r\\n\")\n    if nivel_luz &gt; 500:\n        pin1.write_digital(1)\n    else:\n        pin1.write_digital(0)\n</code></pre> <p>El programa lo podemos descargar de:</p> <ul> <li>A14-2-Interruptor crepuscular</li> <li>A14-2-Interruptor crepuscular</li> </ul>"},{"location":"actividades/A14/#makecode_1","title":"MakeCode","text":"<p>El programa es el siguiente:</p> <p> <p> A14-2-Programa interruptor crepuscular</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>A14-2-Interruptor crepuscular</li> </ul>"},{"location":"actividades/A14/#microblocks_1","title":"MicroBlocks","text":"<p> <p> A14-2-Programa interruptor crepuscular</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>A14-2-Interruptor crepuscular</li> </ul>"},{"location":"actividades/A15/","title":"LCD 1602 I2C","text":"<p>En micro:bit, la conexi\u00f3n I2C est\u00e1 disponible en los pines P19 (SCL) y P20 (SDA) por lo que se requiere de una placa de expansi\u00f3n para poder utilizar dispositivos I2C con ella.</p>"},{"location":"actividades/A15/#circuito","title":"Circuito","text":"<p>Las cvonexiones que hay que realizar son bastante sencillas.</p> <p> <p> Conexionado de la LCD I2C a la placa de expansi\u00f3n</p> <p></p> <p>Hay que conectar el pin SCL del dispositivo al pin 19 de micro:bit, y el pin SDA del dispositivo al pin 20 de micro:bit. Tambi\u00e9n hay que conectar la masa del dispositivo a la masa de la micro:bit (pin GND). Es posible que se necesite alimentar el dispositivo usando una fuente de alimentaci\u00f3n externa a la micro:bit.</p> <p>Hay resistencias pull-up internas en las l\u00edneas I\u00b2C de la placa, pero si usamos cables largos o conectamos un gran n\u00famero de dispositivos es posible que necesitemos a\u00f1adir resistencias pull-up adicionales, para asegurar una comunicaci\u00f3n libre de ruido, tal y como se explica en el apartado I2C de Conceptos t\u00e9cnicos. Se\u00f1ales</p>"},{"location":"actividades/A15/#micropython","title":"MicroPython","text":"<p>Las funciones habituales para una LCD de inicializar, borrar, etc no est\u00e1n implementadas en https://python.microbit.org/v/3 por defecto y tenemos que recurrir a una librer\u00eda externa que implementa una clase y hacer uso de ella. Se recomienda encarecidamente ver el apartado Programaci\u00f3n Orientada a Objetos de la entrada de men\u00fa Python.</p> <pre><code>from microbit import *\nfrom I2C_LCD1602 import *\n\n# Creamos una instancia\nlcd = I2C_LCD1602(0x27)\nlcd.on()\nlcd.backlight(1) #1=retroiliminaci\u00f3n ON, 0=retroiluminacion OFF\nlcd.clear()\n\nwhile True:\n    # Asigna a variable la lectura recibida por los LEDs de la pantalla\n    nivel_luz = display.read_light_level()\n    lcd.puts(\"Nivel de luz: \",0,0) \n    lcd.puts(str(nivel_luz),5,1)\n</code></pre> <p>El programa lo podemos descargar de:</p> <ul> <li>A15-Nivel de luz con LCD</li> <li>A15-Nivel de luz con LCD</li> </ul>"},{"location":"actividades/A15/#makecode","title":"MakeCode","text":"<p>El programa es el siguiente:</p> <p> <p> A15-Nivel de luz con LCD</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>A15-Nivel_luz_LCD</li> </ul>"},{"location":"actividades/A15/#microblocks","title":"MicroBlocks","text":"<p>El programa es el siguiente:</p> <p> <p> A15-Nivel de luz con LCD</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>A15-Nivel_luz_LCD</li> </ul> <p>"},{"location":"actividades/A16/","title":"Medidas de temperatura","text":"<p>Las vamos a ver tanto con el sensor interno de la micro:bit como con un termistor.</p>"},{"location":"actividades/A16/#micropython","title":"MicroPython","text":"<p>El programa que muestra el valor de temperatura medida por el sensor interno de la micro:bit es:</p> <pre><code>from microbit import *\nfrom I2C_LCD1602 import *\n\n# Creamos una instancia\nlcd = I2C_LCD1602(0x27)\nlcd.on()\nlcd.backlight(1) #1=retroiliminacion ON, 0=retroiluminacion OFF\nlcd.clear()\n\nwhile True:\n    Temperatura = temperature()\n    display.scroll(Temperatura)\n    lcd.puts(\"Temperatura: \",0,0) \n    lcd.puts(str(Temperatura),5,1)\n    lcd.puts(\"*C \",8,1)\n    sleep(2000)\n</code></pre> <p>El programa lo podemos descargar de:</p> <ul> <li>A16-Med_temp_sensor_int_uP</li> <li>A16-Med_temp_sensor_int_uP</li> </ul>"},{"location":"actividades/A16/#makecode","title":"MakeCode","text":"<p>El programa es muy sencillo, tan solo tenemos que poner el bloque en un mostrar n\u00famero. Lo complicaremos un poco mostrando la temperatura tambi\u00e9n en la LCD I2C1602.</p> <p> <p> A16-Medida de temperatura con sensor interno</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>A16-Med_temp_sensor_int_MC</li> </ul>"},{"location":"actividades/A16/#microblocks","title":"MicroBlocks","text":"<p>SEl programa que muestra la temperatura medida por el sensor interno de la micro:bit en la LCD y la pantalla es:</p> <p> <p> A16-Medida de temperatura con sensor interno</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>A16-Med_temp_sensor_int_uB</li> </ul>"},{"location":"actividades/A16/#circuito","title":"Circuito","text":"<p>Tenemos que montar y conectar correctamente el siguiente circuito:</p> <p> <p> Circuito con termistor</p> <p></p> <p>A continuaci\u00f3n se muestran los programas para medir la temperatura desde un termistor. Estos programas son los mismos que anteriormente pero se ha a\u00f1adido esta nueva lectura, as\u00ed adem\u00e1s podemos comparar.</p>"},{"location":"actividades/A16/#micropython_1","title":"MicroPython","text":"<p>El programa que muestra el valor de temperatura medida por el sensor interno de la micro:bit y por el termistor es:</p> <pre><code>from microbit import *\nfrom I2C_LCD1602 import *\nimport math #para los c\u00e1lculos\n\nlcd = I2C_LCD1602(0x27)\nlcd.on()\nlcd.backlight(1) #1=retroiliminacion ON, 0=retroiluminacion OFF\nlcd.clear()\n\nwhile True:\n    Temp_int = temperature()\n    display.scroll(Temp_int)\n    sleep(1000)\n    lectura_ADC = pin0.read_analog()\n    # Pasa la lectura analogica a voltios\n    V = lectura_ADC*3.3/1023.0\n    # Por teoria divisor de tension\n    Rt = 10/((3.3/V)-1)\n    # Calculo de la temperatura\n    Temp_term = (1/(1/25 + math.log(Rt/10)/3997))\n    Temp_term_int = round(Temp_term)\n    lcd.puts(\"T_inter / T_term \",0,0)\n    display.scroll(round(Temp_term_int))\n    lcd.puts(str(Temp_int),0,1)\n    lcd.puts(\"*C \",3,1)\n    lcd.puts(str(Temp_term_int),10,1)\n    lcd.puts(\"*C \",13,1)\n    sleep(2000)\n</code></pre> <p>El programa lo podemos descargar de:</p> <ul> <li>A16-Med_temp_sensor_int_term_uP</li> <li>A16-Med_temp_sensor_int_term_uP</li> </ul>"},{"location":"actividades/A16/#makecode_1","title":"MakeCode","text":"<p>Gracias a la extensi\u00f3n de Freenove a\u00f1adir al programa la lectura del termistor es muy simple, como vemos a continuaci\u00f3n.</p> <p> <p> A16-Medida de temperatura con sensor interno y termistor</p> <p></p> <p>El programa lo podemos descargar de:</p> <ul> <li>A16-Med_temp_sensor_int_term_MC</li> </ul>"},{"location":"actividades/A16/#microblocks_1","title":"MicroBlocks","text":"<p>En MicroBlocks no hay una librer\u00eda de matem\u00e1ticas para a\u00f1adir ni tampoco una librer\u00eda para termistores y por lo tanto no es posible resolver esta activdad con este programa.</p> <p>Si vamos a aprovechar para resolverla con el editor de MicroPython Mu.</p> <pre><code>from microbit import *\nimport math  # para los c\u00e1lculos\n\nwhile True:\n    Temp_int = temperature()\n    display.scroll(Temp_int)\n    sleep(1000)\n    lectura_ADC = pin0.read_analog()\n    # Pasa la lectura analogica a voltios\n    V = lectura_ADC * 3.3 / 1023.0\n    # Por teoria divisor de tension\n    Rt = 10 / ((3.3 / V) - 1)\n    # Calculo de la temperatura\n    Temp_term = 1 / (1 / 25 + math.log(Rt / 10) / 3997)\n    Temp_term_int = round(Temp_term)\n    display.scroll(round(Temp_term_int))\n    sleep(2000)\n</code></pre> <p>El programa lo podemos descargar de:</p> <ul> <li>A16-Med_temp_sensor_int_term_Mu</li> </ul>"},{"location":"conceptos/avanzados/","title":"Componentes avanzados","text":"<p>En este apartado iremos describiendo algunos componentes, sensores, actuadores, etc, que se utilizar\u00e1n en los montajes.</p>"},{"location":"conceptos/avanzados/#led-rgb-direccionable","title":"LED RGB direccionable","text":"<p>Comunmente se les conoce como Neopixel, que es una marca registrada por Adafruit Industries. Cada LED que componen la tira o matriz tiene los siguientes cuatro pines:</p> <ul> <li>Alimentaci\u00f3n VDD: 5V. MUY IMPORTANTE, 5V</li> <li>Tierra: GND</li> <li>DI (Date Input): pin para recibir informaci\u00f3n</li> <li>DO (Date Output): pin para enviar inforamci\u00f3n</li> </ul> <p>Cada uno de los LEDs es direccionable de manera individual gracias al circuito electr\u00f3nico (circuito l\u00f3gico) que incluyen con una memoria de un byte por color. Los tipos mas comunes son el SK6812, WS2811 o, el mas habitual de todos, el WS2812 cuyo datasheet tenemos en el enlace.</p> <p>El WS2812B incluye un oscilador interno de precisi\u00f3n y un circuito de control de corriente constante programable de 12 V, lo que garantiza de manera efectiva qimgue la intensidad del color sea consistente. El protocolo de transferencia de datos utiliza un \u00fanico modo de comunicaci\u00f3n de multiplexado NZR.</p> <p>En la figura siguiente vemos el aspecto de un diodo LED RGB individual en formato inserci\u00f3n y SMD.</p> <p> <p> Aspecto de un diodo LED RGB direccionable</p> <p></p> <p></p> <p>Aspectos previos Aspectos t\u00e9cnicos Alimentaci\u00f3n: generalidades Alimentaci\u00f3n: proyectos port\u00e1tiles Alimentaci\u00f3n: proyectos escritorio Alimentaci\u00f3n: requisitos energia</p> <p></p> <p>Aspectos previos</p> <p>Para transmitir informaci\u00f3n digital esta se debe sincronizar mediante una convenci\u00f3n especial, la codificaci\u00f3n. Dos dispositivos llevan una comunicaci\u00f3n por cable convirtiendo la informaci\u00f3n a transmitir en un flujo de bits (0 y 1) o \"Dates\" que se suele nombrar con la letra D y que va acompa\u00f1ada de una se\u00f1al de reloj para sincronizar las transmisiones. La forma convencional de transmisi\u00f3n digital se componen de una l\u00ednea de datos mas una l\u00ednea de reloj. Ahora bien, cualquier ligera desviaci\u00f3n en la longitud de estas l\u00edneas har\u00e1 que eimgl receptor no cumpla con el tiempo de establecimiento del muestreo de datos, originando errores en los datos. La forma de asegurar que esas l\u00edneas son id\u00e9nticas es que sean la misma l\u00ednea, lo que hace que aparezcan c\u00f3digos que fusionan los datos y el reloj, entre los que est\u00e1n los c\u00f3digo RZ, NRZ y NRZI que vamos a ver someramente a continuaci\u00f3n.</p> <ul> <li>Codificaci\u00f3n RZ. El acr\u00f3nimo de de \"Return Zero\" o retorno cero y su caracter\u00edstica es que se transmiten bits de datos dentro de cada periodo de la se\u00f1al. En la figura siguiente los datos se representan en rojo y vemos que ocupan una parte del periodo T, siendo cero el resto del tiempo. Este sistema se denomina RZ unipolar o retorno a cero unipolar y como se observa en la figura un nivel bajo indica 0 y un nivel positivo indica 1.</li> </ul> <p> <p> C\u00f3digo RZ unipolar</p> <p></p> <p>El c\u00f3digo de retorno a cero se divide en un c\u00f3digo de retorno a cero unipolar y un c\u00f3digo de retorno a cero bipolar en el que el nivel alto indica 1 y el nivel negativo 0, tal y como vemos en la imagen siguiente:</p> <p> <p> C\u00f3digo RZ bipolar</p> <p></p> <ul> <li>Codificaci\u00f3n NRZ. El acr\u00f3nimo es de \"Not Return Zero\" o c\u00f3digo sin retorno a cero y se diferencia del RZ en que no necesita retornar a cero. En la figura siguiente vemos gr\u00e1ficamente el c\u00f3digo.</li> </ul> <p> <p> C\u00f3digo NRZ</p> <p></p> <p>En el datasheet estos c\u00f3digo se denominan T0H y T0L.</p> <p>El funcionamiento de una agrupaci\u00f3n en cascada como la de la figura siguiente se puede resumir diciendo que: el circuito integrado de cada LED puede almacenar 3 bytes (24 bits), un byte para cada color. Solo el primer LED est\u00e1 conectado al Pin de control, en este caso, un pin digital de nuestra placa, que enviar\u00e1 la cadena de todos los colores seg\u00fan el n\u00famero de pixeles que est\u00e9n conectados y a su vez el primer LED recibir\u00e1 la informaci\u00f3n de todos los colores uno tras otro. La informaci\u00f3n se transmite de un LED a otro porque cuando un LED recibe 3 bytes nuevos de informaci\u00f3n entrega al siguiente LED los 3 bytes que conten\u00eda anteriormente, de esta manera cuando la placa con el programa termina de mandar todos los colores por el pin de datos el primer LED habr\u00eda recibido y enviado todos los colores para quedarse finalmente con el color que le corresponde y as\u00ed el resto de LEDs. De esta forma una tira de LEDs RGB direccionables es un dispositivo digital de salida, es decir su funcionamiento consiste en recibir la informaci\u00f3n del color a mostrar y mostrarlo.</p> <p> <p> Conexi\u00f3n en cascada de LEDs RGB direccionables</p> <p></p> <p>Volver </p> <p>Aspectos t\u00e9cnicos</p> <p>Los LEDs RGB direccionables se suelen suministrar en tiras de diferentes longitudes y con distinto n\u00famero de LEDs y a veces se dispone la tira en forma de matriz. En la figura siguiente vemos el aspecto de algunos tipos.</p> <p> <p> Tira y matriz de LEDs RGB direccionables</p> <p></p> <p>Tienen 3 cables asociados a un conector y dos cables extra para a\u00f1adir alimentaci\u00f3n externa cuando es necesario porque la placa de control no entrega suficiente corriente para alimentar al conjunto. Cuando se trabaja con una tira de pocos LEDs no es necesario a\u00f1adir esta alimentaci\u00f3n externa, ya que placas como Arduino UNO o la ESP32 STEAMakers pueden suministrar la corriente que necesitan.</p> <p>Cualquier tira de LEDs RGB (sea cual sea su disposici\u00f3n en l\u00ednea, como matriz, etc) debe utilizarse siempre en la direcci\u00f3n que marca el terminal hembra como entrada y el conector macho como salida. Las podemos ir conectando entre s\u00ed pero siempre respetando este sentido de la tira. Junto a cada led RGB est\u00e1 indicada la direcci\u00f3n de la tira mediante un tri\u00e1ngulo y tambi\u00e9n a qu\u00e9 pin debe ir conectado cada cable. Vemos +5V que corresponde a Vcc, GND, y en medio que pone Din o D0 que corresponde al pin digital de entrada de datos que debemos conectar al pin de salida de la placa de control.</p> <p>Tambi\u00e9n las podemos cortar por cualquiera de las l\u00edneas existentes entre cada uno de los LEDs y que est\u00e1 marcado con la l\u00ednea de corte. El corte debe hacerse dejando la mitad del pad de cobre a un lado y otro de la l\u00ednea y as\u00ed poder unir despu\u00e9s entre ellas con conectores especializados o sold\u00e1ndolas.</p> <p> <p> Direcci\u00f3n y l\u00ednea de corte en tira de LEDs RGB direccionables</p> <p></p> <p>Otra configuraci\u00f3n con este tipo de dispositivos lo vemos a continuaci\u00f3n:</p> <p> <p> M\u00f3dulo de 8 de LEDs RGB direccionables</p> <p></p> <p>Estos m\u00f3dulos son enchufables y por tanto ampliables. En la parte posterior est\u00e1n claramente marcados los pines de entrada y los de salida por lo que podemos conectarlos en cascada.</p> <p> <p> Conexionado de tres m\u00f3dulos de 8 LEDs RGB direccionables</p> <p></p> <p>Volver </p> <p>Alimentaci\u00f3n de Neopixel</p> <p>Vamos a comenzar por dar de forma destacada las tres recomendaciones que indican en la gu\u00eda de Adafruit, que son:</p> <p> <p> </p> <p></p> <p>Volver </p> <p>Proyectos port\u00e1tiles</p> <p>Se configuran con relativamente pocos LEDs y por lo tanto no tienen un excesivo consumo por lo que podemos alimentarlos con pilas o bater\u00edas.</p> <ul> <li>Las bater\u00edas recargables de una celda (figura siguiente) de pol\u00edmero de litio entregan 3,7V que son perfectos para alimentar microcontroladores y unos pocos LEDs direccionables.</li> </ul> <p> <p> Bater\u00edas Lipo 1S</p> <p></p> <ul> <li> <p>Pilas AA o AAA. Se pueden usar tres pilas alcalinas con su correspondiente portapilas. Esto proporciona 4.5V. El inconveniente respecto a las bater\u00edas lipo es que son mas grandes y pesadas y la ventaja es que son muy f\u00e1ciles de conseguir.</p> </li> <li> <p>Pilas recargables de hidruro met\u00e1lico de n\u00edquel. En este caso hay que utilizar cuatro unidades de 1.2V con su soporte de cuatro celdas. Esto nos va a proporcionar 4.8V. Tenemos que asegurarnos de usar solamente pilas NiMH porque si colocamos pilas normales de 1.5V estaremos creando una tensi\u00f3n total de 6V y esto es muy probable que rompa el microcontrolador o alg\u00fan LED.</p> </li> <li> <p>Otros medios pueden ser utilizar porwerbanks de la tensi\u00f3n adecuada o alguna de las anteriores de mayor tensi\u00f3n intercalando un convertidor reductor que se adapte a las condiciones de entrada de tensi\u00f3n de que disponemos y que su salida suministre los 5V requeridos. Hay que tener en cuenta el rango de tensi\u00f3n de entrada que requiere el convertidor espec\u00edfico y la corriente m\u00e1xima de salida.amperimetro</p> </li> </ul> <p>Volver </p> <p>Proyectos de escritorio</p> <p>Si estamos hablando de tiras de hasta un metro con una fuente de alimentaci\u00f3n conmutada de 5V/2A en CC t\u00edpica tendremos suficiente.</p> <p>Si se requiere mas corriente resulta tentador utilizar una fuente de laboratorio, pero hay que mucho cuidado porque pueden producir un gran pico de tensi\u00f3n cuando se encienden. Este pico es mas que suficiente para destruir instant\u00e1neamente los LEDs direccionables.</p> <p>Si se usa una fuente de laboratorio, NO conectamos la tira directamente. Primero encendemos la fuente de alimentaci\u00f3n, dejamos pasar unos segundo que el voltaje se estabilice, luego conectamos la tira, asegur\u00e1ndonos de conectar en primer lugar GND.</p> <p>Volver </p> <p>Requisitos de energia</p> <p>Cada LED individual consume hasta 60 miliamperios con el m\u00e1ximo brillo blanco (rojo + verde + azul). Sin embargo, en el uso real, es raro que todos los p\u00edxeles se enciendan de esa manera. Al mezclar colores y mostrar animaciones, el consumo puntual ser\u00e1 mucho menor. Es imposible estimar un n\u00famero para todas las circunstancias, pero se ha experimentado que usando la tercera parte de los 60 mA (20 mA por p\u00edxel) como regla general funciona correctamente. Pero si sabemos con certeza que necesitamos cada p\u00edxel con el m\u00e1ximo brillo, tenemos que usar la cifra 60 mA.</p> <p>Para estimar las necesidades de suministro de energ\u00eda, basta multiplicar la cantidad de p\u00edxeles por 20, o por 60 mA y obtendremos el consumo total en miliamperios. Por ejemplo:</p> <p> <p>8 LEDs x 20 mA = 160 mA (muy cercano a los 190 mA m\u00e1ximo de borde de placa en micro:bit)</p> <p>60 LEDs \u00d7 20 mA = 1200 mA = 1.2 A como m\u00ednimo</p> <p>60 LEDs \u00d7 60 mA = 3600 mA = 3.6 A como m\u00ednimo</p> <p>256 LEDs x 20 mA = 5120 mA = 5.12 A como m\u00ednimo</p> <p>256 LEDs x 60 mA = 15360 mA = 15.36 A como m\u00ednimo</p> <p></p> <p>Parece evidente que en casi todos los casos hay que recurrir a una alimentaci\u00f3n externa, ya sea directamente a los LEDs o a trav\u00e9s de una placa de expansi\u00f3n alimentada de manera adecuada para que no sea la micro:bit la que entrega la corriente demandada.</p> <p>La elecci\u00f3n de la fuente de alimentaci\u00f3n depende de nosotros pero es evidente que la m\u00e1xima seguridad y fiabilidad se consigue con una fuente de alimentaci\u00f3n de dimensiones m\u00e1s generosas, y esto es lo que recomendamos. La mayor\u00eda de las fuentes de alimentaci\u00f3n pueden entregar un poco de corriente adicional durante per\u00edodos breves de tiempo e incluso algunas contienen un fusible t\u00e9rmico y simplemente se apagar\u00e1n si se sobrecargan. Por lo tanto, aunque t\u00e9cnicamente pueden funcionar, digamos que no es recomendable abusar de ellas.</p> <p>Un factor a tener en cuenta es que si vamos a alimentar con bater\u00edas estas se vuelven progresivamente mas pesadas, costosas y peligrosas, as\u00ed que por razones de seguridad habr\u00eda que minimizar el tama\u00f1o de las bater\u00edas.</p> <p>Por otro lado tenemos que tener en cuenta la secci\u00f3n del conductor que ser\u00e1 m\u00e1s barato y menos pesado cuanto menor sea esta, es decir, cuanta menor corriente deba soportar y que cuanto menor sea la corriente menor ser\u00e1 el calor generado.</p> <p>En general podemos decir que:</p> <ul> <li>La regla general de los \"60 miliamperios\" es solo eso... una regla general, no ciencia pura.</li> <li>Al animar y mezclar colores, el consumo de corriente ser\u00e1 menor. A veces mucho menos.</li> <li>Incluso cuando se establece el color en 0 (LEDs apagados), la l\u00f3gica del controlador dentro de cada Pixel usa una peque\u00f1a cantidad de corriente por debajo de 1 miliamperio por p\u00edxel, pero con muchos p\u00edxeles esto deber\u00eda tambi\u00e9n sumarse.</li> </ul> <p>La biblioteca NeoMatrix utiliza la correcci\u00f3n gamma para seleccionar niveles de brillo que son visualmente (aunque no num\u00e9ricamente) equidistantes. Hay 32 niveles para rojo y azul, 64 niveles para verde. La funci\u00f3n Color() realiza la conversi\u00f3n necesaria; no necesitamos hacer ning\u00fan c\u00e1lculo. Acepta valores de rojo, verde y azul de 8 bits y devuelve un color de 16 bits con correcci\u00f3n gamma.</p> <p>La respuesta final a todo esto es que usualmente los LEDs no estar\u00edan encendidos todos juntos, por lo que elegir una fuente de alimentaci\u00f3n se vuelve una adivinanza. Podemos asumir para nuestros proyectos que el 75% de los pixels est\u00e1n encendidos en cualquier momento y que cada uno tiene solo un color, con lo que las corrientes anteriores quedan as\u00ed:</p> <p> <p>60 LEDs: 45\u00d720 mA = 0.9 A</p> <p>256 LEDs: 192 x 20 mA = 3.84 A</p> <p>512 LEDs: 384 x 20 mA = 7.68 A</p> <p></p> <p>La \u00fanica forma 100% segura de saber con certeza el consumo es programar las luces y medir el consumo de corriente con un amper\u00edmetro.</p>"},{"location":"conceptos/avanzados/#placas-de-expansion-para-microbit","title":"Placas de expansi\u00f3n para micro:bit","text":"<p>Aunque existen muchas versiones de distintos fabricantes en nuestro caso vamos a describir tres de ellas. Basicamente la funcionalidad de ampliaci\u00f3n de pines es la misma en todas ellas y se distinguen porque incluyen diferentes funcionalidades, distribuci\u00f3n de pines o drivers para motores.</p> <p></p> <p>Freenove Keyestudio DFROBOT</p> <p></p> <p>Freenove</p> <p>Tiene el siguiente aspecto:</p> <p> <p> Extension board de Freenove</p> <p></p> <p>La placa viene preparada con:</p> <ul> <li>Un conector para alimentaci\u00f3n externa de 7 a 12V</li> <li>Un puerto USB-Micro para conectarla al ordenador</li> <li>Un puerto USB-A colocado en vertivcal para conectar la micro:bit</li> <li>Un diodo LED D1 indicador de 5V</li> <li>Un diodo LED D2 indicador de 3.3V</li> </ul> <p>Para los mas expertos (requiere bastantes conocimientos de electr\u00f3nica) aqu\u00ed dejo el esquema de la placa de control</p> <p>Volver </p> <p>Keyestudio</p> <p>Una micro:bit por si sola no tiene potencia suficiente para controlar directamente motores DC. La placa KS4033 Keyestudio Micro bit DRV8833 Motor Driver Expansion Board incorpora un driver para motores DC con un chip DRV8833CPWP que entrega una corriente m\u00e1xima de 700mA. Adem\u00e1s, dispone de cuatro modos de control del motor: rotaci\u00f3n en sentido horario, rotaci\u00f3n en sentido antihorario, arranque y parada. PWM soporta frecuencias de hasta 100 kHz. Los motores van en el conector azul con clemas atornilladas para mayor facilidad y fiabilidad del conexionado. La placa tambi\u00e9n incorpora interfaces de 3 pines para conectar otros sensores.</p> <p>Los pines A1, A2, B2 y B1 del conector azul de la placa de expansi\u00f3n son controlados por P13, P12, P15 y P16 de la placa micro:bit.</p> <p> <p> Extension board de Keyestudio</p> <p></p> <p>Las especificaciones t\u00e9cnicas de la placa son:</p> <ul> <li>Tensi\u00f3n de entrada VM: 5 a 10.8V DC</li> <li>Corriente de funcionamiento de la parte motriz: \u2264700mA</li> <li>Configuraci\u00f3n de salida para motor: doble puente en h</li> <li>Temperatura de trabajo: 0 a 50 \u00baC</li> </ul> <p>A continuaci\u00f3n vemos un diagrama t\u00edpico de conexionado de motores y la alimentaci\u00f3n de los mismos.</p> <p> <p> Conexionado de la extension board de Keyestudio</p> <p></p> <p>Volver </p> <p>DFROBOT</p> <p>Esta placa de expansi\u00f3n de DFROBOT con montaje vertical de la micro:bit tiene capacidad para controlar cuatro motores DC o dos motores paso a paso. Utiliza el controlador HR8833 con una corriente m\u00e1xima de funcionamiento de 1,5A.</p> <p>La placa de expansi\u00f3n incorpora en los conectores P, 9 pines GPIO de f\u00e1cil conexionado pues incorporan Vcc y GND, En los conectores S hay disponibles 8 conexiones para servos, adem\u00e1s de los conectores atornillados de motores.Tambi\u00e9n dispone de un hub de dos conectores I2C. La placa soporta alimentaci\u00f3n externa de 3.5V a 5.5V a trav\u00e9s del conector DC de 2.1mm o de la clema para cables atornillados que se pueden conectar directamente a un portapilas con 3 pilas AA o AAA. La placa incorpora interruptor de encendido/apagado de la alimentaci\u00f3n externa.</p> <p> <p> Extension board de DFROBOT</p> <p></p> <p>Tiene las siguientes especificaciones:</p> <ul> <li>Tensi\u00f3n de alimentaci\u00f3n: 3.5 a 5.5V DC</li> <li>Tensi\u00f3n de salida digital: 0V / 3.3V</li> <li>Tensi\u00f3n de salida anal\u00f3gica: 0 a 3.3V DC</li> <li>Interface micro:bit: P0 P1 P2 P8 P12 P13 P14 P15 P16</li> <li>Interface servo: 8</li> <li>Interface motor: 4 motores DC / 2 motores paso a paso</li> </ul>"},{"location":"conceptos/avanzados/#conexionado-con-placa-de-expansion","title":"Conexionado con placa de expansi\u00f3n","text":"<p>Usaremos para explicarlo la placa de Freenove que es bastante completa en este aspecto. Tenemos varios casos posibles de conexionado seg\u00fan necesidades.</p> <ul> <li>Directo. Si el dispositivo externo no requiere tensiones diferentes de 3.3V y el consumo previsto es bajo. El conexionado puede ser:</li> </ul> <p> <p> Conexionado directo</p> <p></p> <ul> <li>Baja potencia y alimentaci\u00f3n externa. Si el dispositivo externo utiliza un voltaje de 5V, pero la potencia necesaria no es grande, se puede utilizar el siguiente sistema:</li> </ul> <p> <p> Conexionado para dispositivo 5V y bajo consumo</p> <p></p> <p>Los reguladores AMS1117 que incorpora la placa tienen capacidad de suministrar hasta 1A de corriente m\u00e1xima para la alimentaci\u00f3n de 3.3V.</p> <ul> <li>Externa . Si el dispositivo externo utiliza un voltaje de 5V y el consumo es elevado se puede utilizar el siguiente sistema:</li> </ul> <p> <p> Conexionado para dispositivo 5V y consumo elevado</p> <p></p>"},{"location":"conceptos/avanzados/#modelo-de-color-hsl","title":"Modelo de color HSL","text":"<p>El modelo HSL o a veces HSI (siglas del ingl\u00e9s Hue, Saturation, Lightness o Intensity; traducido por, \u2018matiz, saturaci\u00f3n, luminosidad o intensidad\u2019), define un modelo de color en t\u00e9rminos de sus componentes constituyentes.</p> <p>En el modelo de color HSV, un color se define por su matiz o tono (H), su saturaci\u00f3n (S) y su luminosidad o intensidad (L). Ahora las siglas no significan colores como en RGB, sino par\u00e1metros.</p> <p>La variedad de colores se obtiene cambiando los tres canales de color de tono (H), saturaci\u00f3n (S) y luminosidad (L) y superponi\u00e9ndolos entre s\u00ed. Este modo de color cubre los colores que puede percibir la visi\u00f3n humana.</p> <p>Se suele representar mediante la rueda de color, como vemos a continuaci\u00f3n:</p> <p> <p> Rueda de color HSL</p> <p></p> <ul> <li>Tono, matiz o Hue (H). En el c\u00edrculo crom\u00e1tico el grado 0 (o 360\u00ba si hemos dado una vuelta completa) del Hue es el color rojo. El circulito rodeado corresponde al \u00e1ngulo en la rueda de color. Cada \u00e1ngulo representa un color. En esa posici\u00f3n la saturaci\u00f3n S por defecto tomma su valor m\u00e1ximo de 100, y el brillo (L) es de 50. Nos podemos mover con estas condiciones por la rueda y obtener los distintos colores para esos valores de saturaci\u00f3n o brillo.</li> </ul> <p> <p> Cambios de tono (H) en la rueda de color HSL</p> <p></p> <ul> <li>Saturaci\u00f3n o Saturation (S). Indica la intensidad de un tono concreto. Los valores varian entre 0 y 100, siendo 100 el m\u00e1ximo de saturaci\u00f3n posible y 0 el m\u00ednimo, que dar\u00e1 como resultado, gris. El par\u00e1metro cambia sus valores moviendose dentro del tri\u00e1ngulo en la l\u00ednea del d\u00edametro del c\u00edrculo que corresponde a la posici\u00f3n del \u00e1ngulo determinado por H.</li> </ul> <p> <p> Cambios de saturaci\u00f3n (S) en la rueda de color HSL</p> <p></p> <p>Observamos que al acercarnos al gris el valor de H se restablece a su valor por defecto. Hasta ese punto el tono se mantiene en el valor definido.</p> <ul> <li>Luminosidad o Lightness (L). El par\u00e1metro se refiere a como de claro u oscuro es un color. Si queremos aclarar un color nos moveremos hacia el blanco y si quiero oscurecerlo hacia el negro.</li> </ul> <p> <p> Cambios de luminosidad (L) en la rueda de color HSL</p> <p></p> <p>Hay un par\u00e1metro que suele acompa\u00f1ar a la rueda de color que es el Alfa (A), que puede variar entre 0 y 100 y se refiere al grado de opacidad del color, correspondiendo 100 a totalmente opaco y 0 a totalmente transparente.</p> <p>Convertir RGB a HSL</p> <p>Nos vamos a basar en un ejemplo descrito por los valores R=90, G=220, B=80 correspondiente a un tono verde oscuro.</p> <p> <p> R=90, G=220, B=80</p> <p></p> <ul> <li>Paso 1. M\u00e1ximo y M\u00ednimo. Convertimos los valores RGB a valores en el rango 0-1 dividiendo por 255 cada valor.</li> </ul> <p> <p>R = \\dfrac{90}{255}= 0.353 \\space; \\space G = \\dfrac{220}{255}= 0.863 \\space; \\space B = \\dfrac{80}{255}= 0.314</p> <p>\\boxed{R = 0.353 \\space; \\space G = 0.863 \\space(Max) \\space; \\space B = 0.314 \\space(Min)}</p> <p></p> <ul> <li>Paso 2. Luminancia. Calculamos la Luminancia sumando los valores m\u00e1ximo y m\u00ednimo obtenidos en el paso 1 y lo dividimos por 2.</li> </ul> <p> <p>L \\space = \\space \\dfrac{0.863 + 0.314}{2} \\space= \\space 0.5885 \\space\\approx59 \\%</p> <p>\\boxed{L \\space = \\space 0.5885 \\space \\approx 59 \\%}</p> <p></p> <ul> <li>Paso 3. Saturaci\u00f3n. A la hora de calcular la saturaci\u00f3n S tendremos en cuenta que:</li> </ul> <ul> <li>Si los valores m\u00e1ximo y m\u00ednimo son iguales: No hay saturaci\u00f3n. <li>Si todos los valores RGB son iguales: Tono gris mas o menos oscuro o claro dependiendo de la luminosidad.</li> <li>Si no hay saturaci\u00f3n el Tono ser\u00e1 0\u00ba.</li> <p>Si no se da alguna de las condiciones anteriores sabemos que hay Saturaci\u00f3n, que se calcula seg\u00fan sea el nivel de Luminancia:</p> <p>\\Rightarrow Si L \\leq 0.5</p> <p> S = \\dfrac{Max-Min}{Max+Min} </p> <p>\\Rightarrow Si L &gt; 0.5</p> <p> S = \\dfrac{Max-Min}{2.0-Max-Min} <p>S = \\dfrac{0.863-0.314}{2-0.863-0.314} = \\dfrac{0.549}{0.823}=0.667 \\approx 67 \\%</p> <p>\\boxed{S = 0.667 \\approx 67 \\%}</p> <p></p> <ul> <li>Paso 4. Tono. La f\u00f3rmula del Tono depende de qu\u00e9 canal de color RGB es el valor m\u00e1ximo. Las tres f\u00f3rmulas diferentes son:</li> </ul> <p>\\Rightarrow  Si Rojo es el m\u00e1ximo, entonces:</p> <p> H = \\dfrac{G-B}{Max-Min} </p> <p>\\Rightarrow  Si Verde es el m\u00e1ximo, entonces:</p> <p> H = 2.0 + \\dfrac{B-R}{Max-Min} <p>H = 2.0 + \\dfrac{0.314-0.353}{0.863-0.314} = 2.0 + \\dfrac{(-0.039)}{0.549} = 1.929</p> <p>\\boxed{H=1.929} </p> <p>\\Rightarrow  Si Azul es el m\u00e1ximo, entonces:</p> <p> H = 4.0 + \\dfrac{R-G}{Max-Min}$ </p> <p>El valor obtenido de H lo multiplicamos por 60 para convertirlo en grados en el c\u00edrculo crom\u00e1tico. Si resulta un valor negativo de H le sumamos 360.</p> <p> <p>H = 1.929 \\times 60 = 115.74 \\approx 116 \\space grados</p> <p>\\boxed{H=116 \\space grados}</p> <p></p> <p>Resultado final:</p> <p> R = 90, G = 220, B = 80 <p>H = 116, S = 67, L = 59 </p> <p>Convertir HSL a RGB</p> <p>En el mismo sitio en que hemos basado la conversi\u00f3n de RGB a HSL de Nikolai Waldman est\u00e1 documentado como hacerlo a la inversa, pero nosotros no lo vamos a hacer de este modo.</p> <p>Se encuentran facilmente en la web p\u00e1ginas con calculadoras que permiten convertir de un modelo a otro con tan solo introducir los valores. Algunas incluso indican las f\u00f3rmulas de c\u00e1lculo, que usualmente est\u00e1n basadas en la entrada HSL and HSV de la Wikipedia. A t\u00edtulo de ejemplo aqu\u00ed pongo la de rapidtables, que ofrece muchas calculadoras en l\u00ednea gratuitas</p> <p>Hay una forma de hacerlo a partir de un programa libre como es Inkscape, publicado bajo licencia GNU General Public License, version 3 y que hemos utilizado para las animaciones donde se han explicado los conceptos y donde adem\u00e1s se pueden obtener otros datos y por supuesto modificarlos.</p> <p>Es muy sencillo de utilizar y nos ofrece adem\u00e1s otras posibilidades interesantes. Veamos como llegar a ello una vez abierto Inkscape con un archivo en blanco.</p> <p>Dibujamos cualquier cosa y abrimos las opciones de Relleno y borde del objeto y desde ah\u00ed ya podemos cambiar el modelo de color, activar la rueda, mover la rueda o los valores lineales, volver a cambiar de modelo, etc y se nos ir\u00e1n mostrando los valores convetidos de uno a otro, como se observa en la animaci\u00f3n siguiente cuando cambiamos del modelo HSL a RGB.</p> <p> <p> Modelos de color con Inkscape</p> <p></p>"},{"location":"conceptos/avanzados/#lcd-1602-i2c","title":"LCD 1602 I2C","text":"<p>Una pantalla LCD (del ing\u00e9s, Liquid Cristal Display) I2C de 2 l\u00edneas de 16 caracteres por l\u00ednea tiene el aspecto que vemos en la imagen siguiente.</p> <p> <p> LCD 2x16 con m\u00f3dulo I2C</p> <p></p> <p>En realidad el conjunto que vemos en la imagen anterior no es mas que una LCD 2x16 a la que se ha incorporado un m\u00f3dulo adaptador de LCD a I2C. Este modulo est\u00e1 especialmente dise\u00f1ado para poder soldarlo directamente a la LCD y convertirla as\u00ed en un dispositivo I2C que adem\u00e1s ya lleva incorporado el potenci\u00f3metro de ajuste de contraste en alguno de los casos.</p> <p>Este tipo de pantalla requiere cuatro cables para establecer las conexiones, dos cables SDA (datos) y SCL (reloj) para el bus de comunicaciones I2C y los dos cables de alimentaci\u00f3n VCC y GND.</p> <p>La direcci\u00f3n f\u00edsica I2C por defecto de este tipo de m\u00f3dulos depende del circuito integrado utilizado para realizar la conversi\u00f3n paralelo a serie. Los mas habituales son el PCF8574T que tiene la direcci\u00f3n 0x27 o bien el PCF8574AT que tienen la direcci\u00f3n 0x3F. Tambi\u00e9n es habitual que se pueda cambiar la direcci\u00f3n f\u00edsica dentre de un rango de 8 valores (3 bits). Para un correcto control es muy importante identificar correctamente la direcci\u00f3n I2C de nuestro modulo pues de otra forma nuestro programa no funcionar\u00e1 correctamente.</p> <p>En la siguiente figura se muestra el sistema de distribuci\u00f3n de filas y columnas.</p> <p> <p> Sistema de coordenadas en una LCD 1602</p> <p></p> <p>Es posible, y puede resultar necesario, cambiar la direcci\u00f3n f\u00edsica del dispositivo I2C. Esta tarea nos va a resultar especialmente \u00fatil si disponemos de LCDs I2C con una direcci\u00f3n fijada de f\u00e1brica y queremos conectar varias de ellas en nuestro proyecto.</p>"},{"location":"conceptos/avanzados/#cambiar-direccion-lcd-sin-micro-interruptores","title":"Cambiar direcci\u00f3n LCD SIN micro interruptores","text":"<p>La parte posterior de la LCD 1602 de Keyestudio tiene el aspecto de la imagen siguiente. Nos fijaremos especialmente en los tres grupos de agujeros enmarcados en rojo. Aunque en este caso no vienen nombrados los vamos a denominar A0, A1 y A2 de izquierda a derecha. En LCDs de otras marcas esto puede variar ligeramente.</p> <p> <p> Pads configuraci\u00f3n direcci\u00f3n f\u00edsica en la parte posterior LCD I2C</p> <p></p> <p>La direcci\u00f3n por defecto de f\u00e1brica en este caso es la 0x27, pero se puede cambiar alterando la situaci\u00f3n de conexionado de estos agujeros entre si seg\u00fan la tabla siguiente:</p> <p> A2 A1 A0 Direcci\u00f3n 0 0 0 0x27 0 0 1 0x26 0 1 0 0x25 0 1 1 0x24 1 0 0 0x23 1 0 1 0x22 1 1 0 0x21 1 1 1 0x20 <p></p> <p>Para establecer los unos de la tabla anterior basta con cortocircuitar los dos pads correspondientes. En la imagen siguiente se ha establecido la direcci\u00f3n f\u00edsica como 0x26.</p> <p> <p> Direcci\u00f3n 0x26 establecida</p> <p></p>"},{"location":"conceptos/avanzados/#cambiar-direccion-lcd-con-micro-interruptores","title":"Cambiar direcci\u00f3n LCD CON micro interruptores","text":"<p>La parte posterior de la LCD 1602 de Keyestudio con micro interruptores para cambiar su direcci\u00f3n f\u00edsica tiene el aspecto de la imagen siguiente. Nos fijaremos especialmente en el recuadro azul donde est\u00e1n los microinterruptores que permiten cambiar el estado del bit y encima de los mismo est\u00e1 la informaci\u00f3n de la direcci\u00f3n f\u00edsica que se asigna a cada combinaci\u00f3n. La tabla es exactamente la misma que en el caso anterior.</p> <p> <p> Configuraci\u00f3n direcci\u00f3n f\u00edsica con microinterruptores</p> <p></p>"},{"location":"conceptos/avanzados/#motores","title":"Motores","text":"<p>Apartado para describir los tipos de motores que habitualmente se utilizan en proyectos con micro:bit, como son los motores de corriente continua o motores DC y los servomotores.</p>"},{"location":"conceptos/avanzados/#el-motor-de-corriente-continua","title":"El motor de corriente continua","text":"<p>Se suelen denominar como motores DC (del ingl\u00e9s Direct Current) o motores CC como que son m\u00e1quinas que convierten la energ\u00eda el\u00e9ctrica en mec\u00e1nica en base a un campo magn\u00e9tico que provoca un movimiento de rotaci\u00f3n en el eje del motor.</p> <p>Un motor de corriente continua tiene dos partes bien diferenciadas:</p> <ul> <li>Estator. Es la parte fija del motor y son bobinas de hilo de cobre devanadas en n\u00facleos magn\u00e9ticos.</li> <li>Rotor. Es la parte movil del motor y suele tener forma de cilindro, tambi\u00e9n es un devanado con n\u00facleo que se alimenta con corriente continua a trav\u00e9s de las delgas.</li> </ul> <p>En la animaci\u00f3n de la figura siguiente vemos el principio de funcionamiento de un motor DC explicado a partir del caso de una espira conductora dentro de un campo magn\u00e9tico a la que se aplica una tensi\u00f3n entre sus extremos que hace circular por la misma una corriente el\u00e9ctrica.</p> <p> <p> Base de funcionamiento de un motor DC Fuente: Wikipedia</p> <p></p> <p>En esta imagen existe un campo magn\u00e9tico permanente producido por imanes en el estator. El flujo de corriente en el devanado del rotor produce una fuerza de Lorentz sobre el devanado, representada por las flechas verdes. Debido a que en este caso el motor tiene dos polos, la conmutaci\u00f3n se hace por medio de un anillo partido a la mitad, donde el flujo de corriente se invierte cada media vuelta (180 grados).</p> <p>En la figura siguiente vemos el esquema del funcionamiento de un motor de c.c. elemental de dos polos con una sola bobina y dos delgas en el rotor. Se muestra el motor en tres posiciones del rotor desfasadas 90\u00b0 entre s\u00ed.</p> <ul> <li>1, 2: Escobillas</li> <li>A, B: Delgas</li> <li>a, b: Lados de la bobina conectados respectivamente a las delgas A y B</li> </ul> <p> <p> Esquema de funcionamiento de un motor DC Fuente: Wikipedia</p> <p></p> <p>En la figura siguiente vemos el aspecto de dos motores t\u00edpicos.</p> <p> <p> Aspecto de motores DC</p> <p></p>"},{"location":"conceptos/avanzados/#control-de-motores-dc","title":"Control de motores DC","text":"<p>Las salidas de la micro:bit no van a servir por si solas para el control de un motor DC que tendr\u00e1 un consumo de hasta 1A. La soluci\u00f3n est\u00e1 en realizar el control del motor a trav\u00e9s de un controlador o driver que es gobernado por la placa de control, se alimenta de forma externa y excita al motor. En la figura siguiente vemos esquematizado el concepto.</p> <p> <p> Concepto de control por driver</p> <p></p> <p>El sistema mas sencillo de control todo o nada de un motor DC lo conseguimos a trav\u00e9s de un transistor, tal y como vemos en la figura siguiente.</p> <p> <p> Control de motor DC con transistor</p> <p></p> <p>Pero es evidente que necesitamos un control mas completo del motor en el que se permita:</p> <ul> <li>Invertir el sentido de giro.</li> <li>Controlar la velocidad de giro.</li> </ul> <p>Existen muchos drivers diferentes que consiguen estos objetivos y casi todos basan su funcionamiento en el denominado puente en H estando su principal diferencia en el circuito integrado que utilizan y la corriente m\u00e1xima que es capaz de entregar.</p> <ul> <li>Puente en H con interruptores Vamos a explicar el funcionamiento de un puente en H utilizando para ello un circuito creado con interruptores y el principio b\u00e1sico de que en los motores DC el sentido de giro depende de la polaridad de alimentaci\u00f3n. En la figura siguiente tratamos de expresar el hecho de que cambiando la polaridad de la bater\u00eda cambia el sentido de giro del motor.</li> </ul> <p> <p> Cambio de polaridad para cambiar sentido de giro</p> <p></p> <p>El puente en H m\u00e1s b\u00e1sico que podemos construir lo vemos en la figura siguiente, donde observamos que su nombre se debe a la similitud que tiene el esquema con la letra H.</p> <p> <p> Puente en H con interruptores</p> <p></p> <p>Veamos las posibles combinaciones que podemos realizar accionando dos interruptores:</p> <ul> <li>Cerramos SW1 y SW4. Las conexiones son: positivo motor a positivo bater\u00eda y negativo motor a negativo bater\u00eda. Sentido de giro: horario.</li> <li>Cerramos SW2 y SW3. Las conexiones son: positivo motor a negativo bater\u00eda y negativo motor a positivo bater\u00eda. Sentido de giro: antihorario.</li> <li>Cerramos SW1 y SW2 o SW3 y SW4. Se provoca un CORTOCIRCUITO en la alimentaci\u00f3n.</li> <li>Cerramos SW1 y SW3 o SW2 y SW4. Se cortocircuitan los terminales del motor lo que mantiene al motor frenado.</li> </ul> <p>Es evidente que un puente en H as\u00ed construido no nos va a servir para mucho mas que para explicar el funcionamiento del sistema, pero si reemplazamos los interruptores por un sistema de control que abra y cierre el circuito de cada interruptor es evidente que si tendremos un sistema de control del sentido de giro muy vers\u00e1til.</p> <ul> <li>Puente en H con transistores Si a un transistor lo hacemos trabajar en conmutaci\u00f3n su comportamiento es muy similar al de un interruptor asimilando el estado de corte del transistor al de interruptor abierto y el de saturaci\u00f3n al de cerrado. Es entonces posible sustituir los interruptores por transistores y tendremos una configuraci\u00f3n de puente en H como la de la figura siguiente. Este es un circuito simplificado donde adem\u00e1s se ha a\u00f1adido una l\u00f3gica de control b\u00e1sica que permite explicar el funcionamiento.</li> </ul> <p> <p> Puente en H con transistores</p> <p></p> <p>Los transistores pueden ser NPN (el caso expuesto), PNP o pares complementarios y pueden ser de uni\u00f3n o MOSFET de potencia variando as\u00ed la m\u00e1xima corriente que son capaces de entregar y por lo tanto el tama\u00f1o del motor.</p> <p>El funcionamiento del circuito es el siguiente:</p> <ul> <li>Pin enable. Si es 0 todas las puertas AND tendr\u00e1n un cero en la salida un 0 con lo que los transistores est\u00e1n en corte y al motor no le llega alimentaci\u00f3n. El pin enable a 1 habilita la otra entrada de las 4 puertas AND para que en la misma aparezca la otra entrada.</li> <li>Enable = 1, IN1 = 1 e IN2 = 0. Los transistores Q1 y Q4 se saturan por lo que el motor queda polarizado directamente tal y como se muestra en la imagen y por lo tanto girar\u00e1 en sentido horario.</li> <li>Enable = 1, IN1 = 0 e IN2 = 1. Los transistores Q2 y Q3 se saturan por lo que el motor queda polarizado inversamente y por lo tanto girar\u00e1 en sentido antihorario.</li> <li>Enable = 1, IN1 = 1 e IN2 = 1. Se saturan los transistores Q1 y Q3 y al motor solamente le llega el positivo de alimentaci\u00f3n por lo que permanecer\u00e1 parado.</li> <li>Enable = 1, IN1 = 0 e IN2 = 0. Se saturan los transistores Q2 y Q4 y el motor permanecer\u00e1 frenado.</li> </ul>"},{"location":"conceptos/avanzados/#el-servomotor","title":"El servomotor","text":"<p>Un servomotor o abreviado servo es un motor especial que puede posicionar su eje en un \u00e1ngulo determinado y lo puede mantener en esta posici\u00f3n. Los servos est\u00e1ndar suelen girar 180\u00ba, pero es habitual encontrar servos que giran 90\u00ba y otros 360\u00ba, que son los conocidos como servos de rotaci\u00f3n continua. En el interior del mismo est\u00e1n ubicados tanto la electr\u00f3nica de control como los engranajes reductores que a su vez pueden llevar o no topes f\u00edsicos que marquen el \u00e1ngulo de giro. Para su funcionamiento s\u00f3lo necesitan ser alimentados (conexiones GND y VCC o 5V) y una se\u00f1al de control.</p> <p>Los servomotores son en realidad motores de corriente continua a los que se les ha a\u00f1adido una reductora, para que giren m\u00e1s despacio y con m\u00e1s fuerza, y un controlador electr\u00f3nico que permite hacer que gire un determinado \u00e1ngulo. Adem\u00e1s, el servo en todo momento sabe en qu\u00e9 posici\u00f3n est\u00e1, aunque se apague o reinicie. Esto significa que si a un servo que hemos movido a un determinado punto, lo hemos dejado sin alimentaci\u00f3n y al alimentarlo de nuevo le indicamos que gire 90\u00ba, no va a girar 90\u00ba sino que se va a dirigir a su posici\u00f3n de 90\u00ba que tiene memorizada internamente.</p> <p>En la figura siguiente vemos esquematizado el interior de un servo.</p> <p> <p> Interior de un servo 9g</p> <p></p> <p>Su aspecto real lo vemos en la figura siguiente donde tambi\u00e9n se aprecian las palas y tornilleria que lo acompa\u00f1an.</p> <p> <p> Aspecto real de un servo 9g</p> <p></p> <p>Veamos su principio b\u00e1sico de funcionamiento: La electr\u00f3nica de control del servomotor tiene un circuito de referencia incorporado que emite la se\u00f1al de referencia, que es un ciclo de 20 ms con un ancho de pulso de 1,5 ms. Se compara la tensi\u00f3n de control recibida con la de referencia y se genera una diferencia de tensi\u00f3n. El circuito de control en la placa decidir\u00e1 la direcci\u00f3n de rotaci\u00f3n en consecuencia y accionar\u00e1 el motor. El sistema de engranajes o reductora convierten el giro del motor en un par de fuerza a trav\u00e9s del eje. El sensor detecta que se ha alcanzado la posici\u00f3n enviada de acuerdo con la se\u00f1al de retroalimentaci\u00f3n. Cuando la diferencia de tensi\u00f3n existe el motor gira y cuando la diferencia se reduce a cero, el motor se detiene. Normalmente, el \u00e1ngulo de rotaci\u00f3n es de 0 a 180 grados, aunque existen servos de 90\u00ba y de rotaci\u00f3n continua o 360\u00ba.</p> <p>El servomotor viene con un conector hembra de tres pines para tres cables de conexi\u00f3n, que se distinguen por los colores marr\u00f3n, rojo y naranja (diferentes marcas pueden tener diferentes colores).</p> <p>El \u00e1ngulo de rotaci\u00f3n del servomotor se controla regulando el ciclo de trabajo de la se\u00f1al PWM cuyo est\u00e1ndar es de 20 ms (50 Hz).</p> <p>Existe un tipo especial de servomotor que permite la rotaci\u00f3n continua. En algunos casos se trata de servomotores \u201ctrucados\u201d de forma que se modifican para permitir la rotaci\u00f3n continua quitando los topes mec\u00e1nicos y se sustituye el potenci\u00f3metro por un divisor de tensi\u00f3n con dos resistencia iguales (en algunos casos no se ponen resistencias y se bloquea el potenci\u00f3metro para que no gire dej\u00e1ndolo justo en su punto central). Este tipo de modificaci\u00f3n la podemos realizar nosotros (en la web existen multitud de tutoriales) o tambi\u00e9n podemos comprar un servomotor de rotaci\u00f3n continua listo para funcionar sin tener que hacer ning\u00fan tipo de bricolaje.</p> <p>A continuaci\u00f3n vemos las partes de un servo t\u00edpico.</p> <p> <p> Despiece de un servo 9g</p> <p></p> <ul> <li>Control de un servomotor Uno de los problemas que se nos plantean cuando cogemos un servo por primera vez es averiguar cual es su posici\u00f3n. Lo que nosotros hacemos cuando enviamos la se\u00f1al PWM a la patilla de control del servo es indicarle a que posici\u00f3n queremos que se dirija. El servo a priori, mediante el potenci\u00f3metro y la electr\u00f3nica de control, sabe en que posici\u00f3n est\u00e1 por lo que si le enviamos un dato con el que el servo no pueda posicionarse estar\u00e1 constantemente intentando buscar la posici\u00f3n.</li> </ul> <p>En la imagen vemos las se\u00f1ales de posicionado del servo y los \u00e1ngulos a los que se debe colocar.</p> <p> <p> Se\u00f1ales PWM para posiconar servo</p> <p></p> <p>La se\u00f1al PWM debe ser tal que en un periodo (tiempo) de 20ms se debe generar un pulso de 1ms, 1.5ms o 2ms que el controlador interpretar\u00e1 como 0, 90 y 180 grados respectivamente. Es decir, el pulso entre 1 y 2ms ir\u00e1 siendo interpretado por el controlador para ir moviendo el servo hasta la posici\u00f3n de destino.</p> <p>Lo que nosotros tendremos que programar cuando utilicemos un servo es, entre otras cosas, el \u00e1ngulo en el que queremos posicionarlo que en los servos mas habituales estar\u00e1 comprendido entre 0 y 180\u00ba.</p> <p>Una vez que hemos colocado y conectado el servo y lo posicionamos en sus distintos \u00e1ngulos es momento de elegir la posici\u00f3n que mas nos interese para colocar la pala en su lugar, lo que depender\u00e1 de la aplicaci\u00f3n, logicamente.</p> <p>La velocidad del movimiento est\u00e1 condicionada por el dise\u00f1o f\u00edsico del propio servo y este se mover\u00e1 a su m\u00e1xima velocidad para cambiar de una posici\u00f3n a otra. Entre los movimientos programados a diferentes \u00e1ngulos es conveniente programar un peque\u00f1o retardo para que al servo le de tiempo de llegar a una posici\u00f3n determinada antes de recibir la orden de moverse a otra. Si no lo hacemos as\u00ed es muy posible que el servo inicie un movimiento de \"vibraci\u00f3n\" intentando moverse de una posici\u00f3n a la otra.</p> <p>Es evidente que habr\u00e1 aplicaciones en las que nos interese controlar la velocidad a la que se mueve el servo y la forma mas sencilla de hacerlo es asociando el \u00e1ngulo de giro a una variable e ir incrementando esta poco a poco. La velocidad se controla mediante el retardo entre el movimiento debido a un valor de la variable y el siguiente. Aqu\u00ed debemos tener precauci\u00f3n con el valor del retardo y relacionarlo con el valor de incremento de la variable para que el tiempo sea suficiente para que se haga el movimiento pero no excesivamente largo que har\u00eda el movimiento global muy lento. Tambi\u00e9n debemos poner un retardo fuera del bucle que provoca los movimientos para dar tiempo a que el servo retorne a su posici\u00f3n inicial. L\u00f3gicamente si queremos que este movimiento de regreso lo haga a velocidad controlada utilizaremos otro bucle decremental para ello.</p>"},{"location":"conceptos/avanzados/#magnetometro-y-acelerometro","title":"Magnet\u00f3metro y aceler\u00f3metro","text":"<p>La placa BBC micro:bit lleva incorporado un LSM303AGR que es un m\u00f3dulo br\u00fajula ultracompacto de alto rendimiento: aceler\u00f3metro y magnet\u00f3metro. El aceler\u00f3metro es capaz de detectar direcci\u00f3n del movimiento en tres ejes y el magnet\u00f3metro es capaz de detectar campos magn\u00e9ticos en tres direcciones.</p> <p> <p> Direcciones de detecci\u00f3n de LSM303AGR</p> <p></p>"},{"location":"conceptos/avanzados/#magnetometro","title":"Magnet\u00f3metro","text":"<p>MakeCode Python</p> <p>Medir el campo magn\u00e9tico en tes direcciones es posible en dispositivos como la micro:bit por la propiedad que tienen los semiconductores denominada \"Efecto Hall\". En la entrada Efecto Hall de la wikipedia est\u00e1 descrito con detalle el efecto.</p> <p>Los magnet\u00f3metros se utilizan en sistemas de navegaci\u00f3n para establecer las direcciones que deben seguir aviones y barcos.</p> <p>En BBC micro:bit, la primera vez que grabamos un programa relacionado con el magnet\u00f3metro nos va a salir por pantalla el mensaje:</p> <p> <p>Tilt to Fill Screen (Inclinar para llenar la pantalla)</p> <p></p> <p>Una vez que desaparece el texto se ilumina un solo pixel de la pantalla y seg\u00fan inclinemos la micro:bit la pantalla se ir\u00e1 llenando. El objetivo es llenar de punto toda la pantalla. Cuando el proceso de calibraci\u00f3n fizaliza con \u00e9xito aparece una carita sonriente en la pantalla.</p> <p>En la ayuda y soporte de microbit nos explican como funciona la calibraci\u00f3n en la entrada Calibrating the micro:bit Compass.</p> <p>Calibraci\u00f3n de la br\u00fajula</p> <p>Lo primero que nos indican es que la br\u00fajula que incorpora micro:bit debe calibrar la primera vez que se usa para otner mediciones precisas.</p> <p>La br\u00fajula micro:bit est\u00e1 configurada para ser utilizada en posici\u00f3n horizontal, igual que una br\u00fajula anal\u00f3gica. La calibraci\u00f3n en el dispositivo V2 es un poco m\u00e1s sensible, por lo que es importante calibrar el dispositivo lentamente, desde una posici\u00f3n horizontal y dejar algo de tiempo una vez que el programa se est\u00e1 ejecutando para dejar que los valores se asienten, por ejemplo a\u00f1adiendo una pausa despu\u00e9s de que la rutina de calibraci\u00f3n se complete y/o entre lecturas.</p> <p>Una vez que carguemos un programa que intente leer la br\u00fajula, aparecer\u00e1n las letras y debemos sostener la micro:bit horizontalmente e ir incl\u00ednandola sobre el punto intentando rellenar la pantalla. Una vez finalizado el proceso nuestro programa se ejecutar\u00e1.</p> <p>La rutina de calibraci\u00f3n se ejecuta en segundo plano mientras las letras se desplazan por la pantalla, por lo que es posible empezar a inclinar mientras las palabras se desplazan. Esto acelera la rutina de calibraci\u00f3n.</p> <p>Consejos</p> <ul> <li>Calibrar en el entorno de uso para obtener la m\u00e1xima precisi\u00f3n.</li> <li>Si utilizamos bater\u00eda para alimentarla calibramos con la bater\u00eda conectada.</li> <li>No fijar o apoyar sobre objetos met\u00e1licos por la sensibilidad a los campos magn\u00e9ticos.</li> <li>Si estamos utilizando un im\u00e1n con la micro:bit habr\u00e1 que recalibrar entre actividades.</li> <li>El \"valor m\u00e1ximo de campo\" para el magnet\u00f3metro es de 10.000 gauss (1 Tesla). Pensemos que un im\u00e1n de nevera es de alrededor de 0,001 Tesla y un im\u00e1n de un altavoz alrededor de 1 Tesla.</li> </ul> <p>Al flashear desde el editor MakeCode, la calibraci\u00f3n de la br\u00fajula se almacena en la memoria, por lo que al resetear o apagar y encender la micro:bit esta reecordar\u00e1 la calibraci\u00f3n porque solo se actualiza la parte del programa que cambia. Sin embargo, esta memoria se borra cuando actualizamos con un nuevo programa mediante la t\u00e9cnica de arrastrar y soltar, por lo que tendremos que volver a calibrarla de nuevo. MakeCode dispone de un bloque espec\u00edfico para calibrar.</p> <p> <p></p> <p></p> <p>En el editor online python.microbit y en el editor Mu la calibraci\u00f3n de la br\u00fajula no se almacena por lo que es necesario realizar el proceso de calibraci\u00f3n cada vez que se resetee o restablezca la alimentaci\u00f3n de la micro:bit. Para incluir la calibraci\u00f3n en un programa disponemos de la instrucci\u00f3n:</p> <pre><code>compass.calibrate()\n</code></pre> <p>En el video de Javier Quintana Calibraci\u00f3n br\u00fajula microBIT publicado en youtube podemos apreciar el proceso.</p> <p>Volver </p> <p>MakeCode</p> <p>Bas\u00e1ndonos en la definici\u00f3n de Azimut (o acimut) como el \u00e1ngulo que forman el norte geogr\u00e1fico y la proyecci\u00f3n vertical de un cuerpo sobre el horizonte del observador situado a una determinada latitud, vamos a crear un sencillo ejemplo que nos devuelva el valor del mismo ll micro:bit.</p> <p>La latitud es el \u00e1ngulo entre el ecuador y un punto cualquiera del planeta medido a lo largo del meridiano en el que se encuentra dicho punto.</p> <p> <p> Angulo entre el polo norte y la direcci\u00f3n de la micro:bit</p> <p></p> <p>En MakeCode tenemos el bloque  que nos da un n\u00famero entre 0 y 359 seg\u00fan la orientaci\u00f3n de la micro:bit. </p> <p>El programa siguiente nos calcula el \u00e1ngulo que forma la micro:bit respecto al polo norte magn\u00e9tico con el logo como indicador de la direcci\u00f3n.</p> <p>Descargar el programa</p> <p> <p> Ejemplo de medida de azimut</p> <p></p> <p>Si activamos Show data en el Simulador y movemos la aguja que simula la br\u00fajula podemos ver los datos mas o menos as\u00ed:</p> <p> <p> Simulaci\u00f3n del ejemplo de medida de azimut</p> <p></p> <p>Si flasheamos el programa en la micro:bit podemos ver los datos reales. Esto siempre despu\u00e9s de realizar la calibraci\u00f3n del magnet\u00f3metro explicada.</p> <p> <p> Datos reales del ejemplo de medida de azimut</p> <p></p> <p>Volver </p> <p>Python</p> <p>Recordemos que en Python es necesario calibrar el magnet\u00f3metro antes de nada. Hacemos un programa como el siguiente:</p> <pre><code>from microbit import *\n\ncompass.calibrate()\nwhile True:\n    azimut = compass.heading()\n    uart.write(str(azimut)+\"\\r\\n\")\n    sleep(1000)\n</code></pre> <p>Hasta que no finalicemos la calibraci\u00f3n no entramos en el bucle <code>while</code>. En la imagen siguiente vemos el programa en el editor Mu junto con los resultados tras realizar la calibraci\u00f3n.</p> <p> <p> Ejemplo de medida de azimut en Python</p> <p></p> <p>Descargar el programa</p>"},{"location":"conceptos/avanzados/#acelerometro","title":"Aceler\u00f3metro","text":"<p>Ya dijimos al principio que el LSM303AGR incorpora tambi\u00e9n un aceler\u00f3metro, pero recordemos brevemente algunos conceptos:</p> <ul> <li>Se puede decir que la velocidad es una medida de la distancia que recorre un objeto en un tiempo dado.</li> <li>La aceleraci\u00f3n es una medida de c\u00f3mo cambia la velocidad. La aceleraci\u00f3n es algo que estamos acostumbrados a sentir en nuestro d\u00eda a d\u00eda, por ejemplo cuando avanzamos con un coche o cuando frenamos, o en un autob\u00fas, o la gravedad que nos atrae al lugar en el que estamos parados.</li> </ul> <p>Esto tiene su principio en la primera Ley de Newton o ley de inercia, que viene a decir que un cuerpo en reposo, permanecer\u00e1 en reposo hasta que una fuerza lo haga moverse, y al contrario, un cuerpo en movimiento se mantendr\u00e1 en movimiento hasta que una fuerza lo detenga.</p> <p>T\u00e9cnicamente es posible conseguir fabricar un condensador en el que la energia almacenada en el mismo, que depende de su geometria y de la distancia entre sus placas, pueda traducirse en saber la aceleraci\u00f3n que tiene.</p> <p>Un aceler\u00f3metro es un dispositivo capaz de medir la aceleraci\u00f3n inercial (a = dv/dt) que sufre el componente.</p> <p>La asegunda Ley de Newton o ley fundamental de la din\u00e1mica, nos indica que el cambio de movimiento es proporcional a la fuerza motriz que lo provoca, quedando descrito por su momento:</p> <p>p = m \\cdot v \\space ; \\space F =dp/dt \\to F = m \\cdot a</p> <p>Un sensor de este tipo utiliza internamente componentes denominados MEMS (MicroElectroMechanical Systems) que son sistemas que llevan partes m\u00f3viles en su interior de forma que tenemos un cuerpo s\u00f3lido, en cuyo interior hay una masa sujeta por muelles al cuerpo exterior. La idea se explica mucho mejor observado la siguiente animaci\u00f3n extraida de https://howtomechatronics.com/.</p> <p> <p> Principio de funcionamiento de un aceler\u00f3metro</p> <p></p> <p>Este principio aplicado a tres direcciones es lo que lleva el chip incorporado en la micro:bit, as\u00ed que dependiendo de como la agitemos lo puede interpretar. Como la gravedad tambi\u00e9n influye en la separaci\u00f3n de las placas es posible dfeterminar la orientaci\u00f3n de la placa.</p> <p>Quiz\u00e1 el ejemplo mas recurrente de todos los posibles aplicando el aceler\u00f3metro sea la creaci\u00f3n de un dado electr\u00f3nico consistente en que al agitar la micro:bit se muestre un n\u00famero aleatorio entre 1 y 6. El programa es tan simple como vemos a continuaci\u00f3n:</p> <p> <p> Ejemplo creaci\u00f3n de un dado</p> <p></p> <p>El bloque si agitado inicia un manejador de eventos (parte del programa que se ejecutar\u00e1 cuando algo suceda). Este manejador funciona cuando haces un gesto (como agitar el micro:bit). A su vez gesto significa la forma en que se sostiene la micro:bit, que puede tomar como valores: agitar, logo arriba, logo abajo, pantalla arriba, pantalla abajo, inclinar a la izquierda, inclinar a la derecha, ca\u00edda libre, 3g, o 6g. En ingl\u00e9s se denominan shake, logo up, logo down, screen up, screen down, tilt left, tilt right, free fall, 3g, or 6g.</p> <p>Este mismo programa en Python ser\u00eda:</p> <pre><code>from microbit import *\n\nimport random\nwhile True:\n    if accelerometer.was_gesture('shake'):\n        dado = random.randint(1, 6)\n        display.clear()\n        display.show(dado)\n</code></pre> <p>Vemos el ejemplo en funcionamiento en el simulador.</p> <p> <p> Ejemplo creaci\u00f3n de un dado</p> <p></p> <p>El mismo ejemplo se puede resolver a trav\u00e9s del bloque \"Is gesture\" (es un gesto), as\u00ed:</p> <p> <p> Ejemplo creaci\u00f3n de un dado</p> <p></p>"},{"location":"conceptos/discretos/","title":"Componentes discretos","text":"<p>Se describen brevemente las caracter\u00edsticas y principio de funcionamiento de los componentes b\u00e1sicos para construir circuitos que se montan para pruebas.</p>"},{"location":"conceptos/discretos/#cables-y-conectores","title":"Cables y conectores","text":"<p>En electr\u00f3nica se utilizan multitud de cables y conectores especializados por caracter\u00edsticas y por aplicaci\u00f3n. Para lo que nos interesa existen unos componentes b\u00e1sicos conocidos como puentes, jumpers o cables dupont que est\u00e1n dise\u00f1ados para interconectar componentes mediante la inserci\u00f3n de sus dos terminales.</p> <p>Estos cables utilizan en sus extremos (lo llevan crimpado) o bien conectores macho (Male) o bien hembra (Female), por lo que se pueden clasificar en los tres tipos siguientes, que se comercializan en diferentes colores y longitudes.</p> <p> Conexiones Cable macho-macho (M/M) hembra/hembra (F/F) macho/hembra (M/F) <p></p>"},{"location":"conceptos/discretos/#protoboard","title":"Protoboard","text":"<p>Tambi\u00e9n conocida como breadboard es una placa con multitud de agujeros interconectados de una determinada manera formando grupos de conexiones. Permiten montar de forma r\u00e1pida circuitos mas o menos sencillos. Existen de muchos tama\u00f1os diferentes de los que vemos una muestra en la imagen.</p> <p> <p> Placas protoboard</p> <p></p> <p>Hay dos cosas importantes en este tipo de componente, la primera es no introducir en los agujeritos componentes o cables de mas de 0.5mm de di\u00e1metro porque a la larga esto provocar\u00e1 falsos contactos con otros componentes y la segunda es tener muy claro como van conectados internamente los agujeros.</p> <p> <p> Conexiones internas en placas protoboard</p> <p></p>"},{"location":"conceptos/discretos/#resistencias","title":"Resistencias","text":"<p> 4 bandas 5 bandas 6 bandas</p>"},{"location":"conceptos/discretos/#fijas","title":"Fijas","text":"<p>La resistencia es un componente electr\u00f3nico del grupo denominado pasivos que est\u00e1 dise\u00f1ado para oponerse al paso de la corriente. El valor de la resistencia se expresa en ohmios o sus m\u00faltiplos. Se fabrican principalmente de carb\u00f3n (la mina de un l\u00e1piz es una resistencia) o de pelicula met\u00e1lica y se comercializan en una amplia gama de valores. Su aspecto lo vemos en la imagen.</p> <p> <p> Resistencias</p> <p></p> <p>Las resistencias est\u00e1n definidas por tres caracter\u00edsticas fundamentales:</p> <ul> <li>el valor resistivo</li> <li>la potencia m\u00e1xima que puede disipar</li> <li>la tolerancia</li> </ul> <p>Hay resistencias con valores de Ohmios (\u2126), Kilohmios (K\u2126), Megaohmios (M\u2126) y otros m\u00faltiplos y subm\u00faltiplos. La equivalencias entre ellas es:</p> <ul> <li>1 Kilohmio (K\u2126) = 1,000 Ohmios (\u2126)</li> <li>1 Megaohmio (M\u2126) = 1,000,000 Ohmios (\u2126) = 1,000 Kilohmios (K\u2126)</li> </ul> <p>Para poder saber que valor y tolerancia tiene una resistencia, existe un c\u00f3digo de colores que nos ayuda a obtener con facilidad estos valores. La potencia no se indica expresamente en este tipo de resistencias y depende de su tama\u00f1o, por lo que con el uso nos iremos acostumbrando.</p> <p>Existen resistencia de 3 (en desuso), 4, 5 y 6 bandas de colores y cada una se lee de manera diferente aunque parecida. Veamoslas.</p> <p>Existen muchas p\u00e1ginas y aplicaciones que nos ayudan a averiguar el valor de una resistencia por sus bandas de color. Una muy completa y f\u00e1cil de usar es la de Digikey, una tienda de componentes que adem\u00e1s nos ofrece otras muchas calculadoras que nos resultar\u00e1n \u00fatiles.</p> <p>Volver </p> <p>4 bandas</p> <p>En estas, una de las bandas estar\u00e1 m\u00e1s cercana al terminal o patilla, puede ser mas ancha y es esa su primera cifra significativa o banda 1, la siguiente es la banda 2, la siguiente es la banda multiplicadora y la cuarta banda es la banda de tolerancia, esta banda normalmente es mas estrecha. A continuaci\u00f3n vemos como se leen estas resistencias.</p> <p> <p> Resistencias de cuatro bandas</p> <p></p> <p>El valor se obtendr\u00eda poniendo: 56 x 10\u2074 = 560k \u00b1 5%</p> <p>Volver </p> <p>5 bandas</p> <p>En este caso hay tres cifras significativas y se leen como vemos a continuaci\u00f3n.</p> <p> <p> Resistencias de cinco bandas</p> <p></p> <p>El valor se obtendr\u00eda poniendo: 247 x 10\u00b2 = 24700 = 24K7 \u00b1 5%</p> <p>Volver </p> <p>6 bandas</p> <p>A estas resistencias se a\u00f1ade una sexta banda como \u00faltima banda para indicar el coeficiente de temperatura y tambi\u00e9n tienen tres cifras signiticativas. A continuaci\u00f3n vemos como se leen. El coeficiente de temperatura indica cuanto cambia el valor de la resistencia en funci\u00f3n de la temperatura utilizando normalmente ppm/K (partes por mill\u00f3n por grado Kelvin) como unidad. Es muy raro ver resistencias de seis bandas como componente habitual.</p> <p> <p> Resistencias de seis bandas</p> <p></p> <p>El valor se obtendr\u00eda poniendo: 412 x 10\u00b3 = 412K \u00b1 1% y 5 ppm/K</p>"},{"location":"conceptos/discretos/#el-potenciometro","title":"El potenci\u00f3metro","text":"<p>Se trata de un tipo de resistencia en la que es posible cambiar su valor. Es un dispositivo que normalmente tiene tres terminales. Un potenci\u00f3metro suele estar formado por un material resistivo (un hilo de cobre u otro material conductor o un elemento de carb\u00f3n) y una escobilla (denominada cursor) de contacto m\u00f3vil. Cuando el cursor se desplaza a lo largo del elemento resistivo, se produce un cambio en la resistencia entre el terminal unido a este y los terminales extremos que es entre los que est\u00e1 la resistencia total fija caracter\u00edstica del potenci\u00f3metro.</p> <p> <p> Conexi\u00f3n habitual del potenci\u00f3metro</p> <p></p> <p>En la imagen siguiente vemos el aspecto de un modelo concreto de potenci\u00f3metro as\u00ed como los s\u00edmbolos habituales del mismo. La numeraci\u00f3n indica lo siguiente:</p> <ul> <li>Terminales 1 y 3 son los contactos unidos a los extremos de la resistencia fija o resistencia total del potenci\u00f3metro.</li> <li>Terminal 2 es el contacto que va unido al cursor o parte m\u00f3vil que se desliza sobre la resistencia fija haciendo que la resistencia entre un terminal y el cursor var\u00ede en funci\u00f3n de la posici\u00f3n de este.</li> </ul> <p> <p> Aspecto y s\u00edmbolo del potenci\u00f3metro</p> <p></p> <p>La posici\u00f3n del cursor se determina de forma mec\u00e1nica y son adecuados para usarlos como elementos de control de tensi\u00f3n (conexi\u00f3n en serie) o de corriente (conexi\u00f3n en paralelo). Los potenci\u00f3metros del tipo que estamos viendo (existen de otros muchos tipos) tienen un funcionamiento en forma de rotaci\u00f3n con un \u00e1ngulo de unos 270 grados entre los puntos mas extremos.</p>"},{"location":"conceptos/discretos/#sensor-de-luz-ldr","title":"Sensor de luz. LDR.","text":"<p>Detecci\u00f3n de luz con la micro:bit La fotoresistencia LDR</p> <p>La micro:bit monta en su parte frontal una matriz de 5x5 LEDs que se corresponden con el siguiente esquema:</p> <p> <p> Esquema de la matriz de LEDs</p> <p></p> <p>Se pueden utilizar estos LEDs en modo de polarizaci\u00f3n inversa para detectar la cantidad de luz que incide sobre la pantalla. El valor retornado ser\u00e1 un n\u00famero entero entre 0 y 255 y representa el nivel de luz de menor a mayor.</p> <p>COL1 a COL5 trabajan normalmente como salidas del nRF52 que se utilizan para iluminar selectivamente los LEDs. Aunque COL1, COL3 y COL5 est\u00e1n conectadas a pines aptos para ADC, la detecci\u00f3n de luz se hace de manera digital.</p> <p>ROW1 a ROW5 suelen ser salidas que suministran corriente para los LEDs. Pero tambi\u00e9n se utilizan como entradas digitales cuando queremos detectar luz.</p> <p>En resumen, la micro:bit detecta la intensidad de la luz ambiente a trav\u00e9s de la matriz de LED. En el modo de polarizaci\u00f3n directa, la pantalla LED funciona como una pantalla. En el modo de polarizaci\u00f3n inversa, la pantalla LED funciona como un sensor de luz b\u00e1sico que se puede utilizar para detectar la luz ambiente.</p> <p>Volver </p> <p>Detecci\u00f3n de luz con la micro:bit <p>El diodo LED est\u00e1 compuesto por una uni\u00f3n PN de dos materiales semiconductores uno de ellos dopado con cargas de tipo P y el otro con cargas de tipo N. Con la creaci\u00f3n de esta uni\u00f3n, y precisamente en esa zona, se crea lo que se denomina barrera de potencial.</p> <p> <p> Barrera de potencial en la uni\u00f3n PN</p> <p></p> <p>Esa uni\u00f3n PN cuando se dispone adecuadamente con distintos materiales tiene la capacidad de emitir luz visible debida al calor generado en la recombinaci\u00f3n de electrones.  En los a\u00f1os que van de 1960 a 1990, se utilizaban como materiales para la construcci\u00f3n del LED el Aluminio (Al), Galio (Ga), Indio (In), Ars\u00e9nico (As) y F\u00f3sforo (P) y con ellos se logr\u00f3 la obtenci\u00f3n de luz con longitudes de onda entre 660 y 590 nm, con tonos rojos, naranjas y \u00e1mbar. Posteriormente se introdujo Nitr\u00f3geno (N), junto con el Indio y el Galio, lo que dio paso a la obtenci\u00f3n de radiaciones de longitud de onda entre 585 y 430 nm, de tonos verdes y azules. En 1992 se consigue la luz blanca con la ayuda del F\u00f3sforo (P) que al ser atravesado por luz azul produce luz blanca. La combinaci\u00f3n del Galio con distintos elementos da origen a las diferentes longitudes de onda y por tanto a los diferentes colores.</p> <p>Cuando un LED se polariza inversamente circula por el mismo una corriente muy peque\u00f1a y se puede comprobar que depende de la luz, lo que podemos utilizar para medir el nivel de luminosidad en crudo. Es decir, podemos detectar como de brillante es la luz en el entorno del LED. Si miramos un diodo LED con un lupa o c\u00e1mara que permita aumentar bastante el zoom podemos llegar a ver la zona que emite luz.</p> <p> <p> Diodo LED muy de cerca</p> <p></p> <p>En la zona tipo P las cargas positivas se pueden mover libremente mientras que en la zona N lo hacen las negativas. Cuando se crea la uni\u00f3n las cargas mas cercanas de cada zona se recombinan creando la denominada barrera de potencial, donde no hay movimiento de cargas. Esto se puede considerar como un aislante que separa a dos conductores, o lo que es lo mismo, un condensador, eso si de muy baja capacidad. Sabemos tambi\u00e9n que la capacidad de un condensador viene dada por:</p> <p>C = \\epsilon_{0} \\cdot \\dfrac{S}{d}</p> <p>donde \\epsilon_{0} es la permitividad en el vacio, S es la superficie de las placas y d es la distancia que las separa.</p> <p>Esa barrera de potencial cambia seg\u00fan la luz que incide sobre sobre la misma, aumentando a mayor luminosidad y disminuyendo a menor luminosidad. El aumento de la barrera hace que la disminuya la superficie de las zonas P y N. Un sencillo experimento no permite medir los cambios de esa capacidad demostrando as\u00ed que un LED puede ser un sensor de luz.</p> <p>En mi caso voy a utilizar el medidor de componentes GSM328A que es un medidor de muy bajo coste (se puede encontrar por menos de 8\u20ac) pero que resulta bastante \u00fatil para este tipo de tareas.</p> <p>Siguiendo las instrucciones del manual colocamos el diodo LED en la posici\u00f3n central y rotando el encoder localizamos la posici\u00f3n de medida de baja capacidad y pulsamos para activar.</p> <p> <p> Posicionado del LED y selecci\u00f3n de medida en el GSM328A</p> <p></p> <p>Medidas con diferentes grados de iluminaci\u00f3n obtenidos simplemente tapando el LED.</p> <p> <p> Meidas de capacidad del LED con el GSM328A</p> <p></p> <p>En la micro:bit la medida del nivel de iluminaci\u00f3n consiste principalmente en medir la capacidad de unos determinados LEDs de la pantalla obteniendo el promedio y devolviendo un n\u00famero entre 0 y 255.</p> <p> <p> LEDs de la micro:bit implicados en la medida de luminosidad</p> <p></p> <p>Volver </p> <p>La Fotorresistencia LDR <p>Existe tambi\u00e9n un tipo de resistencia especial denominado fotoresistencia o fotoresistor que es un componente electr\u00f3nico cuya resistencia disminuye de forma exponencial con el aumento de la intensidad de luz incidente. Las siglas LDR vienen de su nombre en ingl\u00e9s, que es Light Dependent Resistor. En la imagen siguiente tenemos el s\u00edmbolo, el aspecto real de una LDR y su curva caracter\u00edstica de variaci\u00f3n de resistencia con la iluminaci\u00f3n.</p> <p> <p> S\u00edmbolo, aspecto y curva caracter\u00edstica de la LDR</p> <p></p> <p>La resistencia de una LDR varia en proporci\u00f3n a la luz ambiental detectada. Con esta caracter\u00edstica, podemos utilizar una LDR para detectar la intensidad de la luz.</p> <p>A continuaci\u00f3n vemos los circuitos que se utilizan para detectar el cambio del valor de resistencia de una LDR cuando la conectamos a una micro:bit:</p> <p> <p> Circuitos para detectar variaciones de R en la LDR</p> <p></p> <p>En estos circuitos, cuando el valor de la resistencia de la LDR cambia debido a un cambio en la intensidad de la luz, las tensiones en la LDR y la resistencia fija tambi\u00e9n cambiar\u00e1n. Podemos hacer que el valor de la intensidad de la luz se corresponda con esa tensi\u00f3n.</p>"},{"location":"conceptos/discretos/#el-termistor","title":"El termistor","text":"<p>El termistor (contracci\u00f3n de t\u00e9rmico y resistor) es una resistencia sensible a la temperatura, es decir, que cuando se produce un cambio de temperatura, la resistencia del termistor var\u00eda. Normalmene tiene forma de peque\u00f1a gota o perla, disco tipo lenteja o un cilindro encapsulado.</p> <p>Hay dos tipos de termistores, los que tienen un Coeficiente de Temperatura Negativo (NTC) y lo que tienen un Coeficiente de Temperatura Positivo (PTC). En un termistor NTC cuando la temperatura aumenta su resistencia disminuye y a la inversa, cuando baja la temperatura su resistencia aumenta. Esta caracter\u00edstica la podemos aprovechar para medir temperaturas.</p> <p>En un termistor PTC cuando aumenta la temperatura lo hace su resistencia y cuando disminuy la temperatura tambi\u00e9n lo hace su resistencia. Este tipo de termistor se usa principalmente como fusible t\u00e9rmico.</p> <p>El s\u00edmbolo de un termistor es:</p> <p> <p> S\u00edmbolo usuales del termistor</p> <p></p> <p>Existen muchas y variadas formas de encapsulados de termistores y en la Wikipedia aparecen clasificados por su forma.</p> <p> <p> Encapsulados de los termistores</p> <p></p> <p>La curva caracter\u00edstica de un termistor NTC es la siguiente:</p> <p> <p> Curva Resistencia/Temperatura termistor NTC</p> <p></p> <p>La ecuaci\u00f3n que relaciona el valor de resistencia y la temperatura es:</p> <p>R = R_0 \\cdot e^{\\beta \\cdot (\\dfrac{1}{T} -\\dfrac{1}{T_0})}</p> <p>Donde:</p> <ul> <li>R es la resistencia a temperatura ambiente T</li> <li>R_0 es la resistencia a la temperatura ambiente T_0</li> <li>\\beta es la constante del termistor</li> </ul> <p>La constate \\beta viene dada por:</p> <p>\\beta = \\ln\\dfrac{\\dfrac{R}{R_0}}{\\dfrac{1}{T}-\\dfrac{1}{T_0}}</p> <p>Los valores de resistencia nominal dados a 25\u00baC para termistores comerciales habituales son de 1K, 10K y 100K, aunque existen de otro valores.</p> <p>El esquema de conexionado mas sencillo de un termistor es como el siguiente:</p> <p> <p> Esquema base de conexionado de un termistor NTC</p> <p></p> <p>En ese circuito es muy f\u00e1cil saber el valor de la tensi\u00f3n en P0, ya que por teor\u00eda del divisor de tensi\u00f3n tenemos que:</p> <p>V_{P_0} = 3.3 \\cdot\\dfrac{R_t}{R+R_t} \\Rightarrow R_t = \\dfrac{R}{\\dfrac{3.3}{V_{P_0}}-1}</p> <p>Podemos utilizar el valor anal\u00f3gico medido en el pin P0 para obtener el valor de resistencia del termistor poder obtener la temperatura a partir de la ecuaci\u00f3n:</p> <p>T = (\\dfrac{1}{T_0}+\\dfrac{\\ln(\\dfrac{R}{R_0})}{\\beta})^{-1}</p> <p>El rango de temperatura en la que el termistor tiene un comportamiento muy estable y de gran sensibilidad se sit\u00faa en torno a los 50\u00baC sobre una temperatura central. Otras ventajas de este tipo de termistores es que son muy econ\u00f3micos y que tienen un durabilidad muy alta. Sus principales desventajas son que no tienen un comportamiento lineal, su tiempo de respuesta es relativamente lento (entre 7 y 10 segundos) y su rango de temperatura es limitado.</p> <p>Un ejemplo de termistor NTC es el del datasheet en el que el fabricante nos suministra los valores de R_0, \\space T_0 \\space y \\space \\beta. En la tabla extraida del datasheet podemos ver estos datos para distintas resistencias, en nuestro caso trabajamos con una que con T_0 = 25\u00baC, \\space R_0 = 10K \\space y \\space \\beta = 3977</p> <p> <p></p> <p></p> <p>La curva caracter\u00edstica de un termistor PTC es la siguiente:</p> <p> <p> Curva Resistencia/Temperatura termistor PTC</p> <p></p> <p>El circuito t\u00edpico de aplicaci\u00f3n de un termistor PTC es el siguiente:</p> <p> <p> Esquema base de conexionado de un termistor PTC</p> <p></p> <p>Los termistores tienen diversas utilizaciones y algunas de ellas pueden ser:</p> <ul> <li>Control de temperatura de extrusor y cama caliente en impresoras 3D de fusi\u00f3n de material.</li> <li>Termostatos.</li> <li>Control de temperatura de aceite en autom\u00f3viles.</li> <li>Control de temperatura en frigorificos y hornos.</li> <li>Protecci\u00f3n contra sobretensiones.</li> <li>Control de temperatura en la carga de baterias.</li> </ul>"},{"location":"conceptos/discretos/#el-diodo-semiconductor","title":"El diodo semiconductor","text":"<p>Son dispositivos que permiten el paso de la corriente electrica en un solo sentido y la bloquean en el contrario. Se suelen conocer tambi\u00e9n como rectificadores por su capacidad de convertir la corriente alterna en corriente continua pulsatoria. Existen diferentes tipos de diodos y nos centraremos en describir como funcionan los diodos de estado s\u00f3lido sin entrar en demasiados fundamentos cient\u00edficos. El s\u00edmbolo del diodo es un tri\u00e1ngulo que viene a indicar el sentido permitido de circulaci\u00f3n de corriente y la barrera que se opone en el contrario.</p> <p> <p> S\u00edmbolo usuales del diodo</p> <p></p> <p>El funcionamiento del diodo se basa en su construcci\u00f3n y esta se realiza mediante la uni\u00f3n de dos materiales semiconductores de un determinado tipo (normalmente silicio) dopados de forma controlada con carga de electrones (zona de tipo N) y otra con carga de protones o huecos o ausencia de electrones (zona de tipo P). Esto crea una uni\u00f3n PN en la que la zona tipo N recibe el nombre de c\u00e1todo (K) y la zona de tipo P de \u00e1nodo (A). Polarizando directamente la uni\u00f3n se reduce la barrera de la uni\u00f3n facilitando el paso de la corriente y si se polariza inversamente ocurre lo contrario y se impide la circulaci\u00f3n de corriente.</p> <p> <p> Funcionamiento esquematizado de un diodo</p> <p></p> <p>Los tipos de diodos se caracterizan de manera b\u00e1sica por los materiales con los que est\u00e1n fabricados y por la cantidad de impurezas dopantes. Entre otros nos podemos encontrar con:</p> <ul> <li>Laser. Son capaces de generar un rayo de luz laser con una longitud de onda entre 800 y 850 nan\u00f3metros. Se aplica en fibra \u00f3ptica, punteros laser, lectores de c\u00f3digo de barras, etc.</li> <li>Zener. Est\u00e1n dise\u00f1ados para trabajar en polarizaci\u00f3n inversa de forma que al alcanzar un determinado nivel de tensi\u00f3n inversa (tensi\u00f3n zener) comienza a conducir manteniendo practicamente constante esa tensi\u00f3n de ruptura zener. Su aplicaci\u00f3n fundamental est\u00e1 en los reguladores de tensi\u00f3n constante.</li> <li>Schottky. Debe el nombre a su inventor Walter Schottky y se conoce tambi\u00e9n como diodo de conmutaci\u00f3n r\u00e1pida, ya que esta es su principal caracter\u00edstica. Esta rapidez es posible porque son sufientes 0.3V de diferencia de tensi\u00f3n para que se produzca el cambio de conducci\u00f3n. Tienen aplicaci\u00f3n all\u00ed donde son necesarias las altas velocidades de conmutaci\u00f3n.</li> <li>LED. Basan su funcionamiento en la generaci\u00f3n de fotones por recombinaci\u00f3n de los portadores de cargas. Existen de diversos colores y se aplican en muchos sitios diferentes. En el apartado siguiente se explica algo mas de los mismos.</li> <li>Shockley. No confundir con Schottky. Est\u00e1 formado por cuatro capas alternando zonas P y N, lo que lo convierten b\u00e1sicamente en un tipo de tiristor. Su funcionamiento se basa en pasar de un estado de baja impedancia (conducci\u00f3n) a otro de alta impedancia (corte) por disminuci\u00f3n de la tensi\u00f3n con el consiguiente aumento de corriente. A la inversa se pasa de saturaci\u00f3n a corte. El invento es debido al f\u00edsico William Shockley uno de los descubridores del transistor.</li> </ul> <p>La simbolog\u00eda de los diferentes diodos gira en torno a variaciones del s\u00edmbolo fundamental visto. En la entrada S\u00edmbolo electr\u00f3nico  se pueden consultar junto con los de otros muchos componentes.</p> <p>En la infografia Funcionamiento y polarizaci\u00f3n del diodo semiconductor tenemos un resumen de sus caracter\u00edsticas tensi\u00f3n/corriente y su funcionamiento. Aqu\u00ed est\u00e1 el archivo en formato pdf.</p>"},{"location":"conceptos/discretos/#el-diodo-led","title":"El diodo LED","text":"<p>Matriz de de barras de LEDs LED RGB</p> <p>El diodo LED (Light Emitting Diode) es un diodo semiconductor capaz de emitir luz, lo mas usuales dentro del espectro visible aunque tambi\u00e9n pueden ser de infrarrojos, laser, etc. Su uso mas habitual es como indicador y, \u00faltimamente cada vez mas frecuentes en iluminaci\u00f3n. Sus principales ventajas frente a luces incandescentes son:</p> <ul> <li>Menor consumo de energ\u00eda</li> <li>Mayor vida \u00fatil</li> <li>Menor tama\u00f1o</li> <li>Gran durabilidad y fiabilidad</li> <li>En la imagen siguiente vemos el aspecto f\u00edsico que tiene y su s\u00edmbolo electr\u00f3nico.</li> </ul> <p> <p> Aspecto y s\u00edmbolo del LED</p> <p></p> <p>El color de la c\u00e1psula es simplemente orientativo, es la longitud de onda quien define realmente el color de la luz emitida. Por ello el LED con la c\u00e1psula transparente puede emitir en cualquiera de los colores del espectro visible.</p> <p>La forma de la capsula mas habitual es cil\u00edndrica de 3 o 5 mm de di\u00e1metro, aunque existen otras formas menos usuales como las que vemos en la imagen siguiente:</p> <p> <p> Tipos de encapsulados para LEDs</p> <p></p> <p>El LED es un dispositivo que tiene polaridad siendo su comportamiento el siguiente: En polarizaci\u00f3n directa (\u00e1nodo a positivo y c\u00e1todo a negativo) el LED emite luz y en polarizaci\u00f3n inversa (\u00e1nodo negativo y c\u00e1todo positivo) se comporta pr\u00e1cticamente como un interruptor abierto.</p> <p>Para su correcto funcionamiento el diodo LED se polariza poni\u00e9ndole en serie una resistencia que limita la corriente que pasa a trav\u00e9s del mismo y, por tanto, determina el nivel de brillo de la luz emitida.</p> <p>Sin entrar en detalles en la tabla siguiente se dan los valores de tensi\u00f3n directa (VF) y corriente directa (IF) para los colores mas habituales de LEDs. A partir de estos valores y el valor de tensi\u00f3n de alimentaci\u00f3n de nuestro LED podemos calcular el valor de la resistencia serie sin mas que aplicar la formula indicada.</p> <p> <p> Tensi\u00f3n y corriente para distintos colores</p> <p></p> <p>Volver </p> <p>Matriz de de barras de LEDs</p> <p>Estas matrices de LED pueden tener distinto n\u00famero de elementos y est\u00e1n dise\u00f1adas para mostrar informaci\u00f3n en forma de gr\u00e1fico de barras f\u00e1cilmente reconocible. Los elementos suelen ser acoplables por los extremos y, por tanto, tienen capacidad de extensi\u00f3n. El uso de estas matrices de gr\u00e1ficos de barras elimina los problemas de alineaci\u00f3n, intensidad y coincidencia de colores asociados a los LED discretos. Existen modelos en que todos los LEDs son del mismo color y existen otros en los que cada LED es de un color diferente, por ejemplo rojos, amarillos y verdes. En definitiva son LED individuales dispuestos en el encapsulado en forma de barra.</p> <p>Normalmente un barra tiene 10 LEDs integrados en un mismo encapsulado con dos filas de pines que permiten manejarlos como LEDs individuales. En la imagen vemos su aspecto real y el diagrama de pines.</p> <p> <p> Aspecto real y diagrama de pines de barra de 10 LEDs</p> <p></p> <p>Dependiendo del fabricante tendremos disponibilidad de mas datos sobre nuestra barra concreta o no, entre ellos la posibilidad de identificar los pines como \u00e1nodo o como c\u00e1todo.</p> <p>Volver </p> <p>LED RGB</p> <p>Un LED RGB es en realidad un encapsulado que incorpora tres diodos LED, uno por cada color fundamental y una patilla com\u00fan que puede ser el \u00e1nodo o el c\u00e1todo de los tres diodos.</p> <p>Los colores primarios en \u00f3ptica son el rojo, el verde y el azul y la correcta combinaci\u00f3n, en t\u00e9rminos de intensidad, de ellos originar\u00e1 cualquiera de los colores secundarios. Las siglas RGB son el acr\u00f3nimo de Red, Green y Blue. En la imagen siguiente vemos el modelo aditivo de los colores rojo, verde y azul.</p> <p> <p> RGB Imagen obtenida de Wikipedia</p> <p></p> <p>Existen dos tipos de LEDs RGB seg\u00fan est\u00e1n conectados internamente y pueden ser de c\u00e1todo com\u00fan o de \u00e1nodo com\u00fan. El s\u00edmbolo y la representaci\u00f3n de este componente lo vemos en la imagen siguiente, correspondiendo la pareja de la izquierda a los de c\u00e1todo com\u00fan y la pareja de la derecha a los de \u00e1nodo com\u00fan:</p> <p> <p> S\u00edmbolo y representaci\u00f3n LED RGB</p> <p></p> <p>El pin mas largo es el com\u00fan, el de su izquierda es el rojo (R), el de su derecha es el verde (G) y el \u00faltimo por la derecha el azul (B).</p> <p>Te\u00f3ricamente, cada uno de los LEDs podr\u00eda adoptar 256 (valores entre 0 y 255) colores diferentes, es decir, un total de 16.777.216 (256x3) posibles colores diferentes con un LED RGB. En realidad el ojo humano solamente puede ver unos 10 millones de colores definidos por lo que se conoce como espacio de color, que tiene como referencia est\u00e1ndar habitual el espacio de color el denominado CIELAB o CIEXYZ, dise\u00f1ados especificamente para abarcar lo que el ojo humano ve.</p>"},{"location":"conceptos/discretos/#pulsador","title":"Pulsador","text":"<p>Un bot\u00f3n pulsador o abreviadamente pulsador es un componente el\u00e9ctrico que permite o impide el paso de la corriente el\u00e9ctrica cuando se acciona. El pulsador solo permanece abierto o cerrado cuando lo presionamos y unicamente mientras lo mantenemos presionado. Al soltarlo vuelve a su posici\u00f3n inicial o de reposo.</p> <p>En funci\u00f3n de como est\u00e1n los contactos cuando el pulsador est\u00e1 en reposo, tenemos dos tipos diferentes: Normalmente Abierto y Normalmente Cerrado. Siendo el mas utilizado es pulsador normalmente abierto.</p> <p>El funcionamiento del pulsador normalmente abierto es:</p> <ul> <li>Pulsador en reposo: el pulsador esta abierto y la corriente no puede pasar a trav\u00e9s del mismo.</li> <li>Pulsador accionado: se conoce como posici\u00f3n de Trabajo y mientras se mantenga pulsado la corriente puede pasar por el pulsador.</li> </ul> <p>En la tabla siguiente vemos la simbolog\u00eda y algunos ejemplos del aspecto f\u00edsico de estos elementos del tipo que habitualmente se utiliza con este tipo de placas.</p> <p> <p> S\u00edmbolos y aspecto real de un pulsador</p> <p></p> <p>Existen muchos tipos y formas de pulsadores, pero los mas utilizados con este tipo de placas los vemos a continuaci\u00f3n. Los de mayor tama\u00f1o suelen ir acompa\u00f1ados de una pieza de diferentes colores para colocar por presi\u00f3n en la parte amarilla (puede ser de otros colores) el pulsador y crear una tecla. Se aprecian las dimensiones as\u00ed como la forma en que van conectados internamente los pines.</p> <p> <p> Pulsadores mas usuales</p> <p></p> <p>Mediante la configuraci\u00f3n adecuada podemos convertir un pulsador en un elemento de entrada a alg\u00fan pin de nuestra placa de control. Las configuraciones m\u00e1s b\u00e1sicas posibles con pulsadores las podemos ver en la imagen siguiente.</p> <p> <p> Configuraci\u00f3n circuito elemental con pulsador</p> <p></p>"},{"location":"conceptos/discretos/#rebotes","title":"Rebotes","text":"<p>Cuando accionamos un pulsador, este no cambia de un estado a otro inmediatamente. En el proceso de cambio de estado del pulsador se producen peque\u00f1as vibraciones mec\u00e1nicas que provocan una serie de efectos transitorios que pueden llegar a convertirse en un problema real. Supongamos que estamos contando pulsaciones, si cada vez que pulsamos esos efectos dan como resultado mas de un pulsaci\u00f3n, es evidente que tenemos un problema. Estos efectos se estabilizan muy rapidamente porque duran muy poco tiempo y por tanto a nivel humano no son detectables, pero a nivel de microcontrolador si lo son. El fenomeno tambi\u00e9n ocurre al soltar el pulsador. Este fen\u00f3meno no deseado es lo que se conoce como \"rebote\".</p> <p> <p> Fenomenos transitorios de rebotes en un pulsador</p> <p></p> <p>Por lo tanto, es muy posible que, cuando detectamos el estado de un pulsador, obtengamos m\u00faltiples acciones de pulsaci\u00f3n y liberaci\u00f3n en un ciclo de pulsaci\u00f3n. Este rebote puede llegar a confundir el funcionamiento del microcontrolador debido a la alta velocidad a la que trabaja. Por eso es conveniente eliminar el efecto de los rebotes en nuestros circuitos. Se puede hacer por hardware, colocando un condensador de 1uF, o incluso de mas capacidad, en paralelo con el pulsador. Tambien se pueden eliminar por software dejando transcurrir unos 150ms entre el momento que se acciona el pulsador y el momento en que la lectura se hace efectiva o bien comprobando el estado del bot\u00f3n varias veces y cuando ha transcurrido un tiempo considerar el estado del bot\u00f3n como estable. Dicho de otro modo, con una serie de lecturas y retardos del estado del pulsador se desechan esas pulsaciones no deseadas.</p>"},{"location":"conceptos/discretos/#interruptor","title":"Interruptor","text":"<p>La diferencia entre un pulsador y un interruptor radica en que el pulsador no mantiene su posici\u00f3n de trabajo si dejamos de accionarlo mientras que el interruptor si mantiene la posici\u00f3n, permaneciendo en la misma hasta que volvamos a accionarlo. Es decir, el interruptor cambia de posici\u00f3n cada vez que lo accionamos siendo totalmente estable cada posici\u00f3n. Hay ocasiones en que visualmente incluso pueden parecer iguales y solo se diferencian en su modo de funcionamiento.</p> <p>Los interruptores se clasifican en funci\u00f3n del tipo de conexi\u00f3n que realizan, como son el n\u00famero de polos (Pole) y el de circuitos (Throw). Se define el n\u00famero de polos como el n\u00famero de circuitos capaz de controlar el interruptor. Puden ser unipolares, para un solo circuito o bipolares para controlar dos circuitos separados. Podemos decir que un interruptor bipolar son dos interruptores unipolares accionados por el mismo actuador. Por otro lado Throw se refiere al n\u00famero de salidas que tiene cada polo. En base a esto tenemos:</p> <p> Tipo Procedencia Significado S\u00edmbolo SPST Single Pole, Single Throw Un polo, un circuito SPDT Single Pole, Double Throw Un polo, dos circuitos DPST Double Pole, Single Throw Dos polos, un circuito DPDT Double Pole, Double Throw Dos polos, dos circuitos <p></p> <p>En la imagen siguiente quedar\u00e1 mas claro el tema de Pole y Throw.</p> <p> <p> SPST, SPDT, DTSP y DPDT</p> <p></p> <p>En el caso de los interruptores tambi\u00e9n pueden ser Normalmente Abiertos o Normalmente Cerrados y existen de muchos tipos en funci\u00f3n de la aplicaci\u00f3n que se les va a dar. Tambi\u00e9n existen de mas de dos circuitos e incluso de varios polos.</p> <p>Por su forma de accionamiento pueden ser: rotatorios, basculantes, deslizantes, tipo DIP, etc. En la imagen vemos el aspecto real de algunos de ellos.</p> <p> <p> Diversos tipos de interruptores</p> <p></p>"},{"location":"conceptos/discretos/#el-transistor-bipolar-o-bjt","title":"El transistor bipolar o BJT","text":"<p>Las siglas BJT corresponden a Bipolar Junction Transistor, haciendo el t\u00e9rmino bipolar referencia al hecho de que en la conducci\u00f3n de la corriente intervienen los dos tipos de portadores (electrones y huecos) y Juntion a como est\u00e1 fabricado el dispositivo, que b\u00e1sicamente son dos uniones PN.</p> <p> <p> Uniones transistor BJT</p> <p></p> <p>Cuando nuestro proyecto utilice un dispositivo que requiera una corriente mayor que la que puede entregar un pin GPIO ser\u00e1 hora de recurrir a este tipo de dispositivo, que basicamente es un amplificador de corriente.</p> <p>En la figura siguiente aparecen los s\u00edmbolos del dispositivo con representaci\u00f3n de convenio de sentido de corrientes.</p> <p> <p> S\u00edmbolos transistor BJT</p> <p></p> <p>No vamos a entrar en detalles de funcionamiento interno, simplemente indicar que en su forma b\u00e1sica de funcionamiento dispone de tres zonas de trabajo: corte (interruptor abierto), saturaci\u00f3n (interruptor cerrado) y zona l\u00edneal. Seg\u00fan la aplicaci\u00f3n nos va a interesar que trabaje en conmutaci\u00f3n, con un cambio lo m\u00e1s r\u00e1pido posible entre corte y saturaci\u00f3n; o bien en zona lineal si lo que pretendemos es que se comporte como amplificador.</p> <p>Quiz\u00e1 el simil que mejor explica el funcionamiento, al menos desde mi punto de vista, es el que podemos encontrar en la p\u00e1gina de facebook de Ingenieria Mecafenis y que reproduzca aqu\u00ed.</p> <p> <p> Simil hidra\u00falico de funcionamiento del transistor</p> <p></p> <p>Existen tres tipos b\u00e1sicos seg\u00fan la potencia que son capaces de manejar: baja potencia o de se\u00f1al, mediana potencia y alta potencia. Adem\u00e1s de por sus caracter\u00edsticas electricas se distinguen por su encapsulados, de pl\u00e1stico para baja potencia, mixto pl\u00e1stico metal para mediana potencia y totalmente met\u00e1lico para alta potencia. En la figura vemos ejemplos de los mismos con el nombre del encapsulado.</p> <p> <p> Aspecto f\u00edsico en diferentes encapsulados</p> <p></p> <p>En nuestro caso tendremos suficiente con transistores de se\u00f1al tanto NPN como PNP. Hay miles de modelos de estos transistores. A continuaci\u00f3n dejamos una peque\u00f1a tabla con los m\u00e1s comunes por parejas de complementarios y el acceso a sus hojas de datos, aspecto fundamental a conocer cuando se trabaja con estos dispositivos.</p> <p> <p> Modelo Capsula Tipo V_{CE} Ic hFE Potencia 2N3904 TO92 NPN 40 V 200 mA 100 min 625 mW 2N3906 TO92 PNP 40 V 200 mA 100 min 625 mW BC547 TO92 NPN 45 V 100 mA 110 min 625 mW BC557 TO92 PNP 45 V 100 mA 110 min 625 mW S8050 TO92 NPN 25 V 1.5 A 40 min 1 W S8550 TO92 PNP 25 V 1.5 A 40 min 1 W MMBT3904 SOT23 NPN 40 V 200 mA 100 min 225 mW MMBT3906 SOT23 PNP 40 V 200 mA 100 min 225 mW <p></p> <p></p> <p>Dependiendo de la aplicaci\u00f3n que pretendamos dar a nuestro transistor habr\u00e1 que montar uno u otro circuito con mas o menos resistencias para mejorar su estabilidad. En la figura siguiente se exponen los tres circuitos b\u00e1sicos de polarizaci\u00f3n de un transistor montado en configuraci\u00f3n de emisor com\u00fan. Se denomina de emisoar com\u00fan porque esta es la patilla com\u00fan al circuito de entrada (base) y el de salida (colector).</p> <p> <p> Circuitos de polarizaci\u00f3n</p> <p></p> <p>Para nuestros prop\u00f3sitos el circuito de polarizaci\u00f3n por resistencia de base ser\u00e1 mas que suficiente para cualquiera de los transistores citados en la tabla anterior y el dispositivo a alimentar ser\u00e1 el sustituto de la resistencia de carga.</p> <p>En el tema teoria del transistor BJT obtenido de OpenCourseWare (OCW) del Instituto Tecnol\u00f3gico de Massachusetts (MIT) que adopta la Universidad del Pa\u00eds Vasco / Euskal Herriko Unibertsitatea con el fin de poner a disposici\u00f3n de la sociedad los materiales creados en la comunidad universitaria, se puede profundizar mas en el tema.</p>"},{"location":"conceptos/discretos/#transistor-mosfet","title":"Transistor MOSFET","text":"<p>La palabra MOSFET es un compuesto de dos terminos: MOS (Metal Oxido Semiconductor) en referencia al diel\u00e9ctrico utilizazo y FET (Field Effect Transistor o transistor de efecto de campo) en referencia a su modo de conducci\u00f3n por campo magn\u00e9tico. Es un transistor que se activa por tensi\u00f3n, es decir que aplicar tensi\u00f3n conduce la corriente entre dos de sus patillas y esta es controlada por la tercera patilla llamada \"Puerta o Gate\". Las otras dos patillas son \"Surtidor o Fuente\" y \"Dreandor\". La principales ventajas de un transistor MOSFET frente a un BJT son:</p> <ul> <li>Su patilla G se activa por tensi\u00f3n en lugar de por corriente.</li> <li>Se pueden construir en tama\u00f1os mas peque\u00f1os.</li> <li>Su velocidad de conmutaci\u00f3n corte/saturaci\u00f3n es del orden de nanosegundos.</li> <li>La conducci\u00f3n de corriente se controla por un campo electrico.</li> <li>Para su funcionamiento requieren menos potencia y por tanto disipan menos energia.</li> </ul> <p>Existen dos tipos de transistores MOSFET, los de canal N y los de canal P cuyos s\u00edmbolos vemos a continuaci\u00f3n:</p> <p> <p> S\u00edmbolos MOSFET</p> <p></p> <p>Un transistor MOSFET controla la corriente entre el surtidor (entrada) y el drenador (salida) mediante una tensi\u00f3n aplicada en la puerta denominada \"tensi\u00f3n de umbral\". Es un interruptor controlado por tensi\u00f3n.</p> <p>La base de su funcionamiento la vemos a continuaci\u00f3n.</p> <p> <p> Polarizaci\u00f3n MOSFET</p> <p></p> <p>A continuaci\u00f3n vemos definidas las zonas de funcionamiento sobre la curvas caracteer\u00edsticas tensi\u00f3n / corriente de un transistor gen\u00e9rico.</p> <p> <p> Curvas caracteer\u00edsticas tensi\u00f3n / corriente</p> <p></p> <p>Las zonas de funcionamiento son:</p> <ul> <li>Corte. La corriente I_D es nula independientemente del valor de V_{DS}. A efectos pr\u00e1cticos es el eje horizontal.</li> <li>No saturaci\u00f3n. Es la zona definida desde el codo de las curvas hacia la izquierda, es decir cuando la V_{DS} est\u00e1 por debajo del valor de saturaci\u00f3n. Es una zona de aumento de corriente donde el transistor tiene un comportamiento similar al de una resistencia variable controlada por la tensi\u00f3n de la puerta.</li> <li>Saturaci\u00f3n. Corresponde a la zona plana de las curvas con I_D constante definida desde el codo de saturaci\u00f3n hasta el valor m\u00e1ximo de V_{DS} que se conoce como tensi\u00f3n de ruptura y que es propio de cada transistor. En esta zona podemos asimilar el comportamiento del transistor como una fuente de corriente constante controlada por la tensi\u00f3n de puerta.</li> </ul>"},{"location":"conceptos/discretos/#zumbador-o-buzzer","title":"Zumbador o buzzer","text":"<p>Antes de entrar en descripciones t\u00e9cnicas de componentes vamos a hablar un poco del sonido, sin entrar en profundidad, y como reproducirlo con una micro:bit.</p> <p></p> <p>Zumbador pasivo Zumbador activo M\u00f3dulo amplificador Auriculares Sonido micro:bit V1 Sonido micro:bit V2</p> <p> Uno de los par\u00e1metros que caracterizan a un sonido es su frecuencia de emisi\u00f3n, siendo la frecuencia el n\u00famero de veces que se repite por unidad de tiempo (segundo). La transmisi\u00f3n del sonido se realiza por ondas a trav\u00e9s en cualquier medio (s\u00f3lido, l\u00edquido o gaseoso) excepto en el vac\u00edo. La frecuencia de un sonido nos indica cuantos ciclos por segundo tiene una onda.</p> <p>En la imagen y la tabla siguientes vemos un dibujo con un fragmento de las teclas de un piano estando todo referido a una nota est\u00e1ndar, la nota \"La\" central que tiene una frecuencia de 440 Hz. Podemos ver la nota musical que reproduce, en las dos notaciones m\u00e1s comunes de los sonidos (Ingl\u00e9s: C D E F G A B, Alem\u00e1n: C D E F G A H, Espa\u00f1ol, italiano y franc\u00e9s: Do Re Mi Fa Sol La Si) y adem\u00e1s se encuentra la frecuencia que produce esa nota musical.</p> <p> <p> Secci\u00f3n de piano y notas</p> <p></p> <p>Otro de los par\u00e1metros que caracterizan al sonido es su nivel y en sonido se caracteriza con los decibelios (dB) que es la forma de medir la intensidad del sonido. La percepci\u00f3n del sonido depende de factores como la intensidad, el tiempo que dura, las frecuencias o tonos y el entorno donde estamos. Vamos a introducir brevemente como medir la intensidad del sonido.</p> <p>Los decibelios (dB) son la unidad de medida de presi\u00f3n ac\u00fastica. Medimos presi\u00f3n, luego estamos midiendo una fuerza y mas concretamente una fuerza por unidad de superficie. Un sonido pierde intensidad seg\u00fan nos alejamos de la fuente y lo hace a un ritmo de unos 6 dB cada que vez que se duplica la distancia. Vemos un ejemplo: supongamos que escuchamos un sonido de 45 dB a una distancia de un metro, cuando nos pongamos a dos metros escucharemos 39 dB, cuando estemos a 4 metros, ser\u00e1 de 33 dB y cuando estemos a 8 metros, de 27 dB.</p> <p>La escala de medida en dB no es lineal, es logaritmica porque representa mejor la forma en que sentimos los cambios de la intensidad del sonido con nuestro oido. Algunos datos para reflexionar sobre el ruido:</p> <ul> <li>El sonido se vuelve da\u00f1ino para el ser humano a partir de los 75 dB.</li> <li>Alrededor de los 120 dB causa dolor. Una exposici\u00f3n de dos horas a 100 dB necesita un d\u00eda completo para que el oido compense la exposici\u00f3n.</li> <li>Sonido en torno a 180 dB pueden ocasionar la muerte.</li> </ul> <p>En la tabla vemos algunos ejemplos del d\u00eda a d\u00eda:</p> <p> nivel de sonido Percepci\u00f3n Situaci\u00f3n 0 dB Muy bajo Nivel de audici\u00f3n humano 10 a 30 dB Nivel bajo Conversaci\u00f3n tranquila. Biblioteca 30 a 50 dB Nivel bajo Conversaci\u00f3n normal. Motor frigorifico. Agua saliendo del grifo 55 a 75 dB Nivel considerable Aspirador. Calle con trafico denso. Despertador. Batidora 75 a 100 dB Nivel alto Sensaci\u00f3n molesta. Atasco de tr\u00e1fico. Sirena de policia 100 a 120 dB Muy alto Taladro/claxon/concierto R&amp;R = 120 dB. Interior discoteca = 110 dB mas de 120 dB Dolor Avi\u00f3n despegando a 25 metros. Petardo a un metro <p></p> <p>Una equivalencia que nos puede ayudar a familiarizarnos con esta unidad es la tabla de equivalencias entre potencias y dBm (decibelios milivatio):</p> <p> P (mW) dBm P (mW) dBm P (mW) dBm P (mW) dBm 1 0 16 12 250 24 4 W 36 1.3 1 20 13 315 25 5 W 37 1.6 2 25 14 400 26 6 W 38 2 3 32 15 500 27 8 W 39 2.5 4 40 16 630 28 10 W 40 3.2 5 50 17 800 29 13 W 41 4 6 64 18  1 W 30 16 W 42 5 7 80 19 1.3 W 31 20 W 43 6 8 100 20 1.6 W 32 25 W 44 8 9 125 21 2 W 33 32 W 45 10 10 158 22 2.5 W 34 40 W 46 13 11 200 23 3 W 35 50 W 47 <p> </p> <p>Si observamos cuidadosamente la tabla veremos que la potencia se duplica o divide por dos, seg\u00fan recorramos la tabla, cada 3 dB.</p> <p>Volver </p> <p>Zumbador pasivo</p> <p>Un zumbador o buzzer pasivo no es mas que un peque\u00f1o altavoz que nos sirve para convertir una se\u00f1al el\u00e9ctrica en una onda de sonido. Son dispositivos que no disponen de ning\u00fan tipo de electr\u00f3nica interna, por lo que tenemos que proporcionar una se\u00f1al el\u00e9ctrica para conseguir el sonido deseado.</p> <p>Normalmente estos dispositivos se incluyen en un m\u00f3dulo que incorpora un transistor y una resistencia de polarizaci\u00f3n del mismo para hacer funcionar al altavoz que act\u00faa como carga.</p> <p>Un buzzer se basa en un transductor piezoel\u00e9ctrico que es capaz de variar su volumen con el paso de la corriente el\u00e9ctrica, fen\u00f3meno que se aprovecha para hacer vibrar la membrana del altavoz. Esquem\u00e1ticamente vemos esto en la figura siguiente:</p> <p> <p> Funcionamiento y aspecto de un buzzer pasivo</p> <p></p> <p>Un zumbador pasivo requiere para su funcionamiento una se\u00f1al de tipo PWM para poder indicarle la frecuencia y la duraci\u00f3n de la se\u00f1al.</p> <p>El aspecto por ambos lados nos ayudar\u00e1 a distinguirlo del activo.</p> <p> <p> Aspecto de un buzzer pasivo</p> <p></p> <p>Volver </p> <p>Zumbador activo</p> <p>Este tipo de zumbador incluye un oscilador que genera una frecuencia audible fija y que se conoce como zumbador pasivo y en realidad es el que de forma correcta se puede denominar como zumbador. Este es mucho mas sencillo de usar ya que basta con conectarlo a un pin digital y cuando pongamos a nivel alto este pin el zumbador generar\u00e1 su zumbido caracter\u00edstico durante el tiempo que establezcamos. Con este tipo de zumbador no se pueden generar melod\u00edas.</p> <p>Cuando est\u00e1 nuevo se distingue del zumbador pasivo o altavoz por la pegatina de protecci\u00f3n que lo acompa\u00f1a, pero esta hay que quitarla para oir el zumbido y sin ella es dif\u00edcil distinguir un tipo del otro, salvo por su reverso. Es aconsejable marcar alguno de los dos cuando podemos distinguirlos, sobre todo si van a ir montados sobre una PCB. Una buena idea puede ser utilizar la propia pegatina en el lateral del mismo para distinguirlo a primera vista.</p> <p>Un zumbador activo produce un tono audible fijo con tan solo aplicarle tensi\u00f3n.</p> <p>El aspecto por ambos lados nos ayudar\u00e1 a distinguirlo del pasivo.</p> <p> <p> Aspecto de un buzzer activo</p> <p></p> <p>Volver </p> <p>M\u00f3dulo amplificador</p> <p>Existen m\u00f3dulos compuestos por un peque\u00f1o altavoz junto con su amplificador. El m\u00f3dulo amplificador KS0374 de keyestudio integra un potenci\u00f3metro para ajuste del volumen, un altavoz y el amplificador de audio 8002B. El chip es un amplificador de 2W clase AB capaz de entregar los 2W de potencia a una carga de tres ohmios con una distorsi\u00f3n menor al 10% a partir de una alimentaci\u00f3n de 5V. T\u00edpicamente el amplificador entrega en torno a los 2W para una carga de ocho ohmios.</p> <p>Lo mas apropiado es ajustar el volumen del sonido al m\u00ednimo antes de usarlo, para luego aumentarlo a voluntad, evitando as\u00ed sobresalto y que se estropee el altavoz.</p> <p>Sus par\u00e1metros principales son:</p> <ul> <li>Chip amplificador: SC8002B</li> <li>Tensi\u00f3n de alimentaci\u00f3n: 5V DC</li> <li>Consumo: \u2265500MA</li> <li>Potencia m\u00e1xima: 2W</li> <li>Temperatura de funcionamiento: de 0 a 40\u00b0</li> <li>Volumen de sonido del altavoz: 80db</li> </ul> <p> <p> Aspecto del m\u00f3dulo KS0374</p> <p></p> <p>Se puede observar que el altavoz es de membrana y bobina m\u00f3vil por lo que es algo similar a lo que vemos en la figura siguiente:</p> <p> <p> Altavoz de bobina m\u00f3vil</p> <p></p> <p>Volver </p> <p>Auriculares</p> <p>Existen de muchos tipos, formas y aplicaciones. Veamos un breve resumen de los mismos:</p> <ul> <li>Circumaurales. Seguramente los mejores de todos en cuanto a calidad de sonido. Se conocen tambi\u00e9n por auriculares HiFi. Son caros.</li> <li>Supraurales. Se suelen conocer como port\u00e1tiles. Centra el apoyo en la oreja lo que los hace algo incomodos. Buena calidad de sonido. Suelen ser plegables.</li> <li>Mini supra. Pueden ser tipo diadema o con enganche para la oreja. Peor calidad de sonido que los anteriores. Suelen usarse cuando tenemos que estar en movimiento.</li> <li>Intra aurales. Se introducen en el conducto auditivo al estilo de los audifonos, lo que aisla muy bien del sonido exterior. Son de \u00faltima generaci\u00f3n y dan una calidad de sonido muy buena. Suelen seer inal\u00e1mbricos.</li> <li>De bot\u00f3n. Parecidos a los intra aurales pero sin entrar en el conducto auditivo, solo en la oreja. Son los que peor calidad de sonido ofrecen dado que no aislan nada del exterior.</li> </ul> <p> <p> Auriculares</p> <p></p> <p>Volver </p> <p>Sonido micro:bit V1</p> <p>Las versiones anteriores a V2 de micro:bit no llevan altavoz de ning\u00fan tipo, por lo que reproducir sonido con las mismas va a requerir del uso de alg\u00fan elemento externo como auriculares o buzzer. Las opciones que vamos a ver de reproducir sonidos en versiones V1 es, logicamente, aplicable a placas V2.</p> <p>Quiz\u00e1 la opci\u00f3n mas simple para crear sonidos en micro:bit sea utilizar unos auriculares y un par de pinzas de cocodrilo para conectarlos al borde de la placa. En el enlace Primeros pasos. Salida de sonido tenemos un par de videos introductorios que se pueden subtitular en espa\u00f1ol y tres grupos de ejemplos, algunos de los que vamos a repasar a continuaci\u00f3n o en el apartado de la versi\u00f3n V2.</p> <p>El esquema de montaje que vamos a realizar para estos proyectos es el siguiente:</p> <p> <p> Conexi\u00f3n de unos auriculares</p> <p></p> <p> <p>Ejemplo 1. Melodia</p> <p></p> <p>Sin entrar en mas detalles sobre la descripci\u00f3n de los bloques, simplemente dejamos la melodia por defecto del bloque y ya podemos reproducirla tanto en el simulador, conectando el sonido multimedia de nuestro ordenador para escucharla o haciendo el montaje y descargando el programa en la placa.</p> <p>El programa es:</p> <p> <p> Ejemplo 1. Melodia</p> <p></p> <p>En las actividades se desarrollan ejemplos con otros elementos de reproducci\u00f3n del sonido.</p> <p>Volver </p> <p>Sonido micro:bit V2</p> <p>Si montamos el ejemplo 1 anterior en una micro:bit V2 va a funcionar exactamente igual que antes. La diferencia est\u00e1 en que se puede silenciar el altavoz y el sonido seguir\u00e1 saliendo en los pines para escucharlo en auriculares. En MakeCode, utilizamos el bloque de m\u00fasica \"apagar altavoz interno\". Si configuramos el bloque en \"DESACTIVADO\" el sonido solamente sale por los auriculares y si lo configuramos como \"ACTIVADO\" sale por ambos sitios. La diferencia no se puede apreciar en el simulador, hay que hacer el montaje externo.</p> <p>El programa ahora es:</p> <p> <p> Ejemplo 1. Melodia V2</p> <p></p> <p>Antes de ver mas explicaciones hagamos un ejemplo para probar.</p> <p> <p> Ejemplo 2. Emociones</p> <p></p> <p>El esquema del circuito del altavoz lo vemos en la figura siguiente:</p> <p> <p> Esquema circuito altavoz</p> <p>Obtenido de</p> <p></p> <p>Vemos que b\u00e1sicamente est\u00e1 compuesto por un transistor BSS816NW, que es un MOSFET de canal N, de 20V V_{DS} y 1.4A de I_D en encapsulado SOT23. El MLT-8530 es un buzzer electro magn\u00e9tico de 3.6V que trabaja a una frecuencia de 2700 Hz y es capaz de entregar 80 dB @ 5V a 10 cm con una corriente m\u00e1xima de 95 mA. El diodo de conmutaci\u00f3n r\u00e1pida BAS16LD evita que la alimentaci\u00f3n positiva llegue al buzzer y provoque un zumbido continuado.</p>"},{"location":"conceptos/ohm/","title":"Ley de Ohm","text":"<p>Es una ley que publica el f\u00edsico alem\u00e1n Georg Sim\u00f3n Ohm en 1827. Su descubrimiento consisti\u00f3 en ver que una corriente electrica (I) que circula a trav\u00e9s de un conductor es proporcional a la diferencia de potencial (V) entre los extremos del conductor e inversamente proporcional a la resistencia el\u00e9ctrica (R) del mismo. La ley de Ohm establece esta relaci\u00f3n:</p> <p> <p>I = \\dfrac {V}{R} \\space;\\space R = \\dfrac {V}{I} \\space;\\space V = I \\cdot R</p> <p></p> <p> <p> Circuito base de la ley de Ohm</p> <p></p>"},{"location":"conceptos/ohm/#unidades","title":"Unidades","text":"<p>La ley de Ohm relaciona tres magnitudes el\u00e9ctricas que se denominan, representan habitualmente y su unidad fundamental de medida es:</p> <ul> <li>Voltaje o tensi\u00f3n, se representa por la letra V y a veces por la U y se mide en voltios, que se representan por V.</li> <li>Intensidad de corriente, se representa por la letra I y se mide en Amperios que se representan por A.</li> <li> <p>Resistencia el\u00e9ctrica, se representa por la letra R y se mide en Ohmios que se representan por \\Omega o por facilidad de escritura con una R, o incluso se omite para valores bajos de resistencia.</p> </li> <li> <p>La unidad de corriente (I) es el amperio (A). En electr\u00f3nica las corrientes de amperios no son muy usuales y se suelen usar los subm\u00faltiplos de, as\u00ed que 1A = 1000mA (miliamprerios) y 1A = 1000000\u03bcA (microamperios) o lo que es lo mismo, 1mA = 1000\u03bcA.</p> </li> <li> <p>La unidad de tensi\u00f3n (V) es el voltio. Otras unidades habituales son 1kV (kilovoltio) = 1000V, 1V = 1000 mV (milivoltio), 1mV = 1000\u03bcV (microvoltio).</p> </li> <li> <p>La unidad de resistencia es el ohmios (\\Omega que, por facilidad, se suele sustituir por R). 1K \\Omega (kilohmio) = 1K = 1000R, 1M \\Omega (megaohmio) = 1000K = 1000000R.</p> </li> </ul>"},{"location":"conceptos/ohm/#ecuaciones-de-la-ley-de-ohm","title":"Ecuaciones de la ley de Ohm","text":"<p>Una forma cl\u00e1sica de representar la ley de Ohm es mediante un tri\u00e1ngulo equilatero dividido en tres partes (ver imagen siguiente) donde la divisi\u00f3n horizontal interior representa la l\u00ednea de fracci\u00f3n y la vertical la multiplicaci\u00f3n. De esta forma es f\u00e1cil recordarla.</p> <p> <p> Tri\u00e1ngulo nmem\u00f3nico de la ley de Ohm</p> <p></p> <p>Tapando la unidad que buscamos aparece la relaci\u00f3n entre las otras dos.</p> <p>Otro diagrama que muestra la forma en que se relacionan las magnitudes que intervienen en la ley de Ohm es:</p> <p> <p> Diagrama circular de la ley de Ohm</p> <p></p>"},{"location":"conceptos/ohm/#circuito","title":"Circuito","text":"<p>Para que la corriente circule es necesario un circuito o lazo cerrado formado por componentes electr\u00f3nicos. En la figura siguiente, a la izquierda vemos representado un circuito de bucle cerrado, por lo que la corriente circula a trav\u00e9s del mismo. A la derecha vemos un circuito abierto por el que no circula corriente.</p> <p> <p> Tri\u00e1ngulo nmem\u00f3nico de la ley de Ohm</p> <p></p>"},{"location":"conceptos/ohm/#resistencias-pull-up-y-pull-down","title":"Resistencias pull-up y pull-down","text":"<p>Cuando necesitamos conectar ciertos elementos a alg\u00fan pin de entrada, como por ejemplo un pulsador externo, no se puede hacer directamente porque cuando se acciona el pulsador se crea un cortocircuito en la alimentaci\u00f3n que puede incluso da\u00f1ar de manera irreversible nuestro dispositivo.</p> <p>Lo que se hace es colocar un resistencia de alto valor (4K7 a 10K) entre Vcc y GND en serie con el pulsador y tomar la se\u00f1al de salida de la uni\u00f3n de ambos elementos. Seg\u00fan situ\u00e9mos el pulsador y la resistencia tendremos uno u otro caso.</p> <p> <p> Pull-up y pull-down externos</p> <p></p> <p>Hay algunos pines que tienen la posibilidad de habilitar su propia resistencia que ya llevan incorporada habl\u00e1ndose entonces de pull-up o pull-down interno.</p>"},{"location":"conceptos/serie/","title":"Las comunicaciones serie","text":"<p>La comunicaci\u00f3n serie o serial communication son comunicaciones bidireccionales a trav\u00e9s de la UART integrada en el microcontrolador. Es importante tener siempre presente que el puerto serie es el que se utiliza para \"subir\" el firmware o programa a la placa.</p> <p>Una UART (Universal Asynchronous Receiver / Transmitter) es un circuito integrado que se encarga de gestionar las comunicaciones a trav\u00e9s de un puerto serie en un equipo. Las placas micro:bit integran su propia UART. En micro:bit, el m\u00f3dulo UART nos permite comunicarnos con un dispositivo conectado a la placa mediante una interfaz serie a trav\u00e9s del puerto serie USB. En los tres programas que estamos manejando son tratadas las comunicaciones serie y es lo que vamos a describir a continuaci\u00f3n.</p> <p>Para ver los datos serie en el ordenador puede que necesitemos lo que se conoce como terminal serie, que no es otra cosa que un programa para visualizar estas comunicaciones.</p> <p>Dependiendo del sistema operativo con el que estemos trabajando el uso de las comunicaciones serie requieren un poco de configuraci\u00f3n. En nuestro caso vamos a ver dos formas de hacerlo pero siempre bajo sistema operativo Linux, en concreto Ubuntu 22.04 LTS.</p>"},{"location":"conceptos/serie/#instalar-putty-en-ubuntu-2204-lts","title":"Instalar PuTTY en Ubuntu 22.04 LTS","text":"<p>PuTTY est\u00e1 disponible para varias distribuciones Linux y vamos a ver la forma de instalarlo desde una terminal de Ubuntu. Como en todas las instalaciones es buena costumbre actualizar la lista de paquetes antes de proceder a instalar el software desde el respositorio por defecto.</p> <pre><code>sudo apt update\n</code></pre> <p> <p> Actualizar lista de paquetes</p> <p></p> <p>Tambi\u00e9n podemos comprobar que versi\u00f3n de PuTTY est\u00e1 disponible:</p> <pre><code>apt show putty\n</code></pre> <p> <p> Comprobaci\u00f3n de la versi\u00f3n disponible de PuTTY</p> <p></p> <p>En el momento de la captura la versi\u00f3n disponible es la 0.76-2</p> <p>Ya podemos instalar PuTTY haciendo:</p> <pre><code>sudo apt install putty -y\n</code></pre> <p>Tras instalar comprobamos la versi\u00f3n haciendo:</p> <pre><code>putty --version\n</code></pre> <p> <p> Comprobaci\u00f3n de la versi\u00f3n de PuTTY</p> <p></p> <p>Invocamos a la aplicaci\u00f3n desde la terminal:</p> <p> <p> Ejecuci\u00f3n de PuTTY</p> <p></p> <p>La GUI (Interfaz gr\u00e1fica) de PuTTY se inicializar\u00e1 y se puede utilizar para conectarse a otras m\u00e1quinas escribiendo el nombre de host o la direcci\u00f3n IP:</p> <p> <p> GUI de PuTTY</p> <p></p> <p>Si por alg\u00fan motivo tenemos que desintalar PuTTY de nuestro sistema hacemos:</p> <pre><code>sudo apt purge putty -y\n</code></pre> <p>Y PuTTY se elimina de Ubuntu junto con sus ficheros de configuraci\u00f3n.</p>"},{"location":"conceptos/serie/#instalar-screen-en-ubuntu-2204-lts","title":"Instalar screen en Ubuntu 22.04 LTS","text":"<p>Es otro sencillo programa para trabajar con datos serie. Para instalarlo en el sistema:</p> <pre><code>sudo apt install screen\n</code></pre> <p> <p> Intalar screen</p> <p></p> <p>Con nuestra placa conectada a un puerto USB del ordenador tenemos que encontrar el nodo asignado a la micro:bit mediante:</p> <pre><code>ls /dev/ttyACM*\n</code></pre> <p>Habitualmente ser\u00e1 /dev/ttyACM0</p> <p> <p> Nombre asignado a micro:bit</p> <p></p> <p>La opci\u00f3n mas conveniente para ejecutar screen es como root, por lo que lo invocamos haciendo:</p> <pre><code>sudo screen /dev/ttyACM0 115200\n</code></pre> <p>La terminal del sistema pasa a una terminal serie lista para recibir datos desde la micro:bit.</p> <p>Para volver a la terminal del sistema hay que pulsar la secuencia de teclas Ctrl-A Ctrl-D.</p>"},{"location":"conceptos/serie/#makecode","title":"MakeCode","text":"<p>El men\u00fa de bloques serial soporta la comunicaci\u00f3n serial entre la BBC micro:bit y el ordenador. B\u00e1sicamente, estos bloques permiten enviar datos desde la micro:bit al ordenador, lo que resulta muy \u00fatil para depuraci\u00f3n ya que podemos a\u00f1adir aclaraciones en el c\u00f3digo que podemos ver en el ordenador mientras el programa se ejecuta.</p> <p>El c\u00f3digo de abajo muestra un simple script que env\u00eda una l\u00ednea cuando la BBC micro:bit arranca y otra l\u00ednea cada vez que se pulsa el bot\u00f3n A.</p> <p> <p> Comunicaci\u00f3n serie base</p> <p></p> <p>Los datos tambi\u00e9n se transmiten autom\u00e1ticamente via serie por el bloque \"gr\u00e1fico de barras\" y son recogidos por el editor. Estos datos tambi\u00e9n pueden transmitirse a la nube.</p> <p>Vamos a comprobar el funcionamiento de la transmisi\u00f3n serie en PuTTY y para ello debemos asegurarnos que el puerto USB asignado a la micro:bit no est\u00e1 siendo utilizado por ning\u00fan otro programa. Una vez estemos seguros que el puerto est\u00e1 libre invocamos PuTTY desde una terminal y configuramos la conexi\u00f3n serie as\u00ed:</p> <p> <p> Comunicaci\u00f3n serie micro:bit - PuTTY</p> <p></p> <p>Despu\u00e9s de hacer clic en el bot\u00f3n \"Open\" se nos abre una terminal serie lista para recibir datos y si pulsamos el bot\u00f3n A varias veces obtendremos un resultado como el siguiente:</p> <p> <p> Terminal de comunicaci\u00f3n serie micro:bit - PuTTY</p> <p></p> <p>Hacemos lo mismo con la aplicaci\u00f3n screen:</p> <p> <p> Comunicaci\u00f3n serie micro:bit - screen</p> <p></p> <p>Al pulsar la tecla \"entrar\" en la ventana anterior se muestra la terminal de screen y tras pulsar varias veces el bot\u00f3n tenemos:</p> <p> <p> Terminal de comunicaci\u00f3n serie micro:bit - screen</p> <p></p> <p>Podemos observar que, aunque muy similares, las terminales serie de ambos programas son diferentes.</p>"},{"location":"conceptos/serie/#micropython-uart","title":"MicroPython. UART","text":"<p>En MicroPython es el m\u00f3dulo uart el que permite comunicarse a trav\u00e9s de la interfaz serie entre la micro:bit y el ordenador. El m\u00f3dulo tiene diferentes funciones encomendadas a realizar diferentes tareas de comunicaci\u00f3n serie, pero sobre todo hay una fundamental que es la de inicializar la micro:bit para trabajar.</p> <pre><code>microbit.uart.init(baudrate=9600, bits=8, parity=None, stop=1, *, tx=None, rx=None)\n</code></pre> <p>Inicializa la comunicaci\u00f3n serie con los par\u00e1metros especificados en los pines Tx y Rx especificados. Hay que tener en cuenta que, para que la comunicaci\u00f3n sea correcta, los par\u00e1metros deben ser los mismos en los dispositovos que se comunican. En la funci\u00f3n tenemos:</p> <ul> <li>baudrate. Define la velocidad de la comunicaci\u00f3n en baudios y puede ser: 9600, 14400, 19200 (2x9600), 28800 (14400x2), 38400 (2x19200), 57600 (28800x2) o 115200 (57600x2).</li> <li>bits. El par\u00e1metro bits define el tama\u00f1o de los bytes que se transmiten. Micro:bit solamente soporta 8 bits.</li> <li>parity. El par\u00e1metro paridad define la forma de comprobaci\u00f3n de la paridad pudiendo valer: <code>none</code>, <code>microbit.uart.ODD</code> o <code>microbit.uart.EVEN</code>, lo que indica: ninguna, impar o par respectivamente. La paridad es una forma de comprobar que el dato transmisitido y el recibido coinciden.</li> <li>stop. Este par\u00e1metro indica el n\u00famero de bits de parada, que en el caso de la micro:bit es uno.</li> <li>Tx y Rx. Son los pines de transmisi\u00f3n (Tx) y recepci\u00f3n (Rx) de la placa. Si no se especifican se utilizan los internos de USB/UART. Se puede especificar cualquier otro pin.</li> </ul> <p>Notas:</p> <ol> <li>Inicializar la UART en pines diferentes a los establecidos por defecto para USB puede originar que la consola de Python deje de ser accesible, ya que utiliza el mismo hardware. Para recuperar la consola hay que reinicializar la UART sin pasar nada por Tx o Rx (o pasando None a estos argumentos). Es decir, llamar a <code>uart.init(115200)</code> es suficiente para restaurar la consola Python.</li> <li>Las conexiones de dispositivos mediante Tx y Rx requieren \"cruzar\" los cables, de forma que el pin TX de la placa est\u00e9 conectado al Rx del otro dispositivo y el pin Rx, con el pin Tx. De esta forma lo que uno transmite el otro lo escucha. Tambi\u00e9n es imprescindible que los dispositivos tengan un GND com\u00fan.</li> </ol> <p>El ejemplo siguiente nos va a permitir comprobar la comunicaci\u00f3n serie desde MicroPython. Grabamos el programa en la micro:bit.</p> <pre><code>from microbit import *\n\nuart.init(115200,8,None,1)\nwhile True:\n    if button_a.was_pressed():\n        #\"\\n\" indica un salto de linea\n        #\\r\" indica un retorno de carro\n        #Con los dos se salta una linea y se lleva\n        #el curso al principio\n        uart.write(\"Python: Boton A pulsado\\n\\r\")\n</code></pre> <p>Abrimos y configuramos PuTTY y la consola nos muestra:</p> <p> <p> Terminal de comunicaci\u00f3n serie micro:bit - PuTTY</p> <p></p> <p>A continuaci\u00f3n vemos el resultado en la consola de screen.</p> <p> <p> Terminal de comunicaci\u00f3n serie micro:bit - screen</p> <p></p>"},{"location":"conceptos/serie/#acceso-a-repl","title":"Acceso a REPL","text":"<p>REPL son iniciales de Read-Evaluate-Print-Loop y es lo que permite a la micro:bit leer y evaluar c\u00f3digo en tiempo real mientras lo escribimos.</p>"},{"location":"conceptos/serie/#editor-web-micropython","title":"Editor web MicroPython","text":"<p>Aunque no se ha explicado hasta este momento, el editor Python basado en navegador que venimos utilizando tiene soporte REPL integrado, al que se puede acceder usando WebUSB. Para utilizar el REPL tenemos que:</p> <ul> <li>Flashear un programa Python en micro:bit, el mismo que antes nos vale.</li> <li>Seleccionar Show Serial para abrir la ventana REPL. Est\u00e1 debajo del simulador.</li> <li>Usaremos la combinaci\u00f3n CTRL-C del teclado para REPL.</li> <li>Usaremos la combinaci\u00f3n CTRL + C del teclado para reiniciar.</li> </ul> <p>En la animaci\u00f3n siguiente vemos el funcionamiento.</p> <p> <p> Terminal de comunicaci\u00f3n REPL micro:bit - editor web</p> <p></p> <p>L\u00f3gicamente la micro:bit tiene el programa grabado y est\u00e1 conectada al ordenador. En caso contrario se generar\u00e1 un error como:</p> <p> <p> Error terminal de comunicaci\u00f3n REPL micro:bit - editor web</p> <p></p>"},{"location":"conceptos/serie/#editor-mu","title":"Editor Mu","text":"<p>El editor Mu es compatible con REPL e incluso incluye un plotter de datos en tiempo real.</p> <p>Como con el resto de programas lo mas conveniente es desconectar y conectar la micro:bit antes de hacer ninguna otra cosa para que el puerto serie USB quede disponible. Con una placa conectada iniciamos Mu y veremos lo siguiente:</p> <p> <p> Ventana del IDE de Mu con una micro:bit conectada</p> <p></p> <p>La selecci\u00f3n de la placa se realiza desde el icono \"Modo\".</p> <p> <p> Modo</p> <p></p> <p>Escribimos nuestro programa, que ahora va a ser:</p> <pre><code>from microbit import *\n\nuart.init(115200, 8, None, 1)\nwhile True:\n    if button_a.was_pressed():\n        uart.write(\"Mu Editor: Boton A pulsado\\n\\r\")\n</code></pre> <p> <p> Programa en Mu para prueba serial</p> <p></p> <p>Flasheamos nuestro programa en la micro:bit haciendo clic en el icono \"Flash\" y abrimos REPL y una vez abierto reseteamos la micro:bit para asegurar la conexi\u00f3n. Ya est\u00e1 lista la terminal para recibir datos, como vemos en la animaci\u00f3n.</p> <p> <p> REPL en Mu</p> <p></p>"},{"location":"conceptos/signals/","title":"Conceptos t\u00e9cnicos","text":"<p>Secci\u00f3n dedicada al estudio inicial de las se\u00f1ales en este tipo de electr\u00f3nica y algunas formas de trabajar con las mismas.</p>"},{"location":"conceptos/signals/#senales-digitales-y-analogicas","title":"Se\u00f1ales digitales y anal\u00f3gicas","text":"<p>Vamos a ver una muy breve introducci\u00f3n a los circuitos digitales y anal\u00f3gicos que nos permita distinguir unos de otros y como tratar sus se\u00f1ales.</p> <p>Una se\u00f1al digital es una se\u00f1al discreta en el tiempo y por tanto est\u00e1 formada por una secuencia de cantidades. Una se\u00f1al digital puede cambiar instantaneamente su valor, como por ejemplo el estado de un pulsador, que puede estar accionado o no. En la pr\u00e1ctica son se\u00f1ales que se denominan cuadradas, por su forma.</p> <p>La electr\u00f3nica digital utiliza magnitudes con dos valores discretos conocidos como '0 - 1, alto - bajo, on - off, High - Low', etc, y que se corresponden con la presencia o no de tensi\u00f3n en un determinado punto. Estos valores discretos pueden sufrir peque\u00f1as variaciones en alguna variable del circuito pero, si no cambia el valor discreto no se produce ning\u00fan cambio en el comportamiento del circuito por lo que podemos decir que este no depende del valor exacto de la se\u00f1al. En la figura siguiente vemos una se\u00f1al digital t\u00edpica.</p> <p> <p> Se\u00f1al digital</p> <p></p> <p>Una se\u00f1al anal\u00f3gica es una se\u00f1al que cambia de valor con el tiempo de manera continuada. En la vida real la mayor\u00eda de las se\u00f1ales son anal\u00f3gicas, como por ejemplo la temperatura, que a lo largo de un d\u00eda est\u00e1 cambiando continuamente pero en valores discretos y no con cambios importantes. En la pr\u00e1ctica son ondas que varian en funci\u00f3n del tiempo.</p> <p>La electr\u00f3nica anal\u00f3gica por contra emplea magnitudes con valores continuos o variables continuas. Una peque\u00f1a variaci\u00f3n en una variable puede producir un gran cambio en el comportamiento del circuito. En la imagen vemos un ejemplo de se\u00f1al anal\u00f3gica simple.</p> <p> <p> Se\u00f1al anal\u00f3gica</p> <p></p> <p>En las placas micro:bit disponemos de 25 conectores situados en el borde inferior. En general diremos que los pines son de tipo GPIO o pines de entrada/salida de prop\u00f3sito general. Algunos pines son para E/S serie, SPI e I2C</p> <p>Un pin GPIO (General Purpose Input/Output, Entrada/Salida de Prop\u00f3sito General) es un pin gen\u00e9rico, cuyo comportamiento (incluyendo si es un pin de entrada o de salida) se puede programar por el usuario en tiempo de ejecuci\u00f3n. En el apartado de informaci\u00f3n t\u00e9cnica siguiente se profundiza en que es cada pin.</p>"},{"location":"conceptos/signals/#pwm","title":"PWM","text":"<p>PWM son siglas en ingl\u00e9s que significan Pulse Width Modulation, que lo podemos traducir a espa\u00f1ol como modulaci\u00f3n de ancho de pulso. Los pines PWM permiten generar una se\u00f1al anal\u00f3gica mediante una salida digital mapeada con 8 bits, o lo que es lo mismo, valores del 0 al 255, es decir mediante una salida PWM podemos emular una se\u00f1al anal\u00f3gica.</p> <p>En realidad una placa microcontrolada no es capaz de generar una salida anal\u00f3gica y lo que se hace es emplear un truco que consiste en activar una salida digital durante un tiempo y el resto del tiempo del ciclo mantenerla desactivada. El valor promedio de la salida es el valor anal\u00f3gico. En el tipo de modulaci\u00f3n PWM mantendremos constante la frecuencia, o lo que es lo mismo, el tiempo entre pulsos y lo que se hace es variar la anchura del pulso.</p> <p>La proporci\u00f3n de tiempo que est\u00e1 encendida la se\u00f1al, respecto al total del ciclo, se denomina ciclo de trabajo o Duty cycle, y generalmente se expresa en tanto por ciento. En la imagen siguiente vemos se\u00f1ales con distintos ciclos de trabajo.</p> <p> <p> Distintos Duty cicle</p> <p></p> <p>Las se\u00f1ales PWM emulan una se\u00f1al anal\u00f3gica para aplicaciones como variar la luminosidad de un LED y variar la velocidad de motores de corriente continua.</p> <p>Por limitaciones impuestas por la circuiter\u00eda de micro:bit solamente pueden coexistir tres pines PWM de manera simultanea. Si intentamos habilitar un cuarto pin PWM se desabilitar\u00e1 alg\u00fan otro pin PWM.</p>"},{"location":"conceptos/signals/#el-bus-i2c","title":"El bus I2C","text":"<p>Las siglas I2C corresponden en realidad a I\u00b2C que tiene su origen en las iniciales del ingl\u00e9s Inter-Integrated Circuit (IIC = I\u00b2C) y que siginifican Circuito Inter-Integrado y vamos a explicar un poco en que consiste este sistema de conexionado.</p> <p>El bus conocido por las siglas I2C, IIC o I\u00b2C, es un bus serie de datos desarrollado en 1982 por Philips Semiconductors (hoy NXP Semiconductors, parte de Qualcomm). Se utiliza principalmente internamente para la comunicaci\u00f3n entre diferentes partes de un circuito, por ejemplo, entre un controlador y circuitos perif\u00e9ricos integrados. Posteriormente fue adoptado progresivamente por otros fabricantes hasta convertirse en un est\u00e1ndar del mercado con miles de circuitos integrados de diferentes fabricantes.</p> <p>I2C tambi\u00e9n se denomina TWI (Two Wired Interface) \u00fanicamente por motivos de licencia, denominaci\u00f3n introducida por Atmel. No obstante, la patente caduc\u00f3 en 2006, por lo que actualmente no hay restricci\u00f3n sobre el uso del t\u00e9rmino I2C.</p> <p>El bus I2C requiere \u00fanicamente dos cables o lineas de se\u00f1al para su funcionamiento, uno para la se\u00f1al de reloj (SCL, Serial Clock) y otro para el env\u00edo de datos (SDA, Serial Data). Ambas l\u00edneas precisan resistencias de pull-up hacia Vcc. Cualquier dispositivo conectado a estas l\u00edneas es de drenador o colector abierto (Open Collector), lo cual en combinaci\u00f3n con las resistencias pull-up, crea un circuito Wired-AND. En la imagen siguiente vemos el diagrama b\u00e1sico de conexionado del bus con algunos ejemplos de dispositivos. La se\u00f1al de reloj siempre es generada por el circuito que act\u00faa como Master.</p> <p> <p> Diagrama de conexi\u00f3n del bus I2C</p> <p></p> <p>Para ser reconocido en el bus, cada dispositivo dispone de una direcci\u00f3n f\u00edsica, que se emplea para acceder a cada uno de ellos de forma individual. Esta direcci\u00f3n puede ser fijada por hardware, en cuyo caso se pueden modificar los \u00faltimos 3 bits mediante \u201cjumpers\u201d o microinterruptores, o por software.</p> <p>En general, cada dispositivo conectado al bus debe tener una direcci\u00f3n \u00fanica. Si tenemos varios dispositivos similares tendremos que cambiar la direcci\u00f3n o, en caso de no ser posible, implementar un bus secundario.</p> <p>El bus I2C tiene una arquitectura de tipo master-slave, lo que indica que el master es el encargado de controlar al resto de dispositivos tipo slave con los que se comunica y que se comunican con el, teniendo siempre el master prioridad absoluta. El dispositivo master es el que inicia la comunicaci\u00f3n con los slaves. Los slaves no pueden iniciar la comunicaci\u00f3n (el master tiene que preguntarles), ni hablar entre si directamente.</p> <p>El bus I2C debe ser por lo tanto s\u00edncrono, es decir debe existir una se\u00f1al de reloj que controle las comunicaciones. Es el master el que proporciona la se\u00f1al de reloj, que mantiene sincronizados a todos los dispositivos del bus. De esta forma, se elimina la necesidad de que cada dispositivo tenga su propio reloj, de tener que acordar una velocidad de transmisi\u00f3n y mecanismos para mantener la transmisi\u00f3n sincronizada como en UART o SPI. En la imagen vemos un cronograma ejemplo del funcionamiento del sistema.</p> <p> <p> Cronograma de trabajo del bus I2C</p> <p></p> <p>El protocolo de comunicaci\u00f3n I2C sigue la siguiente secuencia:</p> <ul> <li>Primero, el master genera la se\u00f1al de reloj del bus (SCL).</li> <li>Se inicia la comunicaci\u00f3n por orden del master al establecer la condici\u00f3n de START, que se produce cuando SDA pasa de uno a cero y se mantiene en cero durante un tiempo.</li> <li>El master direcciona a los slaves.</li> <li>El master indica si se va a leer o escribir.</li> <li>El slave direccionado responde con una se\u00f1al de conformidad ACK (acknowledge).</li> <li>Se transmite los datos byte a byte desde SDA al receptor. Por cada pulso desde SCL se transmite un bit de informaci\u00f3n.</li> <li>El destinatario de la informaci\u00f3n responde con una se\u00f1al de conformidad ACK.</li> <li>Se acaba la comunicaci\u00f3n cuando el master establece la condici\u00f3n de STOP, que se produce cuando SDA, por orden del master pasa de cero a uno y se mantiene en uno durante un tiempo.</li> </ul> <p>Son muchos los dispositivos I2C que se pueden direccionar por este bus I2C, siendo lo m\u00e1s com\u00fan en los dispositivos para I2C que utilicen direcciones de 7 bits, aunque existen dispositivos de 10 bits, pero es un caso raro. Una direcci\u00f3n de 7 bits implica que se pueden poner hasta 128 (27) dispositivos sobre un bus I2C. Hemos visto que las direcciones son de 8 bits y esto es porque el bit extra de los 7 de la direcci\u00f3n lo emplea el master para informar al slave si va a leer o escribir. Si el bit de lectura/escritura es cero, el dispositivo master est\u00e1 escribiendo en el slave. Si el bit es 1 el master est\u00e1 leyendo desde el slave. La direcci\u00f3n de 7 bit se coloca en los 7 bits m\u00e1s significativos del byte y el bit de lectura/escritura es el bit menos significativo.</p>"},{"location":"conceptos/signals/#conversion-adc-y-dac","title":"Conversi\u00f3n ADC y DAC","text":"<p>En un sistema microcontrolado como el de micro:bit (y otros) existe la necesidad de poder trabajar con se\u00f1ales que no sean digitales, como lo son la mayor\u00eda de las variables que nos rodean, por lo tanto se hace necesario implementar una conversi\u00f3n de la informaci\u00f3n de entrada anal\u00f3gica a digital y el dispositivo se encargar\u00e1 tambi\u00e9n de convertir al contrario.</p> <ul> <li>La conversi\u00f3n anal\u00f3gica a digital la realiza el dispositivo ADC (Analog to Digital Converter)</li> <li>La conversi\u00f3n digital a anal\u00f3gica la realiza un dispositivo DAC (Digital to Analog Converter)</li> </ul> <p>Ya hemos visto anteriormente como una se\u00f1al anal\u00f3gica se representa mediante valores discretos y cambian continuamente con el tiempo mientras que una se\u00f1al digital se representa mediante valores discretos.</p> <p>Un conversor ADC se utiliza para convertir se\u00f1ales anal\u00f3gicas, como tensiones, en se\u00f1ales digitales o binarias formada por unos y ceros.</p> <p>El rango del m\u00f3dulo ADC que lleva la micro:bit es de 10 bits, lo que significa que su resoluci\u00f3n es de 2^{10}=1024 \\space bits, por lo que su rango (a 3,3V) se dividir\u00e1 en 1024 partes iguales.</p> <p>Cualquier valor anal\u00f3gico puede ser mapeado a un valor digital usando la resoluci\u00f3n del conversor. Por tanto, cuantos m\u00e1s bits tenga el ADC, de m\u00e1s precisi\u00f3n ser\u00e1 el muestreo del anal\u00f3gico y mayor la precisi\u00f3n de la conversi\u00f3n resultante. As\u00ed tenemos que:</p> <p> 0 \\space (digital) = \\dfrac{0 - 3.3}{1024} <p>1 \\space (digital) = {\\dfrac{3.3}{1024}-\\dfrac{2 \\times 3.3}{1024}} </p>"},{"location":"guias/consola/","title":"La consola serie","text":"<p>El terminal o consola serie sirve para visualizar en un ordenador los datos recibidos a trav\u00e9s del puerto serie y en realidad es una aplicaci\u00f3n que controla las comunicaciones bidireccionales a trav\u00e9s de la UART integrada en el microcontrolador. Tambi\u00e9n sirve para enviar datos desde la consola a la placa.</p> <p>Es muy importante tener siempre presente que el puerto serie es el que se utiliza para \"subir\" el firmware o programa a la placa, tarea que se realiza a trav\u00e9s de una aplicaci\u00f3n pregrabada en el microntrolador y que se denomina \"bootloader\".</p>"},{"location":"guias/consola/#uso-de-la-consola","title":"Uso de la consola","text":"<p>Para usar la consola serie hay que tener un dispositivo micro:bit conectado al ordenador, y usar un navegador que soporte WebUSB, como Chromium, Chrome o Edge. Conectamos y flasheamos en la micro:bit desde el bot\u00f3n \"Enviar a micro:bit\" y una vez completado el proceso, veremos aparecer una barra negra en la parte inferior del editor. </p> <p> <p> Acceso a la consola serie</p> <p></p> <p>Si hacemos clic en \"Mostrar consola serie\" accedemos a la misma, desplegandose una ventana bash o de terminal.</p> <p> <p> Consola serie</p> <p></p> <p>La consola serie permite inspeccionar la salida de texto de un programa a trav\u00e9s de la funci\u00f3n <code>print()</code>. Esto es particularmente \u00fatil para depuraci\u00f3n o para revisar c\u00f3mo el estado de un programa est\u00e1 cambiando con el tiempo. Tambi\u00e9n es posible enviar texto utilizando en el programa la funci\u00f3n <code>input()</code>.</p> <p>En la secci\u00f3n Referencia del men\u00fa del lateral izquierdo podemos encontrar el apartado \"Entrada y salida de texto\" donde se describe el uso del teclado y la pantalla del ordenador en programas de micro:bit. Probaremos los ejemplos que ah\u00ed se plantean mas adelante.</p> <p>Tambi\u00e9n puedes interrumpir y reiniciar el programa usando Ctrl+C y Ctrl+D, respectivamente.</p> <p>En la parte superior derecha de la consola hay una 'i' rodeada de un c\u00edrculo que nos muestra una ventana emergente donde aparece la siguiente informaci\u00f3n:</p> <pre><code>**Consola serie: sugerencias y consejos**\n</code></pre> <p>La terminal serie muestra errores y otros resultados del programa que se ejecuta en el micro:bit. Por defecto, muestra el error m\u00e1s reciente del programa; exp\u00e1ndelo para ver todos los resultados.</p> <p>El programa puede imprimir mensajes usando la funci\u00f3n <code>print</code>. Prueba a a\u00f1adir <code>print('micro:bit es incre\u00edble')</code> al programa.</p> <p>Utiliza el atajo de teclado <code>Ctrl + C</code> para interrumpir el programa. Despu\u00e9s podr\u00e1s escribir comandos de Python para que los ejecute MicroPython. Es una gran manera de experimentar con algo nuevo.</p> <p>Para reiniciar el programa, pulsa <code>Ctrl + D</code>.</p> <p>La consola serie tambi\u00e9n muestra la salida completa de los errores de ejecuci\u00f3n, lo que puede ser \u00fatil cuando se depura. En Python Editor: Troubleshooting errors encontramos mas detalles sobre errores.</p>"},{"location":"guias/consola/#ejemplo-de-escritura-en-la-consola","title":"Ejemplo de escritura en la consola","text":"<p>Un programa como el siguiente:</p> <pre><code>from microbit import *\n\nwhile True:\n    print(\"Nivel de luz: \")\n    print(display.read_light_level())\n    sleep(1000)\n</code></pre> <p>Nos imprime el nivel de luz actual una vez por segundo en la consola del ordenador, como vemos en la animaci\u00f3n siguiente:</p> <p> <p> Envio de datos a la consola serie</p> <p></p> <p>Podemos poner el texto y el dato en una misma l\u00ednea haciendo el programa as\u00ed:</p> <pre><code>from microbit import *\n\nwhile True:\n    print(\"Nivel de luz: \" + str(display.read_light_level()))\n    sleep(1000)\n</code></pre> <p>Para que la funci\u00f3n print sea consistente no podemos mezclar una cadena de texto con un dato entero, por ese motivo se convierte la lectura num\u00e9rica en una cadena con <code>str</code>.</p> <p>Existe mucha informaci\u00f3n en la web referente a la funci\u00f3n print() de Python que se puede consultar cuando resulte necesario. Aqu\u00ed daremos a continuaci\u00f3n unas breves nociones.</p>"},{"location":"guias/consola/#ejemplo-de-lectura-de-la-consola","title":"Ejemplo de lectura de la consola","text":"<p>Un programa como el siguiente:</p> <pre><code>from microbit import *\n\nwhile True:\n    nombre = input('Dime un nombre ')\n    print(\"Hola\", nombre)\n    sleep(1000)\n</code></pre> <p>Nos va a pedir en la consola un nombre cada segundo y cuando se lo escribamos y pulsemos la tecla Enter nos enviar\u00e1 un saludo tambi\u00e9n a la consola.</p> <p> <p> Recepci\u00f3n de datos desde la consola serie</p> <p></p>"},{"location":"guias/consola/#la-funcion-print","title":"La funci\u00f3n <code>print()</code>","text":"<p>Las pantallas, como la que incorpora la micro:bit, las LCDs o las OLED son dispositivos de salida que tienen mucha utilidad en la visualizaci\u00f3n de informaci\u00f3n.</p> <p>Python, ya desde su propio IDLE ya incorpora respuesta inmediata a cosas como por ejemplo indicar el valor de una variable con solo nombrarla e incluso puede realizar operaciones b\u00e1sicas con n\u00fameros o con variables.</p> <p>En los programas tenemos que utilizar la funci\u00f3n <code>print()</code> que nos permite mostrar texto en la pantalla, siendo este indicado como argumento de la funci\u00f3n que se puede indicar tanto entre comillas dobles como simples.</p> <p>Al final de cada <code>print()</code> Python a\u00f1ade de forma autom\u00e1tica un salto de l\u00ednea.</p> <p>La funci\u00f3n <code>print()</code> permite utilizar cadenas y n\u00fameros como argumentos, haciendo f\u00e1cil mezclar n\u00fameros con textos.</p> <p>Si necesitamos generar una l\u00ednea en blanco dejaremos el argumento de la funci\u00f3n vacio.</p> <p>Si queremos evitar en salto de l\u00ednea autom\u00e1tico al final de la funci\u00f3n tenemos que a\u00f1adir <code>end=\"\"</code>.</p> <p> <p> Algunos ejemplos en el IDLE</p> <p></p> <p>Si dentro de una frase necesitamos utilizar comillas no podemos usarlas directamente porque se produce un error de sintaxis (los lenguajes de programaci\u00f3n son 100% inflexivbles con estos errores) ya que Python entiende las comillas como que encierran una cadena y no pueden existir cadenas dentro de cadenas.</p> <p> <p> Cadena entrecomillada que genera error</p> <p></p> <p>Una primera soluci\u00f3n es alternas los tipos de comillas que conforman las cadenas total y parcial:</p> <p> <p> Cadena entrecomillada correcta</p> <p></p> <p>La segunda soluci\u00f3n para incluir comillas dentro de comillas, es escribir una contrabarra () antes de las comillas para que Python reconozca la comilla que le sigue como un car\u00e1cter y no como un delimitador de la cadena:</p> <p> <p> Cadena entrecomillada correcta</p> <p></p> <p>La funci\u00f3n <code>print()</code> muestra los argumentos separados por espacios, lo que nos permite crear frases como sucesi\u00f3n de argumentos, pero que nos genera espacios indebidos, como se ve a continuaci\u00f3n:</p> <p> <p> Cadena con espacios indebidos</p> <p></p> <p>Se puede solucionar de diversas maneras, pero en la actualidad se hace utilizando lo que se conoce como <code>f-Strings</code> (formatted String literals), que se traduce como formateo literal de cadenas. Crear una <code>f-String</code> es tan sencillo como agregar una letra f o F dentante de las comillas. Por ejemplo:</p> <pre><code>\"cadena noraml\"\nf\"cadena f-Strings\"\n</code></pre> <p>Cuando queremos mostrar el valor de una variable utilizando <code>f-Strings</code> debemos especificar dicha variable entre llaves. Si se utilizan varias variables todas deben ir entre llaves.</p> <p> <p> Cadena con espacios indebidos corregidos con <code>f-Strings</code></p> <p></p> <p>Veamos otro ejemplo con argumentos num\u00e9ricos:</p> <p> <p> Cadena con <code>f-Strings</code> y operaciones con argumentos</p> <p></p>"},{"location":"guias/consola/#la-funcion-input","title":"La funci\u00f3n <code>input()</code>","text":"<p>Una forma de que un programa reciba datos del exterior es introducirlos mediante un teclado. En los ejemplos siguientes utilizaremos el teclado para enviar datos a la micro:bit y los visualizaremos en la consola de MicroPython. Comencemos por el ejemplo visto de la lectura de la consola:</p> <p> <p> Ejemplo sencillo con <code>input()</code></p> <p></p> <p>Una cuesti\u00f3n de criterio en el ejemplo puede ser que la respuesta que escribimos aparezca justo detr\u00e1s del texto inicial para as\u00ed compactar mas todo. Tarea que se hace de forma similar a la de la funci\u00f3n <code>print()</code> y usar end=\"\" para evitar el salto de l\u00ednea.</p> <p> <p> Ejemplo sencillo con <code>input()</code> sin salto de l\u00ednea</p> <p></p> <p>Se puede observar la diferente posici\u00f3n del cursor se\u00f1alado en cada caso.</p> <p>El mismo efecto se puede conseguir aprovechando que la funci\u00f3n <code>input()</code> no realiza un salto de l\u00ednea cuando envia un argumento:</p> <p> <p> Ejemplo sencillo con <code>input()</code> sin salto de l\u00ednea</p> <p></p> <p>De forma predeterminada la funci\u00f3n <code>input()</code> convierte lo que introduzcamos en una cadena, aunque sean n\u00fameros y por lo tanto no es posible realizar operaciones de esa forma.</p> <p> <p> Ejemplo de c\u00e1culos con <code>input()</code> con error</p> <p></p> <p>Para que Python interprete la entrada como un n\u00famero, se debe utilizar la funci\u00f3n <code>int()</code> o <code>float()</code>, seg\u00fan necesitemos que sea entero o real:</p> <p> <p> Ejemplo de c\u00e1culos con <code>input()</code> sin error</p> <p></p> <p>Hay que recordar que al introducir una fracci\u00f3n de forma autom\u00e1tica el <code>int</code> introducido se cambia al tipo <code>float</code>.</p> <p>Podemos pensar en este momento que ser\u00eda \u00fatil usar <code>f-Strings</code>, pero hay que indicar que en MicroPython no est\u00e1n soportadas, tal y como se indica en Core language de la documentaci\u00f3n oficial de MicroPython</p> <p>La funci\u00f3n <code>input()</code> s\u00f3lo puede tener un argumento y no es posible utilizar <code>f-Strings</code>, pero podemos incorporar variables en el argumento concatenandolas:</p> <p> <p> Ejemplo de <code>input()</code> con variables como argumento</p> <p></p> <p>Si queremos utilizar n\u00fameros debemos convertir los datos en cadenas con <code>str</code>, para los c\u00e1lculos los datos en <code>int</code> o en <code>float</code> y la separaci\u00f3n entre argumentos se hace con la como (,):</p> <p> <p> Ejemplo de <code>input()</code> con c\u00e1lculos</p> <p></p>"},{"location":"guias/intro/","title":"Introducci\u00f3n a Python","text":""},{"location":"guias/intro/#que-es-python-y-de-donde-viene","title":"\u00bfQue es Python y de donde viene?","text":"<p>Una breve introducci\u00f3n a cosas de Python que nos pueden ayudar con la gu\u00eda de MicroPython. Al final se trata el asunto de los permisos en Linux, que aunque sea un poco \"off topic\" puede resultar \u00fatil.</p>"},{"location":"guias/intro/#creador-de-python","title":"Creador de Python","text":"<p>Python es un lenguaje de programaci\u00f3n interpretado (no hay que compilar los programas) cuya filosof\u00eda hace hincapi\u00e9 en una sintaxis que favorezca un c\u00f3digo legible.</p> <p>Python fue creado a finales de los ochenta, por el holand\u00e9s Guido van Rossum en el Centro para las Matem\u00e1ticas y la Inform\u00e1tica (CWI, Centrum Wiskunde &amp; Informatica), en los Pa\u00edses Bajos.</p> <p>El nombre del lenguaje proviene de la afici\u00f3n de su creador por los humoristas brit\u00e1nicos Monty Python y no de la serpiente del mismo nombre. Aunque se suele usar un s\u00edmbolo con una serpiente pit\u00f3n para representarlo, de ah\u00ed la normal confusi\u00f3n.</p> <p>Se trata de un lenguaje de programaci\u00f3n multiparadigma o que soporta m\u00e1s de un paradigma de programaci\u00f3n, representando un paradigma un enfoque particular o filosof\u00eda para la construcci\u00f3n del software. Python soporta:</p> <ul> <li>Orientaci\u00f3n a objetos. En la programaci\u00f3n orientada a objetos (OOP) los objetos manipulan los datos de entrada para la obtenci\u00f3n de datos de salida espec\u00edficos, donde cada objeto ofrece una funcionalidad especial. Los objetos permiten la agrupaci\u00f3n en librer\u00edas y usualmente permiten al usuario la creaci\u00f3n de sus propias librer\u00edas. Se basa en t\u00e9cnicas de herencia, cohesi\u00f3n, abstracci\u00f3n, polimorfismo, acoplamiento y encapsulamiento.</li> <li>Programaci\u00f3n imperativa. Es la forma natural de programar un ordenador, es el estilo de programaci\u00f3n que se utiliza en el ensamblador y el m\u00e1s cercano a la m\u00e1quina. Sigue la arquitectura arquitectura cl\u00e1sica de Von Newmann con una memoria donde se almacenan los datos y el programa y una unidad de control que ejecuta las instrucciones del programa, conocida c\u00f3mo contador del programa.</li> <li>Programaci\u00f3n funcional. Es un estilo de programaci\u00f3n cuyo m\u00e9todo b\u00e1sico de computaci\u00f3n es la aplicaci\u00f3n de funciones a sus argumentos.</li> </ul>"},{"location":"guias/intro/#filosofia-python","title":"Filosof\u00eda Python","text":"<p>Es muy parecida a la filosof\u00eda de Unix. El c\u00f3digo que sigue los principios de Python de legibilidad y transparencia se dice que es \"pythonic\". Por el contrario, el c\u00f3digo opaco u ofuscado es bautizado como \"unpythonic\". Los puntos que describen su filosofia son:</p> <ul> <li>Bello es mejor que feo.</li> <li>Expl\u00edcito es mejor que impl\u00edcito.</li> <li>Simple es mejor que complejo.</li> <li>Complejo es mejor que complicado.</li> <li>Plano es mejor que anidado.</li> <li>Disperso es mejor que denso.</li> <li>La legibilidad cuenta.</li> <li>Los casos especiales no son tan especiales como para quebrantar las reglas.</li> <li>Lo pr\u00e1ctico gana a lo puro.</li> <li>Los errores nunca deber\u00edan dejarse pasar silenciosamente.</li> <li>A menos que hayan sido silenciados expl\u00edcitamente.</li> <li>Frente a la ambig\u00fcedad, rechaza la tentaci\u00f3n de adivinar.</li> <li>Deber\u00eda haber una -y preferiblemente s\u00f3lo una- manera obvia de hacerlo.</li> <li>Aunque esa manera puede no ser obvia al principio a menos que usted sea holand\u00e9s (en clara referencia a su autor).</li> <li>Ahora es mejor que nunca.</li> <li>Aunque nunca es a menudo mejor que ya mismo.</li> <li>Si la implementaci\u00f3n es dif\u00edcil de explicar, es una mala idea.</li> <li>Si la implementaci\u00f3n es f\u00e1cil de explicar, puede que sea una buena idea.</li> <li>Los espacios de nombres (namespaces) son una gran idea \u00a1Hagamos m\u00e1s de esas cosas!</li> </ul> <p>El Zen de Python viene incorporado (en ingl\u00e9s) a partir de la versi\u00f3n 2.1.2 y podemos invocarlo con <code>import this</code> abriendo Python en una terminal en un sistema en el que lo tengamos instalado, l\u00f3gicamente.</p> <p> <p> Arrastrar y soltar un fragmento de c\u00f3digo</p> <p></p>"},{"location":"guias/intro/#tipos-de-permisos-en-linux","title":"Tipos de permisos en Linux","text":"<p>El comando CHMOD nos da la posibilidad de poder cambiar los permisos de los archivos y directorios combinando entre clases y tipos. Hay cuatro clases:</p> <ul> <li>Propietario (u). Creador del archivo o la carpeta</li> <li>Grupo (g). Usuarios que tendr\u00e1n acceso al archivo o carpeta</li> <li>Otros (o). Todos los usuarios</li> <li>Todos (a). Todos los tipos de usuario (propietario, grupo y otros)</li> </ul> <p>Hay tres tipos de permisos:</p> <ul> <li>Lectura ( r). Permite que el usuario vea el archivo pero no puede realizar cambios en el mismo ni copiarlo o borrarlo.</li> <li>Escritura (w). Se permite que los usuarios que acceden al archivo o carpeta puedan realizar sobre el mismo cualquier tipo de edici\u00f3n, copiar, cortar o borrar.</li> <li>Ejecutar (x). Al activar esta opci\u00f3n, la cual viene por defecto deshabilitada, podemos ejecutar archivos.</li> </ul> <p>Hay tres modificadores para la tarea:</p> <ul> <li>+. Concede el permiso</li> <li>-. Deniega el permiso</li> <li>=. Sobreescribe un permiso con el permiso anterior.</li> </ul> <p>En entornos Unix cada permiso tiene el siguiente valor:</p> <ul> <li>Lectura: 4</li> <li>Escritura: 2</li> <li>Ejecuci\u00f3n: 1</li> </ul> <p>Jugando con sumas de estos valores establecemos distintos permisos, por ejemplo, si queremos dar un permiso de escritura usaremos el 6 = 4 + 2 (Lectura + Escritura). Si queremos que pueda ejecutar usaremos el 7 = 4 + 2 + 1 (Lectura + Escritura + Ejecuci\u00f3n).</p> <p>En la tabla tenemos todos los valores posibles.</p> <p> Dec. Bin. Permiso read write exe 0 000 Sin permisos N N N 1 001 Ejecuci\u00f3n N N Y 2 010 Escritura N Y N 3 011 Lectura y escritura N Y Y 4 100 Lectura Y N N 5 101 Lectura y ejecuci\u00f3n Y N Y 6 110 Lectura y escritura Y Y N 7 111 Lectura, escritura y ejecuci\u00f3n Y Y Y <p></p> <p>El procedimiento para establecer el permiso es muy sencillo. Basta con ir a una terminal y ejecutar la siguiente orden:</p> <pre><code>chmod Tipo-permiso Ruta-Archivo\n</code></pre> <p>Ejemplos para modificar permisos en modo terminal:</p> <pre><code>chmod o=rwx * \u2192 Dar permisos de lectura, escritura y ejecuci\u00f3n a los otros usuarios.\n\nchmod go= * \u2192 Quitar todos los permisos a grupo y los otros usuarios.\n\nchmod 666 /Documentos/curso-python/Ejercicios/holamundo.py\n</code></pre> <p>En sistemas Linux con letras veremos algo como lo siguiente:</p> <ul> <li>0 \u2192 ---  \u2192 sin acceso</li> <li>1 \u2192 --x \u2192 ejecuci\u00f3n</li> <li>2 \u2192 -w- \u2192 escritura</li> <li>3 \u2192 -wx \u2192 escritura y ejecuci\u00f3n</li> <li>4 \u2192 r-- \u2192 lectura</li> <li>5 \u2192 r-x \u2192 lectura y ejecuci\u00f3n</li> <li>6 \u2192 rw- \u2192 lectura y escritura</li> <li>7 \u2192 rwx \u2192 lectura, escritura y ejecuci\u00f3n</li> </ul> <p>Por ejemplo: chmod 777. Le damos a los 3 tipos de usuarios permiso de lectura, ejecuci\u00f3n y escritura (hemos sumado4+2+1).  Si queremos dar permisos de lectura y escritura ser\u00eda 4+2 = 6 y si si lo que queremos es s\u00f3lo dar lectura ser\u00eda 4. Si lo que queremos es dar lectura y ejecuci\u00f3n ser\u00eda de sumar 4 + 1 = 5.</p> <p>Diferentes combinaciones t\u00edpicas:</p> <ul> <li>chmod 755. Permiso de lectura y ejecuci\u00f3n (4+1) a todos los usuarios excepto al propietario que lo tiene completo (lectura, escritura, ejecuci\u00f3n 4+2+1).</li> <li>chmod 666. Permisos de lectura y escritura a todos, excepto ejecuci\u00f3n (4+2). Todos pueden acceder al archivo, leer su contenido y modificarlo.</li> <li>chmod 644. Se suele utilizar para no permitr la escritura a nadie que no sea el propietario. El 755 es similar, lectura y ejecuci\u00f3n aunque este es m\u00e1s restrictivo (s\u00f3lo lectura) y (lectura, escritura para propietario).</li> </ul>"},{"location":"guias/intro/#palabras-reservadas-e-identificadores","title":"Palabras reservadas e identificadores","text":""},{"location":"guias/intro/#palabras-reservadas","title":"Palabras reservadas","text":"<p>Son palabras reservadas que tienen un significado especial para el compilador y que no podemos usar para poner nombres a variables o funciones. Todas las palabras, excepto <code>True</code>, <code>False</code> y <code>None</code> se escriben en min\u00fasculas. A continuaci\u00f3n se da un listado de todas las palabras reservadas o keywords:</p> <pre><code>False, None, True, and, as, assert, async, await, break, class, continue, \n\ndef, del, elif, else, except, finally, for, from, global, if, import, in, \n\nis, lambda, nonlocal, not, or, pass, raise, return, try, while, with, yield\n</code></pre> <p>El listado al principio nos puede resultar abrumador, pero imaginemos un lenguaje con tan solo esas palabras y entenderemos que no resultar\u00e1 tan complejo familiarizarse, al menos con las mas usuales.</p>"},{"location":"guias/intro/#identificadores","title":"Identificadores","text":"<p>Los identificadores son los nombres que se dan a variables, clases, m\u00e9todos, etc. No podemos usar palabras reservadas para estos nombres.</p> <p>Algunas reglas que nos pueden resultar \u00fatiles para nombrar idetificadores son:</p> <ul> <li>Los identificadores son sensibles a may\u00fasculas y min\u00fasculas</li> <li>Los identificadores no pueden ser palabras reservadas</li> <li>Los espacios en blanco no est\u00e1n permitidos</li> <li>Un identificador puede ser una secuencia de letras y n\u00fameros. Siempre debe empezar por una letra o por el s\u00edmbolo de subrayado \"_\". El primer car\u00e1cter de un identificador no puede ser un n\u00famero.</li> <li>No podemos utilizar caracteres especiales como la \u00f1, \u00a1, \u00bf o letras con acentos.</li> <li>No podemos utilizar los s\u00edmbolos como !, @, #, $, etc.</li> </ul> <p>Nos va a resultar muy \u00fatil recordar lo siguiente:</p> <ul> <li>Python es un lenguaje que distingue entre may\u00fasculas y min\u00fasculas. Esto significa que <code>Variable</code> y <code>variable</code> no son lo mismo</li> <li>Damos siempre a los identificadores un nombre que tenga sentido. Aunque que <code>c = 10</code> es un perfectamente v\u00e1lido, escribir <code>contador = 10</code> tendr\u00eda m\u00e1s sentido, y ser\u00eda m\u00e1s f\u00e1cil averiguar lo que representa cuando miremo el c\u00f3digo pasado un tiempo.</li> <li>Las palabras m\u00faltiples se pueden separar usando un gui\u00f3n bajo, como por ejemplo <code>esto_es_un_nombre_de_variable_muy_largo</code>.</li> </ul>"},{"location":"guias/intro/#variables-constantes-y-literales","title":"Variables, constantes y literales","text":""},{"location":"guias/intro/#variables","title":"Variables","text":"<p>En programaci\u00f3n, una variable es un nombre que se utiliza para referirse a una posici\u00f3n de memoria donde se almacena un valor. De forma m\u00e1s abstracta, puede considerarse como una caja que almacena un valor. El nombre de la caja es el nombre de la variable y el contenido su valor. Todas las variables constan de tres partes: un nombre, un tipo de dato y un valor. En la figura siguiente vemos tres variables de distintos tipos:</p> <p> <p> Concepto gr\u00e1fico de variable</p> <p>Enlace a la fuente</p> <p></p> <p>La variable <code>name</code> contiene la cadena <code>Bob</code>, la variable <code>winner</code> es cierta y la variable <code>score</code> contiene el valor <code>35</code>.</p> <p>Python no dispone de ning\u00fan comando para declarar variables. Una variable se crea cuando se le asigna valor por primera vez. La t\u00e9cnica de declarar variables es poner un nombre seguido del signo de asignaci\u00f3n (=) y el valor asignado a la variable. En la declaraci\u00f3n es importante tener claro que se distinguen may\u00fasculas de min\u00fasculas y que no est\u00e1n permitidos los caracteres especiales.</p> <p>En Python no se declara de forma explicita el tipo de la variable pues se trata de un lenguaje inferido. Las variables incluso pueden cambiar de tipo desde el que se establece al asignarle valor la primera vez. Es decir, si declaro <code>valor = 5</code> inicialmente la variable ser\u00e1 de tipo entero (int), pero si en el programa se realizan operaciones que al final hacen que <code>valor = 1.33</code> ahora valor es de tipo float. Autom\u00e1ticamente sabe que <code>valor</code> es un n\u00famero entero y declara la variable <code>valor</code> como un <code>int</code>.</p> <p>Aunque no es necesario si es posible especificar el tipo de dato de una variable, haciendo:</p> <pre><code>x = str(22) # x ser\u00e1 la cadena '22'\ny = int(22) # y ser\u00e1 el entero 22\nz = float(22) # z ser\u00e1 el n\u00famero de coma flotante 22.0\n</code></pre> <p>Es posible saber el tipo de una variable en un momento dado con la sentencia <code>type(variable)</code>.</p> <p>Algunas reglas para nombrar variables que podemos tener en cuenta son:</p> <ul> <li>Los nombres pueden tener una combinaci\u00f3n de letras min\u00fasculas o may\u00fasculas o n\u00fameros o el s\u00edmbolo de subrayado \"_\".</li> <li>Crear nombres que tengan sentido, aunque sean largos.</li> <li>Si usamos varias palabras para definir el nombre, estas las separamos por \"_\"</li> <li>Python es sensible a may\u00fasculas y min\u00fasculas.</li> <li>Hay que evitar palabras reservadas en nombres de variables.</li> </ul>"},{"location":"guias/intro/#constantes","title":"Constantes","text":"<p>Una constante no es mas que un tipo especial de variable cuyo valor no puede modificarse.</p> <p>En Python, las constantes suelen declararse y asignarse en un m\u00f3dulo (un nuevo archivo que contiene variables, funciones, etc y que se importa al archivo principal).</p> <p>Veamos c\u00f3mo declaramos constantes en un archivo separado y lo usamos en el archivo principal,</p> <ul> <li>Creamos un archivo que nombramos constantes.py y que contendr\u00e1:</li> </ul> <pre><code>PI = 3.141592\nFUERZA_GRAVEDAD = 9.82\n</code></pre> <ul> <li>Creamos el archivo principal main.py, que contendr\u00e1:</li> </ul> <pre><code>import constantes\n\nprint(constantes.PI)\nprint(constantes.FUERZA_GRAVEDAD)\n</code></pre> <p>En el ejemplo creamos el archivo de m\u00f3dulo constantes.py y asignamos el valor constante a PI y FUERZA_GRAVEDAD.</p> <p>Despu\u00e9s, creamos el archivo main.py e importamos el m\u00f3dulo constantes. Finalmente, imprimimos el valor de cada constante.</p> <p>La convenci\u00f3n es nombrarlas en may\u00fasculas para distinguirlas de las variables.</p>"},{"location":"guias/intro/#literales","title":"Literales","text":"<ul> <li>Num\u00e9ricos</li> </ul> <p>Los literales son representaciones de valores fijos en un programa. Pueden ser n\u00fameros, caracteres, cadenas, etc. Por ejemplo, \"\u00a1Hola, mundo!\", 12, 23.0, \"C\", etc.</p> <p>Los literales num\u00e9ricos son inmutables (no pueden cambiar) y pueden pertenecer a uno de los tres tipos de datos num\u00e9ricos posibles: Entero, Coma flotante y Complejo. Los tipos son:</p> <ul> <li>Decimal. N\u00fameros regulares. Por ejemplo: 5, 22, -40</li> <li>Binario. Deben comenzar por 0b. Por ejemplo: 0b110, 0b11</li> <li>Octal. Deben empezar con 0o. Por ejemplo: 0o13, 0o7</li> <li>Hexadedicmal. Deben empezar con 0x. Por ejemplo 0x13, 0xFF</li> <li>Coma flotante. Contienen el punto decimal. Por ejemplo 10.2, 3.14</li> <li> <p>Complejo. Tienen la forma <code>a + bj</code>. Por ejemplo: 3 - 2j, -4 + j</p> </li> <li> <p>Booleanos</p> </li> </ul> <p>Solamente hay dos literales booleanos <code>True</code> y <code>False</code></p> <ul> <li>Cadenas de caracteres</li> </ul> <p>Los literales de caracteres son caracteres unicode encerrados entre comillas, por ejemplo <code>S</code>. Los literales cadenas de caracteres son cadenas de csaracteres encerradas entre comillas, por ejemplo <code>Python es divertido</code>.</p> <ul> <li>Especiales</li> </ul> <p>En Python existe un literal especial, <code>None</code>. Podemos usarlo, por ejemplo, para especificar una variable nula, por ejemplo:</p> <pre><code>var = None\nprint(var)\n# El resultado ser\u00e1: None\n</code></pre>"},{"location":"guias/intro/#tipos-de-datos-en-python","title":"Tipos de datos en Python","text":"<p>En Python, al igual que en programaci\u00f3n en general, los tipos de datos especifican el tipo de datos que puede almacenarse en una variable.</p>"},{"location":"guias/intro/#numericos","title":"Num\u00e9ricos","text":"<p>Contienen valores num\u00e9ricos y sabemos que:</p> <ul> <li>Los n\u00fameros enteros son de tipo int</li> <li>Los fraccionarios son de tipo float</li> <li>La divisi\u00f3n (/) siempre devuelve un n\u00famero en coma flotante</li> <li>Para obtener la parte entera de una divisi\u00f3n se usa el operador //</li> <li>Para calcular el resto de una divisi\u00f3n se usa el operador %</li> <li>Para calcular potencias podemos usar el operador **</li> <li>Los par\u00e9ntesis se pueden usar para agrupar expresiones</li> <li>El signo igual (=) se utiliza para asignar un valor (n\u00fameros, booleanos, cadenas, \u2026) a una variable</li> <li>El tipo de la variable ser\u00e1 el del dato asignado, no se declara el tipo de la variable al crearla</li> <li>Por convenci\u00f3n el nombre comienza en min\u00fascula y si son varias palabras se unen por gui\u00f3n bajo</li> </ul> <p>Los tipos b\u00e1sicos de datos son:</p> <ul> <li><code>int</code>: n\u00fameros enteros con signo sin l\u00edmite de tama\u00f1o, ejemplo: entero = 5</li> <li><code>float</code>: n\u00fameros reales, decimales o de coma flotante con precisi\u00f3n de hasta 15 decimales, ejemplo: real = 5.6</li> <li><code>complex</code>: n\u00fameros complejos, por ejemplo 5.5 - 5j</li> <li>Para averiguar el tipo de dato usamos la funci\u00f3n <code>type()</code>.</li> </ul> <p>Podemos realizar conversi\u00f3n de tipos as\u00ed:</p> <ul> <li>A entero int(variable)</li> <li>A real float(variable)</li> </ul>"},{"location":"guias/intro/#cadenas","title":"Cadenas","text":"<p>Contienen secuencias de caracteres. Una cadena es una secuencia de caracteres representada entre comillas simples o dobles.</p> <p>Las cadenas pueden estar encerradas entre comillas simples ('...') o dobles (\"...\") con el mismo resultado. Podemos usar  para incluir comillas en una cadena.</p> <p>La funci\u00f3n print() devuelve la cadena que encierra entre los par\u00e9ntesis, omitiendo las comillas que la encierran.</p> <p>En la imagen siguiente se ven varios ejemplos con cadenas utilizando como editor el IDLE que por defecto se instala con Python y que se abre desde una terminal simplemente invocando a Python.</p> <p> <p> Cadenas en el IDLE</p> <p></p> <p>Una cadena raw (cruda) se interpreta tal como se escribe, es decir, se omiten los caracteres especiales expresados con . Las cadenas raw se escriben entrecomilladas y van precedidas del car\u00e1cter 'r'. En la imagen vemos un ejemplo.</p> <p> <p> Cadena cruda en el IDLE</p> <p></p> <p>Es posible aplicar la operaci\u00f3n de multiplicar a textos haciendo que estos se repitan. En la imagen siguientes vemos ejemplos de concatenaci\u00f3n y multiplicaci\u00f3n, as\u00ed como un error cometido.</p> <p> <p> Concatenar y multiplicar textos en el IDLE</p> <p></p>"},{"location":"guias/intro/#secuencias","title":"Secuencias","text":"<p>Contienen colecciones de datos, como las listas, las tuplas, las colecciones de datos (set) o los diccionarios.</p> <p>Una lista es una colecci\u00f3n ordenada de elementos similares o de distinto tipo separados por comas y encerrados entre corchetes [ ].</p> <p>Tupla es una secuencia ordenada de elementos, igual que una lista. La \u00fanica diferencia es que las tuplas son inmutables. Una vez creadas, las tuplas no pueden modificarse. En Python, se utilizan los par\u00e9ntesis () para almacenar los elementos de una tupla.</p> <p>Las colecciones de datos son un conjunto desordenada de elementos \u00fanicos. Una colecci\u00f3n de datos se define por valores separados por comas dentro de llaves { }.</p> <p>Un diccionario es una colecci\u00f3n ordenada de elementos. Almacena los elementos como pares clave/valor. Siendo las claves identificadores \u00fanicos que se asocian a cada valor.</p> <p>Estudiaremos estos \u00faltimos tipos mas extensamente cuando los necesitemos.</p> <p>Los datos de tipo booleano solamente pueden contener <code>True</code> o <code>False</code>.</p> <p>Dado que en programaci\u00f3n Python todo es un objeto, los tipos de datos son en realidad clases y las variables son instancias(objeto) de estas clases.</p>"},{"location":"guias/intro/#comentarios-en-python","title":"Comentarios en Python","text":"<ul> <li> <p>Una sola linea: Escribiendo el s\u00edmbolo almohadilla (#) delante del comentario.</p> </li> <li> <p>Multilinea: Escribiendo triple comillas dobles (\u201c\u201d\u201d) al principio y al final del comentario.</p> </li> </ul> <p>En los comentarios, pueden incluirse palabras que nos ayuden a identificar adem\u00e1s, el subtipo de comentario:</p> <pre><code># TODO esto es algo por hacer\n# FIXME (arreglarme) esto es algo que debe corregirse\n# XXX esto tambi\u00e9n, es algo que debe corregirse\n</code></pre>"},{"location":"guias/intro/#identation-o-sangria-en-python","title":"Identation o sangria en Python","text":"<p>La sangr\u00eda se refiere a los espacios al comienzo de una l\u00ednea de c\u00f3digo.</p> <p>Mientras que en otros lenguajes de programaci\u00f3n la sangr\u00eda en el c\u00f3digo es solo para facilitar la lectura, la sangr\u00eda en Python es muy importante ya que se usa para indicar un bloque de c\u00f3digo.</p> <pre><code>if 5 &gt; 2:\n    print(\"Cinco es mayor que 2\")\n</code></pre> <p>Lo siguiente ser\u00eda un error de sintaxis.</p> <pre><code>if 5 &gt; 2:\nprint(\"Cinco es mayor que 2\")\n</code></pre> <p>El n\u00famero de espacios de la identation puede ser cualquiera siempre que al menos sea un espacio. Siempre hay que usar el mismo n\u00famero de espacios en el mismo bloque de c\u00f3digo.</p>"},{"location":"guias/intro/#operadores-en-python","title":"Operadores en Python","text":"<p>Los operadores son s\u00edmbolos especiales que realizan operaciones con variables y valores.</p> <p>A continuaci\u00f3n tenemos una lista de los diferentes tipos de operadores de Python:</p> <ul> <li>Operadores aritm\u00e9ticos</li> <li>Operadores de asignaci\u00f3n</li> <li>Operadores de Comparaci\u00f3n</li> <li>Operadores L\u00f3gicos</li> <li>Operadores Bitwise</li> <li>Operadores especiales</li> </ul>"},{"location":"guias/intro/#operadores-aritmeticos","title":"Operadores aritm\u00e9ticos","text":"<p>Los operadores aritm\u00e9ticos se utilizan para realizar operaciones matem\u00e1ticas como sumas, restas, multiplicaciones, etc.</p> <p> Operador Descripci\u00f3n Ejemplo + Suma o concatenaci\u00f3n en textos <code>5+3=8</code>, <code>\"Hola\" + \"Mundo\" = \"Hola Mundo</code> - Diferencia <code>6-3=3</code> * Multiplicaci\u00f3n <code>3*3=9</code> / Divisi\u00f3n <code>6/2=3</code> // Parte entera de un cociente <code>10//3=3</code> % Resto de un cociente <code>10%3=1</code> ** Potenciaci\u00f3n <code>5**2=25</code> <p></p>"},{"location":"guias/intro/#operadores-de-asignacion","title":"Operadores de asignaci\u00f3n","text":"<p>Los operadores de asignaci\u00f3n se utilizan para asignar valores a variables.</p> <p> Operador Descripci\u00f3n Ejemplo = Asignaci\u00f3n <code>x=4</code>, <code>a = a + 1</code> += Suma y asignaci\u00f3n <code>x+=1</code> equivale a <code>x = x + 1</code> -= Diferencia y asignaci\u00f3n <code>x-=1</code> equivale a <code>x = x - 1</code> *= Multiplicaci\u00f3n y asignaci\u00f3n <code>x*=3</code> equivale a <code>x = x * 3</code> /= Divisi\u00f3n y asignaci\u00f3n <code>x/=3</code> equivale a <code>x = x / 3</code> %= Asignaci\u00f3n de restos <code>x%=3</code> equivale a <code>x = x % 3</code> **= Asignaci\u00f3n de exponentes <code>x**=3</code> equivale a <code>x = x ** 3</code> <p></p>"},{"location":"guias/intro/#operadores-de-comparacion","title":"Operadores de Comparaci\u00f3n","text":"<p>Los operadores de comparaci\u00f3n comparan dos valores/variables y devuelven un resultado booleano: Verdadero o Falso <code>True</code> o <code>False</code>.</p> <p> Operador Descripci\u00f3n Ejemplo == Igual a <code>2==3</code> retorna <code>False</code> != Distinto de <code>2!=3</code> retorna <code>True</code> &lt; Menor que <code>2&lt;3</code> retorna <code>True</code> &gt; Mayor que <code>2&gt;3</code> retorna <code>False</code> &lt;= Menor o igual que <code>2&lt;=3</code> retorna <code>True</code> &gt;= Mayor o igual que <code>2&gt;=3</code> retorna <code>False</code> <p></p>"},{"location":"guias/intro/#operadores-logicos","title":"Operadores L\u00f3gicos","text":"<p>Los operadores l\u00f3gicos se utilizan para comprobar si una expresi\u00f3n es Verdadera o Falsa. Se utilizan en la toma de decisiones.</p> <p> Operador Descripci\u00f3n Ejemplo and AND l\u00f3gica <code>a and b #True si a y b son ciertos</code> or OR l\u00f3gica <code>a or b #True si a o b son ciertos</code> not NOT l\u00f3gica <code>not a #True si el operador a es falso</code> <p></p> <p>En la figura siguiente vemos un ejemplo con lo que devuelve en cada caso.</p> <p> <p> Ejemplos en el IDLE de operadores l\u00f3gicos</p> <p></p>"},{"location":"guias/intro/#operadores-bitwise","title":"Operadores Bitwise","text":"<p>Los operadores bit a bit o bitwise act\u00faan sobre los operandos como si fueran cadenas de d\u00edgitos binarios. Operan bit a bit, de ah\u00ed su nombre.</p> <p> Operador Descripci\u00f3n Ejemplo &amp; AND bit a bit <code>5&amp;6 # 101 &amp; 110 = 110 = 4</code> | OR bit a bit <code>5 \\| 6 # 101 \\| 110 = 111 = 7</code> ~ NOT bit a bit <code>~3 # ~011 = 100 = -4</code> ^ XOR bit a bit <code>5^3 # 101^011 = 110 = 6</code> &lt;&lt; Desplazamiento izquierda <code>4&lt;&lt;1 # 100 &lt;&lt; 1 = 1000 = 8</code> &gt;&gt; Desplazamiento derecha <code>4 &gt;&gt; 1 # 100 &gt;&gt; 1 = 010 = 2</code> <p></p>"},{"location":"guias/intro/#operadores-especiales","title":"Operadores especiales","text":"<p>El lenguaje Python ofrece algunos tipos especiales de operadores como el operador de identidad (<code>identity</code>) y el operador de pertenencia (<code>membership</code>).</p> <ul> <li>Operadores <code>identity</code></li> </ul> <p>En Python, <code>is</code> e <code>is not</code> se utilizan para comprobar si dos valores se encuentran en la misma parte de la memoria. Dos variables que son iguales no implica que sean id\u00e9nticas. Algunos ejemplos aclaran mejor lo dicho.</p> <pre><code>x1 = 5\ny1 = 5\nx2 = 'Hello'\ny2 = 'Hello'\n\nprint(x1 is not y1)  # False\n\nprint(x2 is y2)  # True\n</code></pre> <p>Vemos que x1 e y1 son enteros con los mismos valores, por lo que son iguales e id\u00e9nticos. Lo mismo ocurre con x2 e y2 (cadenas).</p> <ul> <li>Operadores <code>membership</code></li> </ul> <p>En Python, <code>in</code> y <code>not in</code> son los operadores de pertenencia. Se utilizan para comprobar si un valor o variable se encuentra en una secuencia (cadena, lista, tupla, conjunto y diccionario).</p> <p>En un diccionario s\u00f3lo podemos comprobar la presencia de la clave, no del valor.</p>"},{"location":"guias/mblocks/","title":"Microblocks","text":"<p>MicroBlocks es una herramienta de programaci\u00f3n por bloques basada en Snap!. Se trata de un software que puede trabajar online o localmente y que nos va a permitir programar diferentes placas, entre ellas la micro:bit.</p> <p> <p> Logotipo de MicroBlocks</p> <p>Logotipo descargado de la entrada en SAP de Kathy Giori  titulada Recap of \u201cSneak Preview into MicroBlocks\u201d.</p> <p></p> <p>MicroBlocks es un lenguaje de programaci\u00f3n por bloques similar a Scratch que es una excelente herramienta para aprender desde nivel principiante hasta nivel experto y v\u00e1lido para edades que van desde los 8 hasta los 99 a\u00f1os.</p> <p>En el apartado Get Started de su web tenemos descrito como trabajar desde un navegador y los distintos sistemas operativos as\u00ed como los pasos a seguir para configurar nuestra placa y como comenzar a crear programas.</p> <p>En esta ocasi\u00f3n vamos a trabajar de forma local descargando e instalando el programa en nuestro ordenador. En mi caso trabajar\u00e9 con Linux de 64 bits instalando el paquete debian descargado 'ublocks-amd64.deb'. La forma elegida para instalarlo, suponiendo que el paquete est\u00e1 en Descargas, es:</p> <pre><code>sudo dpkg -i ~/Descargas/ublocks-amd64.deb\n</code></pre> <p>Tras la instalaci\u00f3n verificamos que todo est\u00e1 correcto y que Linux ve la placa ejecutando en una terminal lo que vemos en la imagen siguiente.</p> <p> <p> Verificaci\u00f3n de conexi\u00f3n con micro:bit en Linux</p> <p></p> <p>En el enlace Mis notas sobre Linux trabajando con Ubuntu tenemos un par de entradas que describen problemas con el paquete brltty (Braille TTY). En el caso de placas con un chip microcontrolador de la serie USB CP210x, algunas de ellas compatibles con MicroBlocks. Si tenemos este caso el problema se puede resolver eliminando el paquete BRLTTY.</p> <pre><code>sudo apt remove brltty\n</code></pre> <p>El programa una vez instalado lo tenemos disponible en aplicaciones, como vemos en la imagen siguiente.</p> <p> <p> App MicroBlocks disponible</p> <p></p>"},{"location":"guias/mblocks/#por-que-usar-microblocks","title":"\u00bfPor qu\u00e9 usar MicroBlocks?","text":"<p>MicroBlocks tiene una caracter\u00edstica que lo distingue de otros lenguajes de programaci\u00f3n por bloques y es que la programaci\u00f3n real ocurre seg\u00fan se desarrolla el programa, lo que podemos denominar como programaci\u00f3n en directo o en vivo y, debido a esto, que implica que el c\u00f3digo se descarga seg\u00fan se escribe tenemos la otra caracter\u00edstica que le dota de independencia o autonom\u00eda, ya que cuando demos el programa por bueno, este ya est\u00e1 grabado como firmware en la placa.</p> <p>Otra de la caracter\u00edsticas importantes que ofrece MicroBlocks es la multitarea o posibilidad de desarrollar funcionalidades que trabajan de forma paralela y separada cada tarea. Por ejemplo, reproducir un sonido mientras se controla un servomotor. Esta forma de trabajo hace que el c\u00f3digo sea mas sencillo de escribir y de entender.</p> <p>Cuando trabajamos con MicroBlocks la placa que conectemos se comporta como una tarjeta de memoria. No hay necesidad de leer un archivo de proyecto, simplemente conectamos la placa y el script o programa nos aparecer\u00e1 en el IDE. Es decir, MicroBlocks lee el programa que hay en la placa y lo carga de manera autom\u00e1tica.</p> <p>El funcionamiento de MicroBlocks se basa en:</p> <ul> <li>El editor de bloques o IDE que se puede ejecutar online o de manera local.</li> <li>Una m\u00e1quina virtual que se ejecuta en la placa microcontroladora. Esta m\u00e1quina virtual es la encargada de ejecutar el programa de usuario y lo hace compilando en c\u00f3digo de bytes o instrucciones de bajo nivel muy parecidas al c\u00f3digo m\u00e1quina. Si tenemos habilitados los bloques avanzados podemos ver los bytes generados por el programa, como vemos en la animaci\u00f3n siguiente:</li> </ul> <p> <p> C\u00f3digo de bytes</p> <p></p> <p>La parte m\u00e1s importante de la informaci\u00f3n de bytes es la primera l\u00ednea, que muestra el n\u00famero de bytes compilados. Los scripts en MicroBlocks no deben superar los 1000 bytes, de ah\u00ed la importancia de esta informaci\u00f3n.</p> <ul> <li>El sistema de comunicaci\u00f3n entre la placa y el host remoto o el ordenador que hace que el firmware se actualice seg\u00fan se escribe el programa. Este sistema es el encargado de enviar los bytes y comandos para iniciar el programa y procesar mensajes del microcontrolador. As\u00ed el editor proporciona realimentaci\u00f3n gr\u00e1fica de lo que sucede en el microcontrolador y directamente puede mostrar valolres en un \"bocadillo de conversaci\u00f3n\" como el de la figura siguiente.</li> </ul> <p> <p> Bocadillo de conversaci\u00f3n</p> <p></p> <p>MicroBlocks tambi\u00e9n dispone de una herramienta de representaci\u00f3n gr\u00e1fica que estudiaremos en su momento.</p> <p>Una funcionalidad importante del editor es que, adem\u00e1s de programar por bloques, administra las Librerias, que est\u00e1n escritas en MicroBlocks. Existen muchas que iremos viendo poco a poco. Las librerias escritas en MicroBlocks pueden ser editadas por los usuarios.</p>"},{"location":"guias/mblocks/#configuracion-del-equipo","title":"Configuraci\u00f3n del equipo","text":"<p>Necesitamos un ordenador (\u00a1no un dispositivo m\u00f3vil!) con un puerto USB, un cable USB y una placa soportada. Podemos ejecutar MicroBlocks en un navegador Chromium, Chrome o Edge, o descargarlo como una aplicaci\u00f3n independiente para Linux, Chromebook, Windows o MacOS. Las placas soportadas son:</p> <ul> <li>BBC micro:bit v1 y v2</li> <li>Calliope mini</li> <li>Circuit Playground Express y Bluefruit</li> <li>Citilab ED1</li> <li>Raspberry Pi Pico and Pico W</li> <li>Adafruit Clue</li> <li>M5Stack Core Grey</li> <li>ESP8266 y ESP32</li> </ul> <p>Los instaladores est\u00e1n disponibles para las versiones liberadas listas para descargar la apropiada para nuestro sistema operativo. Si estamos trabajando con Chrome o Edge es muy posible que nos advierta de que estamos descargando un archivo que podr\u00eda da\u00f1ar nuestro ordenador. Debemos ignorar esta y sucesivas advertencias para proceder con la descarga.</p> <p>En Linux se descarga un paquete .deb, ublocks-amd64.deb en concreto para esta ocasi\u00f3n que se instala de forma muy sencilla. Con una terminal abierta en el directorio donde est\u00e1 el archivo .deb tecleamos:</p> <pre><code>dpkg -i ~/Descargas/ublocks-amd64.deb\n</code></pre> <p>Tras breves instantes el programa estar\u00e1 instalado y lo tendremos disponible en aplicaciones, como ya hemos visto antes.</p>"},{"location":"guias/mblocks/#configuracion-de-la-placa","title":"Configuraci\u00f3n de la placa","text":"<p>El proceso de configuraci\u00f3n de las placas soportadas es muy similar en todas ellas y es seguir el proceso que vamos a ver a continuaci\u00f3n. En este caso particular se toman las im\u00e1genes y animaciones realizando el proceso con una micro:bit V2.21.</p> <p>Conectamos la placa al ordenador y en el men\u00fa de MicroBlocks hacemos clic en el engranaje y seleccionamos la opci\u00f3n 'actualizar firmware de la placa'.</p> <p> <p> Actualizar firmware de la placa</p> <p></p> <p>En el men\u00fa de la ventana emergente tenemos que seleccionar el tipo de placa que hemos conectado.</p> <p> <p> Seleccionar placa</p> <p></p> <p>Si estamos trabajando con MicroBlocks en un navegador, se nos pedir\u00e1 que seleccionemos la placa si a\u00fan no est\u00e1 conectada.</p> <p>Si no hay una placa conectada aparecer\u00e1 el siguiente aviso.</p> <p> <p> No puedo abrir puerto serie</p> <p></p> <p>Si todo est\u00e1 correcto el icono del puerto USB pasa a estar acompa\u00f1ado de un c\u00edrculo verde que indica la conexi\u00f3n.</p> <p> <p> Conexi\u00f3n por puerto serie realizada</p> <p></p> <p>En este video del canal Youtube de MicroBlocks Fun titulado Quick introduction to MicroBlocks for programming a micro:bit (Introducci\u00f3n r\u00e1pida a MicroBlocks para programar un micro:bit) tenemos una introducci\u00f3n r\u00e1pida a MicroBlocks con micro:bit.</p> <p>La informaci\u00f3n en ingl\u00e9s de la guia de usuario y el manual de referencia de bloques tambi\u00e9n pueden resultarnos de gran ayuda.</p>"},{"location":"guias/mblocks/#actualizar-firmware-en-esp32","title":"Actualizar firmware en ESP32","text":"<p>Los dispositivos ESP son una categor\u00eda especial de Espressif que cuentan con capacidad WIFI. En estas placas se borra totalmente el contenido de la memoria flash de la placa y se carga el firmware m\u00e1s reciente. Tras seleccionar ESP32 se inicia la actualizaci\u00f3n del firmware y aparece informaci\u00f3n del progreso en la pantalla.</p> <p> <p> Actualizar firmware en ESP32</p> <p></p>"},{"location":"guias/mblocks/#habilitardeshabilitar-autocarga-de-librerias","title":"Habilitar/deshabilitar autocarga de librerias","text":"<p>Una de las cosas buenas del editor MicroBlocks es que siempre trata de simplificar las cosas a los usuarios. Dado que cada placa con microcontrolador tiene diferentes caracter\u00edsticas, funciones y capacidades, MicroBlocks intenta de forma autom\u00e1tica complementar las funcionalidades b\u00e1sicas cargando las bibliotecas que estime necesarias, siempre que la opci\u00f3n est\u00e9 habilitada, que se distinguir\u00e1 porque la opci\u00f3n disponible es desactivar.</p> <p> <p> Autocarga de librerias activada</p> <p></p> <p>Cuando se selecciona, este elemento se deshabilita esta funcionalidad y depende del usuario cargar las bibliotecas requeridas.</p> <p> <p> Autocarga de librerias desactivada</p> <p></p>"},{"location":"guias/mblocks/#habilitardeshabilitar-plugshare","title":"Habilitar/deshabilitar PlugShare","text":"<p>Otra caracter\u00edstica muy interesante del editor de MicroBlocks es que cargar\u00e1 autom\u00e1ticamente un proyecto desde el microcontrolador conecvtado, si no hay otro proyecto cargado en el editor. La activaci\u00f3n y desactivaci\u00f3n de la opci\u00f3n es id\u00e9ntica a la de la carga de librer\u00edas. Si la opci\u00f3n muestra desactivar es que est\u00e1 habilitada por lo que el editor leer\u00e1 el proyecto desde el dispositivo y luego proceder\u00e1 a cargarlo en el editor. Si la opci\u00f3n muestra activar es que la funcionalidad no est\u00e1 habilitada.</p> <p>Esta funci\u00f3n es muy importante porque permite a los usuarios compartir proyectos simplemente intercambiando sus dispositivos f\u00edsicos y conect\u00e1ndolos a un ordenador. No hay que compartir archivos.</p> <p>Podr\u00edamos denominar a esta funcionalidad como \"conecta y comparte\".</p> <p> <p> PlugShare activado</p> <p></p>"},{"location":"guias/mblocks/#descripcion-general","title":"Descripci\u00f3n general","text":"<p>En la imagen siguiente vemos los nombres de las distintas partes que componen el editor de MicroBlocks.</p> <p> <p> Partes del editor</p> <p></p> <ul> <li>Bloques. Los bloques est\u00e1n organizados por categorias codificadas por colores. Cuando se selecciona una categor\u00eda se despliegan los correspondientes a esa categoria en la zona denominada paleta de bloques. En la wiki de MicroBlocks podemos encontrar una referencia completa a los bloques (Block Reference) con multitud de ejemplos resueltos.</li> <li>Barra de men\u00fas. Contiene, de izquierda a derecha, el icono en forma de globo terraqueo para configurar el idioma, la rueda dentada para entrar en opciones de MicroBlocks, la hoja de papel que muestra el men\u00fa archivo, el gr\u00e1fico es un men\u00fa con opciones de graficar y conectar y el conector USB para el men\u00fa conectar.</li> <li>Nombre del proyecto. Es el nombre del proyecto actual.</li> <li>Botones de inicio/parada. Son dos iconos que sirven para controlar la ejecuci\u00f3n de los programas.</li> <li>Librerias. Aqu\u00ed se muestran las diversas bibliotecas que se cargan seg\u00fan sea requerido.</li> <li>\u00c1rea de bloques de programa. Es donde se crea el programa o script de usuario y las funciones, que en MicroBlocks se conocen como bloques personalizados.</li> <li>Barra de informaci\u00f3n. Si vamos moviendo el rat\u00f3n por los diversos bloques y \u00e1reas del IDE en esta barra se muestra el tipo de bloque y una breve informaci\u00f3n de ayuda sobre los bloques; as\u00ed como la funcionalidad de las distintas \u00e1reas. La informaci\u00f3n detallada del bloque est\u00e1 disponible a trav\u00e9s del men\u00fa contextual de cada bloque.</li> <li>Controles tama\u00f1o bloques. Estos tres controles permiten cambiar el tama\u00f1o de los bloques aumentando (+) o disminuyendo (-), as\u00ed como establecerlos en el tama\u00f1o predeterminado o del 100% de zoom (=).</li> </ul>"},{"location":"guias/mblocks/#idioma","title":"Idioma","text":"<p>En la imagen siguiente vemos el men\u00fa desplegado.</p> <p> <p> Idioma</p> <p></p> <p>Simplemente tenemos que seleccionar el idioma deseado de entre los que est\u00e1 traducido MicroBlocks. Esto configura todos los men\u00fas, mensajes y bloques de c\u00f3digo en ese idioma. La operaci\u00f3n puede demorarse unos segundos dependiendo del equipo en el que se est\u00e9 ejecutando el programa.</p>"},{"location":"guias/mblocks/#microblocks_1","title":"MicroBlocks","text":"<p>En la figura siguiente vemos este men\u00fa desplegado.</p> <p> <p> MicroBlocks</p> <p></p> <ul> <li>La opci\u00f3n 'acerca de...' nos muestra la informaci\u00f3n sobre MicroBlocks que vemos en la imagen siguiente.</li> </ul> <p> <p> acerca de...</p> <p></p> <ul> <li>Actualizar el firmware de la placa es lo que permite al usuario cargar la \u00faltima versi\u00f3n del firmware en la placa conectada. Dependiendo de los dispositivos conectados y de las condiciones se puede desplegar un men\u00fa para seleccionar el dispositivo concreto. Es la opci\u00f3n que utilizaremos para grabar los programas en la placa.</li> <li>Mostrar bloques avanzados modifica el men\u00fa MicroBlocks mostrando mas opciones, como vemos en la imagen siguiente.</li> </ul> <p> <p> Bloques avanzados</p> <p></p> <ul> <li>La opci\u00f3n versi\u00f3n de firmware nos devuelve la versi\u00f3n de firmware de la m\u00e1quina virtual para micro:bit, como vemos en la imagen siguiente.</li> </ul> <p> <p> versi\u00f3n de firmware</p> <p></p> <ul> <li>La opci\u00f3n borra y reparticiona el firmware en placa ESP borra totalmente el contenido de la memoria y carga el programa actual en placas con capacidad EiFi tipo ESP.</li> <li>La opci\u00f3n inicia el servidor HTTP. Activa (o desactiva si est\u00e1 activo) el servidor HTTP de MicroBlocks en el puerto por defecto 6473, aunque este puede ser cambiado.</li> <li>La opci\u00f3n desactiva autocarga de librerias de placa permite desabilitar la funcionalidad de MicroBlocks de que intente autom\u00e1ticamente complementar las funcionalidades b\u00e1sicas del dispositivo conectado cargando varias bibliotecas.</li> <li>La opci\u00f3n activar PlugShare en proyecto en blanco es una funci\u00f3n que si est\u00e1 habilitada hace que el editor de MicroBlocks cargue autom\u00e1ticamente un proyecto desde el microdispositivo conectado, siempre que no haya un proyecto cargado en el editor. Si el \u00edcono de conexi\u00f3n no es verde y est\u00e1 habilitado PlugShare cuando estamos en un proyecto vac\u00edo, tan pronto como se establezca la conexi\u00f3n USB, MicroBlocks leer\u00e1 y cargar\u00e1 el proyecto que contiene el dispositivo conectado.</li> <li>La opci\u00f3n oculta los bloques avanzados devuelve al men\u00fa MicroBlocks a su estado por defecto, que es la opci\u00f3n mas habitual.</li> </ul>"},{"location":"guias/mblocks/#archivo","title":"Archivo","text":"<p>En la figura siguiente vemos este men\u00fa desplegado.</p> <p> <p> Archivo</p> <p></p> <ul> <li>Guarda. Cuando demos por finalizado un proyecto, o tengamos que dejarlo para otro momento sin perder el trabajo realizado, debemos guardarlo en el ordenador. Se nos abrir\u00e1 una ventana como la de la imagen siguiente.</li> </ul> <p> <p> Guarda fichero</p> <p></p> <ul> <li>Nuevo. Para crear nuevos proyectos. Si tenemos un programa cargado en el \u00e1rea de trabajo del editor, mostrar\u00e1 un mensaje solicitando confirmaci\u00f3n para eliminar del editor el proyecto activo. En la imagen siguiente vemos el mensaje.</li> </ul> <p> <p> Confirmacion</p> <p></p> <p>Si la contestaci\u00f3n es 'Si' el \u00e1rea de trabajo queda vac\u00eda y las bibliotecas a\u00f1adidas por el usuario se borran.</p> <ul> <li>Abre. Esta opci\u00f3n permite cargar en el editor proyectos .ubp previamente guardados. Si hay un proyecto cargado en el \u00e1rea de trabajo, se mostrar\u00e1 un mensaje de confirmaci\u00f3n (igual que en Nuevo) y se presenta una ventana de di\u00e1logo que permite localizar y abrir el archivo deseado. En la imagen siguiente vemos esta ventana.</li> </ul> <p> <p> Di\u00e1logo abrir fichero</p> <p></p> <p>En la categor\u00eda Ejemplos es donde se presentan muchos proyectos de MicroBlocks para diferentes microdispositivos y opciones de hardware.</p> <ul> <li>Copia URL del proyecto al portapapeles. Cuando trabajamos online permite compartir el proyecto.</li> </ul>"},{"location":"guias/mblocks/#conectar","title":"Conectar","text":"<p>En la figura siguiente vemos este men\u00fa desplegado. En esta ocasi\u00f3n hay un dispositivo ya conectado y por eso se muestra la opci\u00f3n disconnect (/dev/ttyACM0).</p> <p> <p> Conectar</p> <p></p> <p>Si tenemos varios dispositivos conectados a puertos USB se nos mostrar\u00e1n los mismos para que podamos escoger el dispositivo que nos interesa. Al seleccionar uno y hacer clic en Conectar se establecer\u00e1 una conexi\u00f3n con el dispositivo correspondiente. Si la conexi\u00f3n tiene \u00e9xito, el \u00edcono USB cambiar\u00e1 a uno con un fondo circular verde, como vemos en la imagen siguiente.</p> <p> <p> Conectado</p> <p></p> <p>Es importante prestar atenci\u00f3n al estado de este icono. MicroBlocks ejecuta muchos procesos internos automatizados y la actualizaci\u00f3n y sincronizaci\u00f3n autom\u00e1tica del c\u00f3digo del proyecto en el dispositivo conectado es uno de ellos, pero esto solo es posible cuando el \u00edcono est\u00e1 en modo verde.</p> <p>Existen diversas razones por las que la conexi\u00f3n puede interrumpirse. Cuando esto ocurre el icono dejar\u00e1 de estar verde y debemos buscar el motivo de la desconexi\u00f3n.</p>"},{"location":"guias/mblocks/#botones-de-inicioparada","title":"Botones de inicio/parada","text":"<p>MicroBlocks siempre est\u00e1 en conexi\u00f3n; se puede hacer clic en bloques o secuencias de comandos individuales para ejecutarlos sin hacer clic en el bot\u00f3n de 'Inicio'.</p> <p>La funci\u00f3n principal del bot\u00f3n 'Inicio' es simular el encendido del dispositivo iniciando todas las secuencias de comandos.</p> <p>El bot\u00f3n 'STOP' detiene la ejecuci\u00f3n del proyecto. Todas las variables son desasignadas. Todos los scripts se detienen.</p> <p>El proyecto cargado en el dispositivo estar\u00e1 en el mismo hasta nueva grabaci\u00f3n de firmware. De hecho, podemos desconectarlo, encenderlo desde una fuente externa y ejecutar el proyecto sin el editor.</p>"},{"location":"guias/mblocks/#programando","title":"Programando","text":"<p>Dado que es la parte en la que mas se trabaja, la creaci\u00f3n de programas, la vemos en su propio apartado.</p> <p>Los bloques colocados en el \u00e1rea de trabajo los podemos mover a voluntad con el rat\u00f3n, as\u00ed como con los men\u00fas contextuales que aparecen al pulsar el bot\u00f3n derecho. Existen una serie de atajos asociados a las teclas Ctrl y Shift que se ir\u00e1n viendo.</p>"},{"location":"guias/mblocks/#arrastrar-y-soltar","title":"Arrastrar y soltar","text":"<p>El movimiento de arrastrar y soltar es el habitual de entornos de programaci\u00f3n por bloques y adem\u00e1s resulta muy intuitivo. Lo nuevo en Microblocks es que mientras se arrastra aparece una sombra paralela que pretende crear un efecto 3D de que el bloque en movimiento va flotando sobre el \u00e1rea de trabajo, incluso por encima del resto de bloques.</p> <p> <p> Sombra paralela</p> <p></p>"},{"location":"guias/mblocks/#acoplar-bloques","title":"Acoplar bloques","text":"<p>Cuando nos acercamos con un bloque o un conjunto de bloques a otro u otros bloques, aparecer\u00e1 una l\u00ednea blanca blanca horizontal que designa un punto de acople.</p> <p> <p> L\u00ednea blanca mostrando punto de acople</p> <p></p> <p>Si soltamos el bot\u00f3n del rat\u00f3n cuando se ve esa l\u00ednea blanca el bloque o bloques se acoplar\u00e1n a los del otro lado de la l\u00ednea.</p>"},{"location":"guias/mblocks/#menu-contextual-de-bloques","title":"Men\u00fa contextual de bloques","text":"<p>Si situamos el cursor sobre un bloque que est\u00e1 en un grupo de bloques y hacemos clic con el bot\u00f3n secundario o derecho, nos aparece un men\u00fa contextual.</p> <p> <p> Men\u00fa contextual en bloques</p> <p></p> <p>Este men\u00fa contextual ofrece mas opciones si hemos seleccionado 'Mostrar bloques avanzados'.</p> <p> <p> Men\u00fa contextual en bloques avanzados</p> <p></p> <ul> <li>Copiar en el portapapeles. Es una operaci\u00f3n que crea una copia de los conjuntos de bloques seleccionados en el portapapeles. Estos se pueden pegar dentro del mismo proyecto o en un proyecto diferente. Tambi\u00e9n es posible copiar/pegar entre el editor online y el local.</li> <li>Copiar al Portapapeles como URL. Esta caracter\u00edstica se utiliza principalmente para incorporar programas MicroBlocks en p\u00e1ginas web, ya que el formato est\u00e1 codificado como URL.</li> </ul>"},{"location":"guias/mblocks/#menu-contextual-de-area-de-trabajo","title":"Men\u00fa contextual de \u00e1rea de trabajo","text":"<p>Es el men\u00fa contextual que aparece cuando hacemos un clic derecho sobre cualquier zona vac\u00eda del \u00e1rea de trabajo.</p> <p> <p> Men\u00fa contextual en \u00e1rea de trabajo</p> <p></p> <ul> <li>tama\u00f1o de bloques. Cuando se selecciona nos muestra una lista con porcentajes para escoger est\u00e1ndo tildado el valor actual.</li> <li>deshaz el \u00faltimo movimiento. Invierte el \u00faltimo movimiento de bloque completado.</li> <li>limpia. Organiza los conjuntos y los bloques sueltos en la pantalla en una disposici\u00f3n de arriba hacia abajo y de izquierda a derecha desde el lado izquierdo del \u00e1rea de trabajo. Los bloques se organizan en m\u00faltiples columnas determinadas por el ancho del \u00e1rea IDE. \u00a1Esta operaci\u00f3n no se puede deshacer!</li> <li>copia todos los programas al portapapeles. Es la pareja de copiar al portapapeles. Mientras que el primero solamente copia el bloque o el programa, este copia todos los programas del proyecto.</li> <li>copia todos los programas al portapapeles como URL. Es lo mismo que el visto anteriormente.</li> <li>guarda una imagen de todos los programas visibles. Es la versi\u00f3n complementaria de la vista en el men\u00fa contextual de bloques.</li> <li>fija la escala de la imagen a exportar. Al seleccionarla nos muestra una lista con porcentajes para escoger est\u00e1ndo tildado el valor actual.</li> </ul>"},{"location":"guias/mblocks/#crear-un-programa","title":"Crear un programa","text":"<p>Por defecto, al iniciar Microblocks aunque se haga con la micro:bit conectada, no tendremos disponibles los bloques de manejo de la pantalla de 5x5 LEDs. Estos bloques se encuentran en la libreria 'Pantalla LED' que debemos a\u00f1adir a nuestro programa. Desde 'Control debemos situar los bloques 'al empezar' y 'por siempre'.</p> <p>Repetimos el 'Primer proyecto' en el que vamos a utilizar, adem\u00e1s de los dos nombrados, el 'limpia pantalla' y 'muestra car\u00e1cter'. En la animaci\u00f3n siguiente vemos el proceso y la simulaci\u00f3n.</p> <p> <p> Primer proyecto</p> <p></p> <p>Podemos observar que tras unos instantes el programa comienza a ejecutarse en la micro:bit conectada. En el caso de Microblocks el bloque usado solamente permite un car\u00e1cter y no crea la animaci\u00f3n si ponemos mas de uno. Para hacer esto tenemos disponible otro bloque.</p> <p>Ya tenemos creado el programa y comprobado que funciona, es hora de salvarlo en el ordenador. Esto lo haremos asi principalmente para tener disponibles todos los programas y poder enlazarlos donde convenga en estas notas. En la animaci\u00f3n siguiente vemos el proceso de descarga del archivo.</p> <p> <p> Descarga del archivo Primer-proyecto.ubp</p> <p></p> <p>El Primer proyecto lo podemos descargar desde este enlace.</p> <p>Durante el proceso de cambios en el programa podemos comprobar que el conjunto de bloques esta rodeado de una l\u00ednea verde que indica que el programa se est\u00e1 ejecutando en la micro:bit. Lo apropiado cuando vamos a realizar cambios es detener la ejecuci\u00f3n, hacer los cambios y volver a poner la ejecuci\u00f3n en marcha.</p> <p> <p> Realizando cambios</p> <p></p> <p>En la animaci\u00f3n vemos junto a los botones de inicio/parada el icono indicador de progreso de la sincronizaci\u00f3n entre el IDE y la placa.</p>"},{"location":"guias/mblocks/#enlaces-utiles","title":"Enlaces \u00fatiles","text":"<ul> <li> <p>En la web de Francisco Soldado denominada 'ardutaller' nos vamos a encontrar con una entrada MicroBlocks \u2192&gt; micro:bit donde aparece un video con detalles adicionales sobre el trabajo con esta pareja de software/hardware. En ese mismo enlace tenemos disponibles varias actividades totalmente resueltas tanto en catal\u00e1n como espa\u00f1ol.</p> </li> <li> <p>Este es el video en Youtube integrado en la web titulado Introducion al Software Microblocks. Conexi\u00f3n a Microbit</p> </li> </ul>"},{"location":"guias/mkcode/","title":"Microsoft MakeCode","text":"<p>El editor MakeCode de Microsoft es una buena forma de comenzar a programar la BBC micro:bit seg\u00fan mi criterio. Se utiliza un sistema de bloques codificados por colores que resultan f\u00e1ciles de usar y lo suficientemente potentes como para acceder a todas las funciones de la placa. Tambi\u00e9n se puede cambiar el editor a JavaScript para ver el c\u00f3digo equivalente a los bloques.</p> <p>Se puede encontrar m\u00e1s informaci\u00f3n sobre c\u00f3mo usar el editor MakeCode en las Preguntas m\u00e1s frecuentes de MakeCode.</p> <p>Lo que vamos a mostrar aqu\u00ed es una referencia de MakeCode a trav\u00e9s del editor que podemos encontrar en:</p> <p> <p> Abrir el editor online MakeCode</p> <p></p> <p>Existen versiones descargables de MakeCode, pero no para Linux.</p>"},{"location":"guias/mkcode/#primeros-pasos","title":"Primeros pasos","text":"<p>El aspecto que se nos va a mostrar al entrar en el enlace anterior es el que vemos en la imagen siguiente, que se corresponde con la parte superior de la web. Es posible la primera vez se en ingl\u00e9s pero lo podemos cambiar haciendo clic en la rueda dentada y escogiendo el idioma entrando en la primera opci\u00f3n que se muestra.</p> <p> <p> Pantalla inicial de MakeCode</p> <p></p> <p>La ventana requiere pocas explicaciones y lo primero que vamos a hacer en crear un nuevo proyecto haciendo clic en el bloque de 'Nuevo proyecto'. Para crear proyectos en la nube tendremos que loguearnos mediante una cuenta v\u00e1lida. En la animaci\u00f3n siguiente vemos como crear nuestro primer proyecto.</p> <p> <p> Primer programa en MakeCode</p> <p></p> <p>Al principio nos pide un nombre para el programa y nos ofrece la posibilidad de escoger como queremos trabajar en cuanto a c\u00f3digo se refiere. Posteriormente lanza un peque\u00f1o tutorial, que aunque est\u00e1 en ingl\u00e9s, nos explica muy claramente como trabajar con el programa.</p> <p>En la animaci\u00f3n siguiente se recorren las opciones principales que est\u00e1n disponibles cuando estamos editando un proyecto.</p> <p> <p> Ventana de edici\u00f3n de proyecto en MakeCode</p> <p></p>"},{"location":"guias/mkcode/#descripcion-de-la-ventana-de-proyecto","title":"Descripci\u00f3n de la ventana de proyecto","text":"<ul> <li>En la parte superior izquierda de la pantalla es donde est\u00e1 situado el simulador que se muestra con una imagen de una micro:bit. Se trata de una secci\u00f3n muy importante porque nos permite trabajar con la mayor parte de los programas sin necesidad de tener una placa f\u00edsica conectada, adem\u00e1s resultar \u00fatil para depurar el c\u00f3digo.</li> <li>A la derecha del simulador se sit\u00faa una columna con los bloques de programaci\u00f3n organizados por categorias. Cuando hacemos clic en una categoria se despliegan, a la derecha, los bloques mas utilizados de esa categoria. Muchas veces, debajo del nombre correspondiente a esa categoria aparece un letrero ...mas, que si se pulsa muestra el resto de bloques de la categoria. Para llevar un bloque al \u00e1rea de programaci\u00f3n basta con hacer clic sobre el mismo y arrastrarlo a la misma. En la parte superior de esta columna hay un buscador por si no recordamos muy bien donde est\u00e1 el bloque que buscamos.</li> <li>A la derecha de los bloques de programaci\u00f3n est\u00e1 la zona de programaci\u00f3n, que es donde se arrastran los bloques para crear el programa.</li> <li>Tanto en la parte superior como inferior de la pantalla tenemos enlaces a funcionalidades del programa que quedan resumidas en la imagen siguiente.</li> </ul> <p> <p> Barras de herramientas de MakeCode</p> <p></p>"},{"location":"guias/mkcode/#crear-un-programa","title":"Crear un programa","text":"<p>Por defecto, al crear un proyecto, MakeCode sit\u00faa dos bloques de eventos en el a\u0155ea de programa, 'al iniciar' y 'para siempre'. Otros bloques que permiten iniciar el programa los podemos encontrar en 'Entrada'. Esta ser\u00e1 la primera tarea a realizar en nuestro programa, decidir que evento es el que inicia el c\u00f3digo.</p> <p>El programa lo vamos creando arrastrando bloques al \u00e1rea de programaci\u00f3n y podemos ir probando el funcionamiento en el simulador. Las opciones que permiten interactuar con el simulador son dependientes de los bloques introducidos.</p> <p>Vamos a hacer algo en este 'Primer proyecto' que es el nombre que le dimos al primer programa. Simplemente vamos a utilizar dos bloques, uno va a ser 'Borrar la pantalla' y el otro 'Mostrar n\u00famero', ambos en la secci\u00f3n 'Entrada'. El primero lo vamos a poner en el bloque 'al iniciar' de manera que cada vez que se inicia la micro:bit se apaguen todos los LEDs y el segundo lo pondremos en 'para siempre' y sin modificar nada vemos como el n\u00famero 0 se muestra mientras est\u00e1 alimentada la micro:bit. En la animaci\u00f3n siguiente vemos el proceso y la simulaci\u00f3n.</p> <p> <p> Primer proyecto</p> <p></p> <p>Podemos hacer pruebas cambiando el n\u00famero e incluso entrando n\u00fameros de varias cifras para ver lo que ocurre.</p>"},{"location":"guias/mkcode/#grabar-codigo-en-la-microbit","title":"Grabar c\u00f3digo en la micro:bit","text":"<p>Aunque es posible utilizar el bot\u00f3n 'Descargar' para grabar directamente el programa en la memoria flash, el proceso que nosotros vamos a seguir siempre va a ser descargar el .hex y arrastrarlo a la unidad MICROBIT montada. Esto lo haremos asi principalmente para tener disponibles todos los programas y poder enlazarlos donde convenga en estas notas. En la animaci\u00f3n siguiente vemos el proceso de descarga del archivo.</p> <p> <p> Descarga del archivo Primer-proyecto.hex</p> <p></p> <p>El Primer proyecto lo podemos descargar desde este enlace.</p> <p>Una vez descargado el .hex y conectada la micro:bit a un puerto USB procedemos a grabar el programa en la micro:bit para comprobar que funciona exactamente igual que en la simulaci\u00f3n. El proceso lo vemos en la animaci\u00f3n siguiente.</p> <p> <p> Grabar en la micro:bit el archivo Primer-proyecto.hex</p> <p></p> <p>Durante el proceso de grabaci\u00f3n podemos comprobar el parpadeo del LED amarillo de la cara posterior y como se desmonta y monta la unidad MICROBIT reseteandose la placa.</p>"},{"location":"guias/outofthebox/","title":"Experiencia inmediata","text":"<p>Cuando abrimos y conectamos una micro:bit nueva, se ejecuta un programa de demostraci\u00f3n grabado en f\u00e1brica. Esto es lo que se conoce como \"Out of box experience\" que se traduce como \"experiencia inmediata\" y que nos permite comenzar a ver y disfrutar funcionalidades de la placa sin hacer nada mas que conectarla. Si queremos restablecer de f\u00e1brica la micro:bit podemos descargarnos el archivo .hex listo para usar.</p> <p>El programa es v\u00e1lido para todas las versiones de micro:bit aunque, l\u00f3gicamente, si no disponemos de las funcionalidades que nos da la V2 no podremos disfrutarlas.</p> <p>Una vez descargado el programa lo grabamos en nuestra micro:bit y veremos como la pantalla LED comienza a hacer cosas, nos saluda y a partir de aqu\u00ed podemos ir desbloqueando varios juegos siguiendo las instrucciones en pantalla y lo que vamos a ver aqu\u00ed.</p> <p>Una primera cosa que podemos hacer con la V2 es \"dormir a la micro:bit\" manteniendo presionado el bot\u00f3n de reset de la parte posterior hasta que se apague el LED de encendido. Para \"despertarla\" presionamos de nuevo reset.</p> <ul> <li>Presionar lo botones. Median te una flecha nos indica el bot\u00f3n que debemos pulsar para avanzar. Los botones son las entradas m\u00e1s b\u00e1sicas de que dispone micro:bit</li> <li>Ag\u00edtala (Shake it). Cuanto mas agitemos la micro:bit mas LEDs se enceder\u00e1n. Esta funcionalidad est\u00e1 programada con el sensor de movimiento que integra la placa y que se conoce como aceler\u00f3metro porque mide fuerzas. Puede medir la fuerza de sacudida o en que direcci\u00f3n se realiza esta.</li> <li>Tilt: chase the dot. Se trata de atrapar el punto intermitente inclinando la micro:bit.</li> <li>Aplaude (Clap). La micro:bit V2 dispone de micr\u00f3fono y escucha el sonido.</li> <li>Huevo de pascua. A veces se denominan as\u00ed los juegos secretos. Cuando veamos en pantalla un coraz\u00f3n debemos pulsar simultaneamente los botones A y B y se desbloquer\u00e1 el juego de la serpiente.</li> </ul> <p>Podemos reiniciar la microbit en cualquier momento para iniciar de nuevo la demostraci\u00f3n.</p> <p>El c\u00f3digo que descargamos est\u00e1 escrito en C++ por lo que no se cargar\u00e1 en los editores de MakeCode o Python. Ahora bien, se puede  crear un programa propio para esta 'experiencia lista para usar' tanto en MakeCode como en Python.</p> <p>Tanto para enviar a la micro:bit este programa como otro archivo hexadecimal podemos utilizar la herramienta online micro:bit WebUSB hex file flashing tool o micro:bit WebUSB herramienta de flasheo de archivos hexadecimales.</p> <p>En la animaci\u00f3n siguiente vemos esta herramienta en funcionamiento.</p> <p> <p> Herramienta de flasheo</p> <p></p> <p>En la imagen vemos la ventana de la aplicaci\u00f3n traducida.</p> <p> <p> Herramienta de flasheo traducida</p> <p></p>"},{"location":"guias/poo/","title":"Programaci\u00f3n Orientada a Objetos","text":"<p>Este apartado se crea especificamente por la dificultad que tiene el tema que vamos a explicar a continuaci\u00f3n:</p> <p>Hay ciertos elementos o dispositivos que van a requerir de una librer\u00eda externa a Python y estas librerias se hacen utilizando las clases. En el editor online de MicroPython de micro:bit se pueden incluir y utilizar este tipo de liber\u00edas. Para centrar un poco el tema vamos a ver:</p> <ul> <li>Las clases en Python de una forma no muy profunda.</li> <li>La utilizaci\u00f3n del men\u00fa Project de python.microbit, necesario para poder incluir librerias</li> <li>Ejemplo de trabajo con una libreria para una LCD I2C.</li> </ul>"},{"location":"guias/poo/#las-clases-en-python","title":"Las clases en Python","text":"<p>La Programaci\u00f3n Orientada a Objetos (POO) es un modelo de programaci\u00f3n que proporciona unas gu\u00edas acerca de c\u00f3mo trabajar con \u00e9l y que est\u00e1 basado en el concepto de clases y objetos.</p> <p>Una clase es una especie de plantilla que define, de forma gen\u00e9rica, como ser\u00e1n los objetos de un determinado tipo. Pongamos por ejemplo que una clase representa a un club, que podemos denominar \"club\". Esta clase puede tener atributos (propiedades) como nombre, edad, profesion. Se pueden implementar como m\u00e9todos (funciones) de esas propiedades comportamientos como socio, socia o imparte_taller.</p> <p>Un ejemplo sencillo de un objeto puede ser un profesor, que puede ser socio por lo que se crea un atributo de profesi\u00f3n y adem\u00e1s puede impartir_taller, por lo que se define un nuevo m\u00e9todo.</p> <p>Una clase en Python es una estructura que permite definir los m\u00e9todos y atributos que definen un objeto. En Python una clase es una plantilla para crear objetos que son instancias de esa clase.</p> <p>En Python, una clase se define mediante la palabra clave <code>class</code>, seguida del nombre de la clase, dos puntos (:) y el cuerpo de la clase. Este cuerpo contiene definiciones de m\u00e9todos y atributos, que pueden ser p\u00fablicos o privados seg\u00fan su acceso.</p> <pre><code>class club:\n    def __init__(self, nombre, edad, profesion):\n        self.nombre = nombre\n        self.edad = edad\n        self.profesion = profesion\n    def saludo(self)\n        print(\"Hola, me llamo \" + self.nombre + \"y soy \" + self.profesion)\n</code></pre> <p>Las principales ventajas de utilizar clases son:</p> <ul> <li>Reutilizaci\u00f3n. Una clase la podemos reutilizar en diferentes partes del programa y en distintos programas. Esto puede ahorrar mucho tiempo y evita repeticiones de c\u00f3digo.</li> <li>Modulaci\u00f3n. El c\u00f3digo de un programa se divide en partes mas peque\u00f1as lo que facilita el mantenimiento y la soluci\u00f3n de problemas.</li> <li>Encapsulaci\u00f3n. Consiste en ocultar la complejidad de un objeto para mostrar solamente una interfaz simple f\u00e1cil de usar para interactuar ese objeto.</li> <li>Polimorfismo. Se trata de implementar el mismo conjunto de m\u00e9todos con diferentes comportamientos para distintos objetos. Esto dota de mayor flexibilidad al dise\u00f1o de programas.</li> </ul> <p>Las principales desventajas de utilizar clases son:</p> <ul> <li>Complejidad. Una clase puede hacer mas dificil de entender y depurar un programa debido al incremento de complejidad.</li> <li>Curva de aprendiza. Aprender Programaci\u00f3n Orientada a Objetos y clases tiene una curva de aprendizaje mas pronunciada, sobre todo cuando se empieza a programar.</li> <li>Abuso. A veces se abusa inncesariamente de las clases en situaciones en las que una funci\u00f3n har\u00eda lo mismo incluso de forma mas eficiente.</li> </ul> <p>Las variables que se definen dentro de las clases se denominan atributos y sirven para almacenar datos de un objeto de esa clase. Se utilizizan para representar propiedades de un objeto.</p> <p>Los atributos pueden ser como las variables normales, enteros, reales, cadenas, listas, tuplas, diccionarios, etc. Adem\u00e1s pueden tener distintos niveles de visibilidad que se indican mediante modificadores de acceso. En Python los modificadores son p\u00fablicos por defecto, lo que significa que son accesibles desde cualquier lugar del programa.</p> <p>Un atributo se define como una variable que se inicializa con el m\u00e9todo <code>__init__</code>. Por ejemplo:</p> <pre><code>class club:\n    def __init__(self, nombre, edad, profesion):\n        self.nombre = nombre\n        self.edad = edad\n        self.profesion = profesion\n</code></pre> <p>En la clase <code>club</code> los atributos nombre, edad y profesion, se definen como se ve en el c\u00f3digo. En este caso los tres son atributos p\u00fablicos de la clase <code>club</code>, que se inicializan con los valores que se proporcionen al crear un objeto de la clase. El acceso a los atributos de un objeto de una clase se utiliza el modificador (.) seguido del nombre del atributo, por ejemplo, para acceder al atributo <code>nombre</code> de un objeto <code>socio</code> de la clase <code>club</code> hariamos:</p> <pre><code>socio1 = socio1.nombre\n</code></pre> <p>Los tipos de atributos son:</p> <ul> <li>P\u00fablicos. Ya hemos indicado que se puede acceder a ellos desde cualquier parte del programa y desde fuera de la clase y que en Python lo son por defecto, por lo que no requieren ning\u00fan modificador de acceso. Se accede a ello con (.).</li> <li>Privados. Solo son accesibles desde la propia clase y se definen con el prefijo (__) seguido del nombre del atributo.</li> <li>Protegidos. Solamente son accesibles desde la propia clase o desde sus clases heredadas. Se utiliza el prefijo \"\" seguido del nombre del atributo para su definici\u00f3n. En Python es simplemente una convenci\u00f3n y si es posible acceder desde fuera de la clase.</li> </ul> <p>En Python se utilizan los m\u00e9todos, que son funciones que se definen dentro de una clase y que se utilizan para hacer operaciones en los objetos creados a partir de esa clase. La definici\u00f3n de un m\u00e9todo se realiza de la misma forma que la de una funci\u00f3n con la diferencia de que en un m\u00e9todo siempre tiene como primer par\u00e1metro el objeto al que se aplicar\u00e1 el m\u00e9todo, que por defecto se llama <code>self</code>.</p> <p>Para utilizar un m\u00e9todo de una clase lo primero que tenemos que hacer es crear un objeto a partir de la clase y as\u00ed poder llamar al m\u00e9todo sobre ese objeto.</p> <p>El objeto <code>self</code> se utiliza como referencia del objeto que se manipula cuando se llama al m\u00e9todo. Al crear una instancia de una clase, necesitamos diferenciar o especificar los atributos de la instancia de los argumentos y otras variables. Y ah\u00ed es donde necesitamos la palabra clave <code>self</code> para especificar que estamos pasando el valor a los atributos de la instancia y no a la variable o argumento local con el mismo nombre.</p> <p>Existen tambi\u00e9n otros m\u00e9todos que se denominan dunder (de double underscore methods) que tienen un doble gui\u00f3n bajo (__) al principio y al final del nombre.</p> <ul> <li>init: Inicializar un objeto cuando se crea una instancia de una clase. Se usa para asignar valores a los atributos de una instancia de clase.</li> <li>str: Se utiliza para devolver una cadena de una instancia de una clase. Es el m\u00e9todo que se llama cuando usamos la funci\u00f3n <code>str()</code> para convertir un objeto en una cadena de caracteres.</li> <li>repr(): M\u00e9todo especial de Python que se utiliza para devolver una cadena legible de un objeto. Se llama cuando usamos la funci\u00f3n repr().</li> </ul> <p>Y bueno, hay mas conceptos y definiciones necesarias para trabajar creando clases, pero como este no es el objetivo, lo vamos a dejar aqu\u00ed que ya es suficiente para manejarnos un poco con clases ya creadas.</p>"},{"location":"guias/poo/#menu-project","title":"Men\u00fa Project","text":"<p>Aunque ya hemos visto el uso del editor Python online de micro:bit vamos a centrarnos en el uso de este men\u00fa pues lo vamos a necesitar para tener acceso a librerias externas. La secci\u00f3n de proyectos, que se encuentra en el men\u00fa de la izquierda, es especialmente \u00fatil si necesitamos a\u00f1adir archivos Python adicionales al proyecto. Puede ser, por ejemplo, para a\u00f1adir un m\u00f3dulo para un accesorio o para a\u00f1adir c\u00f3digo proporcionado por un tercero. En el canal Youtube de Micro:bit Educational Foundation est\u00e1 el video Projects section: micro:bit Python Editor que describe el proceso.</p>"},{"location":"guias/poo/#uso-del-menu-project","title":"Uso del men\u00fa project","text":"<p>Cuando accedemos la men\u00fa Project de la barra lateral izquierda veremos como se muestra el nombre del proyecto, se enumeran todos los archivos del proyecto actual y tres botones.</p> <p> <p> Acceso al men\u00fa Project</p> <p></p> <p>Inicialmente solamente est\u00e1 el archivo main.py que incluye el c\u00f3digo de inicio. Si queremos a\u00f1adir un archivo nuevo a nuestro proyecto debemos elegir \"Create file\" haciendo clic en el bot\u00f3n del mismo nombre. Si llamamos LCD a este archivo la situaci\u00f3n ser\u00e1 la siguiente:</p> <p> <p> Creaci\u00f3n de un nuevo archivo</p> <p></p> <p>En la animaci\u00f3n se observa que el nombre tiene que ser en min\u00fasculas y que ademas la extensi\u00f3n la a\u00f1ade el propio programa.</p> <p>El l\u00e1piz a la derecha del nombre del proyecto permite editar el nombre del mismo. Las di\u00e9resis a la derecha de los nombres de archivo tienen utilidad para editar el c\u00f3digo del archivo, salvar el archivo o borrar el archivo. La opci\u00f3n borrar no est\u00e1 disponible en main.py ya que es un archivo obligatorio y no puede ni eliminarse ni cambiarle el nombre. El nuevo archivo aparecer\u00e1 en el men\u00fa.</p> <p> <p> Nuevo archivo creado y opciones</p> <p></p> <p>Este archivo forma parte de nuestro proyecto. En este momento es cuando podemos abrir un archivo de libreria, en mi caso voy a abrir el archivo que contiene la clase para el manejo de la LCD I2C1602. Para ello hago clic en el bot\u00f3n \"Open\", localizo el archivo y le doy a abrir o hago doble clic sobre su nombre.</p> <p> <p> Localizaci\u00f3n del archivo a a\u00f1adir</p> <p></p> <p>Se muestra entonces una ventana en la que nos pregunta si queremos cambiar archivos reemplazando el c\u00f3digo en <code>main</code> por el del archivo seleccionado. Aqu\u00ed en lugar de confirmar la acci\u00f3n descrita observamos que hay un peque\u00f1o icono en el interior de la ventana que si lo clicamos nos permite cambiar la opci\u00f3n de reemplazar por la de a\u00f1adir el fichero, y es justo lo que tenemos que hacer.</p> <p> <p> Selecci\u00f3n de cambiar o a\u00f1adir el archivo</p> <p></p> <p>Escogemos la opci\u00f3n de a\u00f1adir y hacemos clic en confirmar para que el archivo pase a formar parte de nuestro proyecto.</p> <p> <p> Selecci\u00f3n de cambiar o a\u00f1adir el archivo</p> <p></p> <p>El estado final de los archivos del proyecto es el siguiente:</p> <p> <p> Archivo libreria a\u00f1adido al proyecto</p> <p></p> <p>Con esto ya estamos en condiciones de comenzar a programar nuestro ejemplo \"Hola Mundo\". El proceso para a\u00f1adir la librer\u00eda se puede realizar sin necesidad de crear el archivo <code>lcd.py</code> pero siempre con la precauci\u00f3n de sustituir la opci\u00f3n de reemplazar por la de a\u00f1adir. En caso contrario el contenido del archivo <code>main.py</code> pasar\u00e1 a ser el del archivo elegido.</p> <p>Si queremos recuperar el estado original que teniamos al principio para, por ejemplo, empezar un nuevo proyecto basta con hacer clic en el bot\u00f3n rojo \"Reset project\", pero cuidado porque si no hemos archivado las modificaciones anteriores las perderemos.</p> <p>Si nos movemos por el archivo de libreria podemos observar que es una clase y en ella aparecen m\u00e9todos para la LCD como indicar su direcci\u00f3n f\u00edsica, borrarla, etc.</p> <p> <p> Contenido del archivo libreria I2C_LCD1602</p> <p></p> <p>Ahora es cuando nos vendr\u00e1 bien lo aprendido sobre clases.</p>"},{"location":"guias/poo/#ejemplo-hola-mundo-con-lcd","title":"Ejemplo Hola Mundo con LCD","text":"<p>Vamos a ir creando el ejemplo paso a paso explicando lo que hacemos.</p> <p>1.- En primer lugar debemos importar la librer\u00eda a nuestro archivo principal y lo hacemos exactamente igual que la l\u00ednea de importaci\u00f3n de microbit.</p> <pre><code>from microbit import *\nfrom I2C_LCD1602 import *\n...\n</code></pre> <p>Con esto ya tenemos disponible la clase para trabajar con ella y como se ha indicado lo primero que hay que hacer es crear una instancia de la clase para poder acceder a sus miembros. A continuaci\u00f3n lo tenemos comentado.</p> <pre><code>from microbit import *\nfrom I2C_LCD1602 import *\n# Inicializamos el objeto al crear una instancia de \n# la clase a trav\u00e9s del self del m\u00e9todo dunder __init__\nlcd = I2C_LCD1602(0x27)\n...\n</code></pre> <p>Lo siguiente que haremos ser\u00e1 encender la LCD, poner la retroiluminaci\u00f3n activa y borrar todo contenido de la LCD para comenzar desde una pantalla limpia. Estos son los procesos usuales antes de entrar en el bucle infinito para dejar la pantalla preparada para empezar a mostrar mensajes. En la animaci\u00f3n vemos como crear una de las l\u00edneas.</p> <p> <p> Acceso a miembros desde la instancia creada</p> <p></p> <p>El programa ya tiene el siguiente contenido modificado en el archivo <code>main.py</code>, es hora de programar en el bucle infinito.</p> <pre><code>from microbit import *\nfrom I2C_LCD1602 import *\n# Inicializamos el objeto al crear una instancia de \n# la clase a trav\u00e9s del self del m\u00e9todo dunder __init__\nlcd = I2C_LCD1602(0x27)\nlcd.on()\nlcd.backlight(1) #1=retroiliminaci\u00f3n ON, 0=retroiluminacion OFF\nlcd.clear()\n...\n</code></pre> <p>Dentro de bucle simplemente vamos a escribir dos mensajes, \"Hola Mundo\" en la primera fila (0) y simplemente para ver como se hace otro texto en la segunda fila (1). El programa final es este:</p> <pre><code># Le indicamos a MicroPython que obtenga todo (el *) lo que \n# necesita para trabajar con micro:bit desde el m\u00f3dulo microbit\nfrom microbit import *\n# De id\u00e9ntica forma le decimos que obtenga todo de la clase\n# I2C_LCD1602 para trabajar con una LCD 1602 I2C\nfrom I2C_LCD1602 import *\n# Inicializamos el objeto al crear una instancia de \n# la clase a trav\u00e9s del self del m\u00e9todo dunder __init__\nlcd = I2C_LCD1602(0x27)\nlcd.on()\nlcd.backlight(1) #1=retroiliminaci\u00f3n ON, 0=retroiluminacion OFF\nlcd.clear()\n\nwhile True:\n    # Escribe Hola Mundo desde la columna 0 en la fila 0.\n    lcd.puts(\"Hola Mundo\",0,0) \n    # Escribe LCD I2C1602 desde la columna 3 de la fila 1\n    lcd.puts(\"LCD I2C1602\",3,1)\n</code></pre> <p>Descargar la libreria</p> <p>Descargar el programa</p>"},{"location":"guias/pyt/","title":"BBC micro:bit con MicroPython","text":"<p>Practicamente todas las explicaciones sobre este tema van a estar basadas en BBC micro:bit MicroPython documentation que desafortunadamente no est\u00e1 es espa\u00f1ol.</p> <p>Uno de los lenguajes que entiende la micro:bit es el Python y la versi\u00f3n que se ejecuta en BBC micro:bit se llama MicroPython.</p> <p>Aunque en principio toda la informaci\u00f3n se va a referir a la versi\u00f3n V2 de micro:bit casi todo ser\u00e1 v\u00e1lido para versiones anteriores, excepto claro lo no implementado en estas.</p> <p>Fundamentalmente vamos a utilizar, para crear los programas, el editor de MicroPython para micro:bit que es muy similar MakeCode. Tambi\u00e9n se puede trabajar con el edit Mu.</p> <p>Python en BBC micro:bit est\u00e1 pensado para que estudiantes de 11 a 14 a\u00f1os (o edades superiores), aprendan fundamentos de la programaci\u00f3n a trav\u00e9s de la codificaci\u00f3n basada en texto.</p> <p> <p> Editor de MicroPython</p> <p></p> <p>Conectamos la micro:bit al ordenador mediante un cable USB.</p> <p>Escribimos el script (programa) en la ventana del editor y hacemos clic en el bot\u00f3n \"Enviar a micro:bit\" o \"Guardar\" para despu\u00e9s transferirlo al micro:bit.</p>"},{"location":"guias/pyt/#partes-del-editor-de-python-microbit","title":"Partes del editor de Python micro:bit","text":"<p>En la gu\u00eda de usuario User guide tenemos la descripci\u00f3n que vamos a resumir aqu\u00ed de las partes que componen el editor.</p> <p> <p> Apartados del editor de MicroPython</p> <p></p>"},{"location":"guias/pyt/#1-referencia","title":"1. Referencia","text":"<p>La secci\u00f3n facilita descubrir lo que Python y micro:bit pueden hacer, como explorar bloques en MakeCode o Scratch.</p> <p>Tamibi\u00e9n sirve para ver f\u00e1cilmente el potencial del hardware que incorpora la micro:bit y que el software de escritura en Python aumenta la creatividad de los alumnos.</p>"},{"location":"guias/pyt/#2-fragmentos-de-codigo","title":"2. Fragmentos de c\u00f3digo","text":"<p>Son fragmentos de c\u00f3digo listos para arrastrar y soltar en el \u00e1rea de programa. Estos fragmentos son totalmente funcionales, ahorran tiempo y ayudan a superar barreras de falta de habilidad con el teclado y recordar de forma precisa la sintaxis.</p> <p> <p> Arrastrar y soltar un fragmento de c\u00f3digo</p> <p></p> <p>Podemos observar como al arrastrar al \u00e1rea de c\u00f3digo la identation (sangria) se realiza de forma autom\u00e1tica para respetar la sintaxis de Python.</p>"},{"location":"guias/pyt/#3-resaltado-de-la-estructura-del-codigo","title":"3. Resaltado de la estructura del c\u00f3digo","text":"<p>Los distintos colores y la l\u00edneas de sangria que se muestran en los programas Python ayudan en las fases de dise\u00f1o, planificaci\u00f3n y prueba de un proyecto. Es f\u00e1cil seguir y entender el flujo de un programa si se mantiene todo en su lugar.</p> <p>En la animaci\u00f3n siguiente se provocan diversos errores de manera intencionada y se muestra la marca del error y la informaci\u00f3n que nos ofrece.</p> <p> <p> Resaltado de la estructura del c\u00f3digo</p> <p></p>"},{"location":"guias/pyt/#4-resaltado-de-errores","title":"4. Resaltado de errores","text":"<p>Los errores forman parte normal de la codificaci\u00f3n. Los s\u00edmbolos circulares junto al n\u00famero de l\u00ednea ayudan a identificar errores y corregirlos antes de enviar el c\u00f3digo a la micro:bit. Se puede pasar el cursor sobre el c\u00edrculo en el margen para que se muestre una explicaci\u00f3n del error. Repetimos aqu\u00ed la animaci\u00f3n previa donde hemos visto esto.</p> <p> <p> Resaltado de errores</p> <p></p>"},{"location":"guias/pyt/#5-autocompletar","title":"5. Autocompletar","text":"<p>El miedo a una pantalla en blanco y no saber qu\u00e9 escribir son dos de las mayores barreras para comenzar la codificaci\u00f3n basada en texto.</p> <p>Para ayudar con esto, a medida que escribe c\u00f3digo, el editor nos hace sugerencias que permiten elegir haciendo clic o presionando la tecla Intro. Esto ahorra tiempo, evita errores tipogr\u00e1ficos y evita tener que recordar de forma precisa una determinada sintaxis.</p> <p>Tambi\u00e9n es otra forma de descubrir qu\u00e9 pueden hacer Python y micro:bit, por ejemplo, al ver las opciones disponibles para mostrar im\u00e1genes ya definidas. Adem\u00e1s, si nos movemos con las flechas del teclado, por las opciones nos ir\u00e1n apareciendo a la derecha las descripciones de cada una de ellas.</p> <p> <p> Autocompletar</p> <p></p>"},{"location":"guias/pyt/#6-simulador","title":"6. Simulador","text":"<p>Permite probar el c\u00f3digo antes de grabarlo en la micro:bit real. Esto ayuda a desarrollar, probar, depurar y evaluar el c\u00f3digo y permite crear proyectos sin disponer fisicamente de la placa.</p> <p> <p> Simulador</p> <p></p>"},{"location":"guias/pyt/#7-ideas-y-api","title":"7. Ideas y API","text":"<p>En la pesta\u00f1a 'Ideas' hay programas completos listos para usar que se pueden modificar para crear los nuestros propios.</p> <p>El men\u00fa API (abreviatura de \"Application Programming Interfaces\" o \"interfaz de programaci\u00f3n de aplicaciones\") nos proporciona una descripci\u00f3n general m\u00e1s detallada de los comandos de MicroPython que se pueden usar con micro:bit. Esto puede ser \u00fatil cuando deseamos entender mejor lo que estamos haciendo en un trozo de c\u00f3digo en particular y qu\u00e9 opciones o argumentos se pueden usar con una funci\u00f3n.</p> <p> <p> Ideas y API</p> <p></p> <p>En la imagen siguiente tenemos un resumen de estos apartados.</p> <p> <p> Partes del editor explicadas en un gr\u00e1fico</p> <p></p>"},{"location":"guias/pyt/#uso-del-simulador","title":"Uso del simulador","text":"<p>La micro:bit que hay en la barra lateral de la derecha es un simulador. Si hacemos clic en reproducir podemos probar nuestro c\u00f3digo. Si el c\u00f3digo utiliza funciones como el aceler\u00f3metro, el sensor de temperatura, el sensor de luz (o cualquier otra funci\u00f3n de micro:bit), se pueden simular las condiciones necesarias para probar la micro:bit con los controles encontramos debajo. Tambi\u00e9n podemos usar la consola serie simulada para interactuar con la micro:bit simulada.</p> <p>En el video Simulator: micro:bit Python Editor enlazado de la documentaci\u00f3n vemos como se usa el simulador.</p>"},{"location":"guias/pyt/#flasheando-la-microbit","title":"Flasheando la micro:bit","text":"<p>Una vez comprobado el funcionamiento del programa tenemos todo listo para probarlo en la micro:bit real simplemente escogiendo 'Enviar a micro:bit'.</p> <p>El video Direct flashing from Python to micro:bit enlazado de la documentaci\u00f3n muestra los siguientes pasos si tenemos un navegador compatible con WebUSB.</p> <p>Si el navegador no soporta webUSB o no conseguimos una configuraci\u00f3n adecuada, como es mi caso utilizando Chomium tenemos que utilizar un m\u00e9todo alternativo para enviar el programa a la micro:bit.</p> <p> <p> Flasheando la micro:bit</p> <p></p>"},{"location":"guias/pyt/#abriendo-un-programa","title":"Abriendo un programa","text":"<p>Para abrir un programa, ya sea porque lo hemos guardado anteriormente o porque es de un tercero, hacemos clic en el bot\u00f3n 'Abrir'. En la ventana de di\u00e1logo que se amuestra seleccionamos el archivo '.hex' o '.py' que queremos abrir y luego hacemos clic en abrir. Alternativamente, podemos arrastrar y soltar un archivo '.hex' o un script '.py' en el editor.</p> <p> <p> Abriendo un programa</p> <p></p>"},{"location":"guias/pyt/#proyectos-configuracion-y-ayuda","title":"Proyectos, configuraci\u00f3n y ayuda","text":"<p>Las tres pesta\u00f1as de la parte inferior izquierda nos dan acceso a estas funcionalidades.</p> <ul> <li>Proyecto. La secci\u00f3n de proyectos, que se encuentra en el men\u00fa de la izquierda, es particularmente \u00fatil si necesitamos agregar archivos de Python adicionales al proyecto. Esto puede ser, por ejemplo, para agregar un m\u00f3dulo para un accesorio o para agregar un c\u00f3digo proporcionado por un tercero.</li> </ul> <p>Al hacer clic en el bot\u00f3n se enumeran todos los archivos .py del proyecto. Originalmente, solo habr\u00e1 un archivo con el nombre main.py que incluye el c\u00f3digo inicial que hemos tecleado en la parte central del editor.</p> <p>Si necesitamos un segundo archivo en el proyecto, podemos elegir 'Crear archivo' y ponerle un nombre, por ejemplo, lo podemos llamar 'ampliar' y se crear\u00e1 un nuevo archivo Python dentro del proyecto.</p> <p>Si por el contrario lo que queremos es abrir un archivo, procedente de un proveedor de accesorios o un tercero, hacemos clic el bot\u00f3n 'Abrir', localizamos el archivo en nuestro ordenador y lo abrimos. Se nos mostrar\u00e1 una ventana '\u00bfCambiar archivos? con una frase que empieza por \"Sustituir c\u00f3digo principal por ...\" y que finaliza con el nombre del archivo seleccionado. A la derecha de esta frase hay un icono que si lo clicamos nos va a permitir escoger entre las opciones de 'Sustituir c\u00f3digo' o 'A\u00f1adir archivo' para a\u00f1adirlo como archivo adicional. Este archivo adicional, que est\u00e1 dentro del proyecto, puede ser referenciado en main.py utilizando la funci\u00f3n 'import'.</p> <p>Si, por otro lado, queremos volver al c\u00f3digo original en alg\u00fan momento, por ejemplo porque se ha realizado un cambio en el programa existente y queremos restablecerlo, podemos usar el bot\u00f3n 'Restablecer proyecto' que est\u00e1 en la parte inferior. Pero cuidado porque esto reemplaza todo el c\u00f3digo, nos lleva de regreso al c\u00f3digo predeterminado y elimina cualquier archivo adicional a\u00f1adido.</p> <p> <p> Proyecto</p> <p></p> <p>El directorio donde se almacenan los proyectos es 'Descargas'.</p> <ul> <li>Configuraci\u00f3n. Se nos abre un men\u00fa donde podemos escoger entre 'Idioma' y 'Configuraci\u00f3n' que muestra una ventana con unas cuantas opciones de configuraci\u00f3n.</li> </ul> <p> <p> Configuraci\u00f3n</p> <p></p> <ul> <li>Ayuda. En esta pesta\u00f1a tenemos acceso a diferentes opciones como 'Ayuda y asistencia' que nos abre una web para consultas, 'Documentaci\u00f3n de MicroPython' que nos dirige a la wiki de referencia citada al principio del apartado, 'Comentarios' un sitio desde enviar nuestros propios comentarios, 'T\u00e9rminos de uso' que nos dirige a la web donde est\u00e1n definidos y 'Acerca de nosotros' que es el t\u00edpico Acerca de... que vemos en la ventana siguiente.</li> </ul> <p> <p> Acerca de nosotros</p> <p></p> <p>Es importante leer 'T\u00e9rminos de uso' donde est\u00e1 descrito todo lo que debemos tener en cuenta cuando se utiliza micro:bit y todo lo relacionado con la marca en los t\u00e9rminos indicados que adem\u00e1s debemos aceptar. Los t\u00e9rminos de uso se dan en 18 puntos.</p>"},{"location":"guias/pyt/#editando-codigo","title":"Editando c\u00f3digo","text":"<p>Para la creaci\u00f3n y edici\u00f3n de nuestros programas utilizaremos la ventana central del editor micro:bit MicroPython.</p> <p>En esta ventana nos ser\u00e1n de gran utilidad las caracter\u00edsticas de autocompletado, detecci\u00f3n de errores y la funcionalidad de los botones deshacer y rehacer que tambi\u00e9n permiten corregir errores.</p> <p> <p> Editando c\u00f3digo</p> <p></p> <p>En la imagen siguiente tenemos enmarcada con l\u00ednea verde discontinua la zona de edici\u00f3n de c\u00f3digo. Esta zona la podemos ampliar minimizando el men\u00fa de la izquierda (1), el men\u00fa de la derecha (4) o ajustando su anchura (2). Los iconos de zoom (3) permiten ampliar y reducir el tama\u00f1o del texto en la ventana y los controles deshacer/rehacer (5) tienen la funcionalidad habitual y permiten cierto nievel de edici\u00f3n.</p> <p> <p> Manejo del editor</p> <p></p>"},{"location":"guias/pyt/#primer-proyecto","title":"Primer proyecto","text":"<p>Para trabajar con Python en micro:bit necesitamos conocer la API de MicroPython que se trata en otro apartado y cuyo original podemos consultar en la webgrafia. Aqu\u00ed vamos a resumir muy brevemente el significado de las tres l\u00edneas de c\u00f3digo que compoenen el programa.</p> <p>Todo lo necesario para poder interactuar con el hardware lo tenemos en el m\u00f3dulo microbit y para facilitar su uso se recomienda iniciar todos los scripts con: <pre><code>from microbit import *\n</code></pre> La pantalla de LEDs se controla a partir del objeto display y sus m\u00e9todos, dos de los cuales usamos en el programa y que trabajan de la forma siguiente: <pre><code>display.clear() #Apaga todos los LEDs\ndisplay.show(0) #Muestra el n\u00famero entre par\u00e9ntesis\n</code></pre> Los n\u00fameros pueden tener mas de una cifra y si queremos mostrarlos como cadena de texto los encerramos entre comillas simples o dobles. L\u00f3gicamente en este caso podemos utilizar otros caracteres que no sean n\u00fameros.</p> <p>El primer proyecto lo tenemos disponible en los enlaces siguientes:</p> <ul> <li>Primer proyecto .hex</li> <li>Primer proyecto .py</li> </ul>"},{"location":"programacion/mkcode/","title":"MakeCode","text":"<p>De manera muy resumida lo que haremos en esta secci\u00f3n es:</p> <ul> <li>Describir los bloques y conceptos relacionados.</li> <li>Incluiremos esquemas si resultan necesarios.</li> </ul> <p>Se explican los bloques utilizados de los men\u00fas de bloques. Referencia a micro:bit reference The micro:bit APIs.</p>"},{"location":"programacion/mkcode/#comentarios","title":"Comentarios","text":"<p>Todo lenguaje de programaci\u00f3n contempla la posibilidad de realizar comentarios en el c\u00f3digo para que sirvan de aclaraci\u00f3n de para que sirve cada bloque en el programa, en especial en alguna parte que transcurrido un tiempo nos resulte complicada de entender.</p> <p>En MakeCode la forma de hacer comentarios es siempre sobre un bloque, as\u00ed que si Si necesitamos a\u00f1adir un comentario a un bloque desplegamos las opciones del bloque pinchando con el bot\u00f3n derecho y a\u00f1adimos un comentario pinchando en la entrada 'a\u00f1adir comentario'. Esto har\u00e1 que aparezca, en la esquina superior izquierda del bloque, un peque\u00f1o icono con forma de hoja escrita. Si pulsamos sobre este icono se despliega un peque\u00f1o editor, dimensionable y movible, donde podemos escribir nuestro comentario. En este editor hay un s\u00edmbolo de papelera que elimina el comentario actual. Esta opci\u00f3n est\u00e1 disponible tambi\u00e9n en el men\u00fa contextual, l\u00f3gicamente si se ha creado un comentario. En la animaci\u00f3n siguiente vemos el funcionamiento.</p> <p> <p> Comentarios</p> <p></p>"},{"location":"programacion/mkcode/#basico","title":"B\u00e1sico","text":"<p>En este grupo tenemos acceso a la funcionalidad b\u00e1sica de la micro:bit.</p> <ul> <li>al iniciar. Se trata del bloque de la imagen y es un bloque que se ejecuta una sola vez cuando se inicia la micro:bit. Es uno de los dos bloques que aparecen al principio cuando escogemos Restablecer o creamos un nuevo proyecto desde Mis proyectos.</li> </ul> <p> <p> Bloque 'al iniciar'</p> <p></p> <ul> <li>para siempre. Se trata del bloque de la imagen y es un bloque que se ejecuta de manera infinita. Es el otro de los dos bloques que aparecen al principio cuando escogemos Restablecer o creamos un nuevo proyecto desde Mis proyectos.</li> </ul> <p> <p> Bloque 'para siempre'</p> <p></p> <ul> <li>mostrar cadena. Muestra la cadena de texto en la pantalla caracter a caracter. En la imagen la palabra es Hello.</li> </ul> <p> <p> Bloque 'mostrar cadena'</p> <p></p> <ul> <li>mostrar icono. Dibuja el icono seleccionado en la pantalla.</li> </ul> <p> <p> Bloque 'mostrar icono'</p> <p></p> <ul> <li>borrar la pantalla. Apaga todos los LEDs.</li> </ul> <p> <p> Bloque 'borrar la pantalla'</p> <p></p> <ul> <li>pausa (ms). Detiene la ejecuci\u00f3n del programa el tiempo establecido en milisegundos.</li> </ul> <p> <p> Bloque 'pausa (ms)'</p> <p></p>"},{"location":"programacion/mkcode/#pantalla-led","title":"Pantalla LED","text":"<p>Control de la pantalla LED.</p> <ul> <li>ajustar brillo. Configura el brillo de la pantalla desde 0 (apagada) a 255 (m\u00e1ximo brillo). Los bloques de pantalla posteriores a este tendr\u00e1n el brillo establecido hasta que no se cambien el valor a otro distinto.</li> </ul> <p> <p> Bloque 'ajustar brillo'</p> <p></p> <ul> <li>graficar x,y,brillo. Enciende el LED indicado en la coordenada x,y con el brillo especificado. La coordenadas x es la horizontal y la y es la vertical. La coordenada 0,0 es la esquina superior ezquierda, la 0,4 es la derecha, la 4,0 es la inferior izquierda y la 4,4 la inferior derecha.</li> </ul> <p> <p> Bloque 'graficar x,y,brillo'</p> <p></p>"},{"location":"programacion/mkcode/#arrays-o-arreglos","title":"Arrays o arreglos","text":"<p>Se van a utilizar para agregar, eliminar y sustituir elementos en listas. En MakeCode las listas se nombran indistintamente como array, matriz o lista y tienen su propio men\u00fa de bloques que es visible cuando desplegamos 'Avanzado'. Los bloques existentes est\u00e1n clasificados en los siguientes grupos:</p> <p></p> <p>Create Leer Modificar Operaciones</p> <p>Describiremos estos grupos de forma somera porque esta es suficiente para entender lo que hace el bloque. No obstante, algunos se describen de manera mas explicita.</p> <p></p> <p>Create</p> <ul> <li>fijar 'nn' a. Le da a la variable el valor de la entrada, para valores num\u00e9ricos.</li> <li>fijar 'tt' a. Le da a la variable el valor de la entrada, para texto.</li> <li>matriz vacia. Crea una lista con los elementos que introduzcamos con el '+'.</li> </ul> <p>Volver </p> <p></p> <p>Leer</p> <ul> <li>longitud del arreglo. Devuelve el n\u00famero de elementos de una lista.</li> <li>obtener el valor en 'x'. Obtiene el valor del elemento 'x'.</li> <li>eliminar el valor en 'x'. Elimina el elemento 'x' de la lista.</li> <li>obtener y eliminar el \u00faltimo valor de (<code>pop</code>). Elimina y devuelve el \u00faltimo elemento de una matriz. Se elimina el \u00faltimo elemento de la matriz, por lo que la matriz se reduce en un elemento.</li> <li>obtener y eliminar el primer valor de (<code>shift</code>). Elimina y devuelve el primer elemento de una matriz. Se elimina el primer elemento de la matriz, por lo que la matriz se reduce en un elemento.</li> <li>obtener valor aleatorio. Devuelve un valor al azar de la matriz.</li> </ul> <p>Volver </p> <p>Modificar</p> <ul> <li>establecer el valor en 'x' a 'nn'. Estable el valor del elemento 'x' al valor indicado en 'nn'.</li> <li>a\u00f1adir valor 'nn' al final (<code>push</code>). A\u00f1ade un nuevo elemento al final de una matriz.</li> <li>eliminar el \u00faltimo valor de. Elimina el \u00faltimo elemento de la matriz y lo devuelve.</li> <li>eliminar el primer valor de. Elimina el primer elemento de la matriz y lo devuelve.</li> <li>insertar 'nn' al principio (<code>unshift</code>). A\u00f1adir un elemento al principio de una matriz y devolver la nueva longitud de la matriz.</li> <li>insertar en 'x' valor 'nn' (<code>insertAt</code>). Inserta el valor 'nn' en la posici\u00f3n espe\u00edfica indicada por 'x' aumentando la longitud del array en uno. El elemento se agrega a la matriz en la posici\u00f3n que indiquemos. Si ya hay un elemento en esa posici\u00f3n, entonces \u00e9l y todos los elementos posteriores se desplazan a la posici\u00f3n superior siguiente.</li> <li>eliminar valor en 'x' (<code>removeAt</code>). Elimina el elemento que hay en la posici\u00f3n 'x'. El tama\u00f1o de la matriz se reduce en uno. El elemento se elimina de la matriz en la posici\u00f3n que indiquemos. Todos los dem\u00e1s elementos posteriores se desplazan hacia abajo a la posici\u00f3n inferior siguiente.</li> </ul> <p>Volver </p> <p>Operaciones</p> <ul> <li>bloque encontrar indice de (<code>IndexOf</code>). Devuelve la posici\u00f3n o \u00edndice de la primera aparici\u00f3n de un valor en una matriz. Devuelve un n\u00famero, que es la posici\u00f3n en la matriz del elemento. El resultado es -1 si no se encuentra ninguna coincidencia.</li> <li>invertir (<code>reverse</code>). Invertir los elementos de una matriz.</li> </ul>"},{"location":"programacion/mkcode/#variables","title":"Variables","text":"<p>Cuando vamos a utilizar bucles, estos siempre llevan asociada una variable, y por eso debemos aprender a gestionar el tema de las variables en MakeCode. Las variables tienen su propio men\u00fa y es relativamente sencillo de usar. Como ya se ha dicho, una variable es un espacio en la memoria donde el programa puede almacenar valores. El sistema nos permite asignarles un nombre simb\u00f3lico como por ejemplo \u201ctemperatura\u201d, \u201cvelocidad\u201d, \u201destado\u201d,\u2026 para facilitar su uso.</p> <p>Cuando accedemos al men\u00fa 'Variables' por primera vez y si no hemos pues ning\u00fan bloque en el \u00e1rea de programa, el aspecto del men\u00fa es el siguiente:</p> <p> <p> Variables en MakeCode</p> <p></p> <p>Veamos como funciona la creaci\u00f3n de una variable, cambiarle el nombre, eliminarla y dem\u00e1s tareas que podemos hacer con ellas. En la animaci\u00f3n siguiente vemos el proceso de crear y poner nombre a una variable. Vemos que al hacer clic en el bot\u00f3n se abre una ventana de di\u00e1logo donde nos pide el nombre, que tecleamos seg\u00fan las reglas establecidas, y que al hacer clic en 'Aceptar' se nos crean tres bloques, dos para trabajar con la variable creada y uno que es la propia variable, todos ellos con el nombre que hemos puesto a esa variable.</p> <p> <p> Creaci\u00f3n de una variable en MakeCode</p> <p></p> <p>El bloque 'fijar' sirve para inicializar la variable al valor especificado, el bloque 'cambiar' es el equivalente al operador '+=' con el incremento que establezcamos en 'por' y el \u00faltimo bloque es el valor de la variable.</p> <p>Al final de la animaci\u00f3n tambi\u00e9n vemos que al hacer clic en la flechita de cualquiera de los bloques se despliega un men\u00fa en el que aparece la variable, la opci\u00f3n de crear otra nueva, renombrarla o borrar la variable que est\u00e1 seleccionada en ese momento. En la animaci\u00f3n siguiente vemos estos aspectos en funcionamiento.</p> <p> <p> Trabajo con el men\u00fa desplegable en una variable en MakeCode</p> <p></p> <p>Cuando pasamos por el men\u00fa de bloques vemos que 'fijar' y 'cambiar' no se vuelven a crear cuando creamos nuevas variables ya que est\u00e1n todas en el desplegable y lo \u00fanico que tenemos que hacer es seleccionarlas. Si se crea, en cambio, un bloque para el contenido de cada variable. Tambi\u00e9n vemos que si eliminamos una variable que est\u00e1 en uso en varios sitios se elimina, preva advertencia, de todos ellos.</p> <p>Ahora bien, la variables como tal se eliminan de la zona de programa pero no del men\u00fa 'Variables, donde siguen estando disponibles hasta que las eliminemos, tarea que solamente es posible hacer desde alguno de los bloques situado en la zona de programa.</p>"},{"location":"programacion/mkcode/#bucles","title":"Bucles","text":"<p>Bloque for Bloque while Bloque cada 'nn' ms Bloques salir y continuar</p> <p> Bloque for Son bloques que repiten el c\u00f3digo asociado un n\u00famero determinado de veces, Lo pueden hacer utilizando una variable como \u00edndice o estableciendo el n\u00famero exacto de veces.</p> <p>El aspecto del bloque para recorrer con una variable lo vemos en la imagen siguiente:</p> <p> <p> Bloque for en MakeCode</p> <p></p> <p>Cuando llevamos el bloque a la zona de programa se crear\u00e1 una variable index, salvo que esta ya exista. Un bloque como el siguiente crear\u00e1 un contador con la variable i desde 0 hasta 4 y mostrar\u00e1 los n\u00fameros 0 al 9 uno tras otro en la pantalla LED.</p> <p> <p> Contador de 0 a 9</p> <p></p> <p>Una variedad de este bloque la tenemos en el bloque 'repetir' para el n\u00famero de veces que indiquemos, que tiene el aspecto que vemos en la figura siguiente.</p> <p> <p> Bloque repetir nn veces</p> <p></p> <p>En el ejemplo siguiente, cuando se inicia el dispositivo, se producen tres efectos de latido de un coraz\u00f3n.</p> <p> <p> Ejemplo de uso del bloque repetir nn veces</p> <p></p> <p>Otro bloque que utiliza el bucle for es el que vemos en la imagen siguiente, un bloque pensado para repetir el c\u00f3digo para cada valor de los contenidos en una lista.</p> <p> <p> Bucle for para elementos de una lista</p> <p></p> <p>En la imagen siguiente vemos un programa que utiliza este bloque. Hemos creado una lista aleatoria de valores y el programa lo que hace es encontrar y mostrar el mayor de ellos. El funcionamiento del programa lo leemos asi: se crea una variable <code>mayor</code> para guardar el valor del elemento de la lista de mayor valor, la matriz le hemos dejado el nombre <code>lista</code> y para recorrerla se utiliza la variable <code>valor</code>. El condicional (los veremos en una actividad posterior) va comprobando si <code>valor &gt; mayor</code> y mientras sea cierto se guarda en <code>mayor</code> el <code>valor</code> leido y si no es cierto se contin\u00faa con el siguiente elemento de la lista. Una vez finalizado el condicional se mestra la cadena con la variable <code>mayor</code>.</p> <p> <p> Ejemplo de bucle for para elementos de una lista</p> <p></p> <p>Volver </p> <p>Bloque while</p> <p>Se trata de un bloque que repite su bloque de c\u00f3digo mientras la condici\u00f3n sea cierta (<code>True</code>). Su aspecto lo vemos en la imagen siguiente.</p> <p> <p> Bucle while</p> <p></p> <p>El bucle while tiene una condici\u00f3n que se eval\u00faa con un valor <code>booleano</code>. La condici\u00f3n se comprueba antes de que se ejecute ning\u00fan c\u00f3digo. Lo que significa que si la condici\u00f3n es falsa la primera vez que se eval\u00faa, el c\u00f3digo dentro del bucle no se ejecuta n\u00fanca.</p> <p>Con el bloque tal cual es solamente podemos establecer la condici\u00f3n como <code>True</code> o <code>False</code>, lo que es muy poca cosa. Es evidente que podr\u00e1 tener mucha mas potencia si recurrimos a condiciones mas complejas y utilizamos los operadores. Este apartado no lo vamos a estudiar en este momento, pero si diremos que estos bloques est\u00e1n en el men\u00fa 'L\u00f3gica' y su funcionamiento es el mismo que en visto en Python -&gt; Introducci\u00f3n.</p> <p>Como ejemplo vamos a ver como dibujar una l\u00ednea diagonal en los LEDs [(0,0) - (1,1) - (2,2) - (3,3) - (4,4) y (5,5)] de la pantalla. En la imagen vemos el programa final, donde observamos que la condici\u00f3n va a ser cierta hasta que index alcance el valor 4, por lo que se va a ir encendiendo cada LED a intervalos de un segundo. Esto solamente va a ocurrir cuando se inicia el disposiivo, aunque en este ejemplo concreto esto no tiene importancia.</p> <p> <p> Programa bucle while</p> <p></p> <p>Volver </p> <p>Bloque cada 'nn' ms Repite el c\u00f3digo en segundo plano de forma contnuada en el intervalo de tiempo que se indique. Establecemos la cantidad de tiempo que el bucle espera antes de que el c\u00f3digo en su interior se ejecute de nuevo. Esto es similar a un bucle \"forever\" (por siempre), en el sentido de que se ejecuta continuamente, excepto que hay un intervalo de tiempo establecido para esperar antes de que el bucle se ejecute la pr\u00f3xima vez. El bloque es muy \u00fatil si, por ejemplo, queremos estar comprobando cada cierto tiempo si ocurre un evento, como pulsar una tecla, escuchar un sonido, etc.</p> <p>En la imagen siguiente vemos el aspecto que tiene el bloque.</p> <p> <p> Bloque cada 'nn' ms</p> <p></p> <p>Volver </p> <p>Bloques salir y continuar  Son los bloques equivalentes a las sentencias <code>break</code> y <code>continue</code> en MicroPython y funcionan exactamente igual, es decir, el bloque 'salir' permite salir de un bucle de forma inmediata y el bloque 'continuar' sirve para saltarse la iteraci\u00f3n actual del bucle.</p> <p>Los bloques tienen el aspecto que vemos en la imagen.</p> <p> <p> <code>break</code> y <code>continue</code></p> <p></p>"},{"location":"programacion/mkcode/#operadores-de-comparacion-y-booleanos","title":"Operadores de comparaci\u00f3n y booleanos","text":"<p>Como sabemos un valor booleano solamente puede tomar uno de dos valores posibles: <code>True (verdadero)</code> o <code>False (falso)</code>. Estos bloques los encontramos en la entrada 'L\u00f3gica' y son:</p> <p> <p> Valores booleanos</p> <p></p> <p>Los dos bloques existen de forma separada, pero cada uno de ellos puede adoptar el valor contrario al que muestra por defecto seleccionandolo con la flechita.</p> <p>Los operadores booleanos u operadores l\u00f3gicos son AND, OR y NOT y son operadores que a partir de valores de entrada booleanos crean otro valor tambi\u00e9n booleano. Estos bloques tambi\u00e9n los encontramos en la entrada 'L\u00f3gica' y son:</p> <p> <p> Operadores booleanos</p> <p></p> <p>A continuaci\u00f3n vemos una serie de bloques con operadores que satisfacen la condici\u00f3n.</p> <p> <p> Operadores booleanos</p> <p></p> <p>Tanto los valores booleanos como los operadores se usan con instrucciones <code>if</code> o <code>while</code> para determinar qu\u00e9 c\u00f3digo se ejecutar\u00e1 a continuaci\u00f3n. Por ejemplo:</p> <p> <p> Bucle <code>while</code> con una condici\u00f3n</p> <p></p> <p>En el siguiente ejemplo se utilizan operadores booleanos en el bucle.</p> <p> <p> Bucle <code>while</code> con una condici\u00f3n y operadores booleanos</p> <p></p>"},{"location":"programacion/mkcode/#sentencia-condicional-ifelifelse","title":"Sentencia condicional <code>if...elif...else</code>","text":"<ul> <li><code>if</code>. Ejecuta c\u00f3digo dependiendo de si una condici\u00f3n booleana es verdadera o falsa. El c\u00f3digo dentro del bloque <code>if</code> s\u00f3lo se ejecuta cuando el bloque <code>condici\u00f3n</code> es verdadero.</li> </ul> <p> <p> Condicional <code>if</code></p> <p></p> <p>Se pueden comparar variables con valores o variables con variables, para una condici\u00f3n verdadera o falsa.</p> <ul> <li><code>else</code>. Si necesitamos que se ejecute alg\u00fan otro c\u00f3digo cuando la condici\u00f3n del <code>if</code> no sea verdadera, lo ponemos en un \u00e1rea de bloque adicional llamada <code>else</code> (si no).</li> </ul> <p> <p> Condicional <code>if...else</code></p> <p></p> <p>Un condicional como el siguiente se podr\u00eda leer como: \"<code>si</code> tengo dinero por encima de una cantidad, <code>entonces</code> estoy feliz y <code>si no</code> estoy triste.</p> <p> <p> Condicional <code>if...else</code></p> <p></p> <p>Cambiando el valor asignado a dinero vemos el funcionamiento.</p> <p>La clausula <code>else</code> se a\u00f1ade al condicional <code>if</code> haciendo clic en el signo '+'.</p> <ul> <li><code>if...else if</code>. Condici\u00f3n <code>if</code> que si resulta falsa se evalua una nueva condici\u00f3n puesta en <code>elif</code>. Otra acci\u00f3n condicional es a\u00f1adir un <code>if</code> a un <code>else</code> para obtener un <code>else if</code>. Funciona as\u00ed</li> </ul> <p> <p> Condicional <code>if...else if</code></p> <p></p> <p>Hacemos clic en el s\u00edmbolo m\u00e1s '+' para a\u00f1adir secciones <code>else</code> o <code>else if</code> al bloque <code>if</code> actual.</p>"},{"location":"programacion/mkcode/#texto","title":"Texto","text":"<p>Si expandimos el men\u00fa 'Avanzado' nos encontraremos con una entrada 'Texto' que vamos a describir en esta actividad.</p> <ul> <li> Una letra, palabra o l\u00ednea de texto que puede contener letras, n\u00fameros y caracteres.</li> <li> Devuelve el n\u00famero de caracteres de la cadena de texto.</li> <li> A\u00f1ade una cadena de texto a otra para crear una cadena mas larga. Se pueden a\u00f1adir mas cadenas.</li> <li> Convierte un texto que s\u00f3lo tiene caracteres num\u00e9ricos en un valor num\u00e9rico de coma flotante. Se puede convertir una cadena de texto con caracteres num\u00e9ricos en un valor real de coma flotante. El texto debe tener s\u00f3lo caracteres num\u00e9ricos. Aunque tambi\u00e9n puede incluir los s\u00edmbolos '-' y '.'. Si el texto tiene otros caracteres, como \"-5.8g5u7\", s\u00f3lo se devuelve -5.8 ya que es el mejor intento de conversi\u00f3n a un n\u00famero. Por lo tanto, hay que no mezclar caracteres num\u00e9ricos con letras u otros s\u00edmbolos.</li> </ul> <p>Potencias de 10. Si la cadena de texto tiene la letra 'e' despu\u00e9s de los caracteres num\u00e9ricos y luego algunos caracteres num\u00e9ricos m\u00e1s como \"2e4\", entonces los caracteres num\u00e9ricos despu\u00e9s de la 'e' son un exponente de 10. Esto significa que una cadena con \"7.5e2\" se convierte en el valor de 750 cuando se convierte a un n\u00famero de coma flotante. Esto se debe a que el 2 despu\u00e9s de la 'e' indica 10\u00b2, lo que equivale a <code>10 * 10 =  100</code>. El valor resultante es entonces 7.5 * 100 que es igual a 750. En el siguiente ejemplo se toman los primeros d\u00edgitos de PI de la frase \"pi vale 3.141592\" y los convierte en un n\u00famero.</p> <p> <p> Extraer PI de una cadena</p> <p></p> <p>Descargar el programa</p> <ul> <li> Divide una cadena en cadenas m\u00e1s peque\u00f1as utilizando un caracter (una cadena) de separaci\u00f3n para dividir la cadena m\u00e1s grande.</li> <li> Determina si una cadena contiene los caracteres de una cadena especificada.</li> <li> Obtiene la posici\u00f3n (\u00edndice) de la primera aparici\u00f3n de un valor especificado en una cadena.</li> <li> Determina si una cadena de texto contiene caracteres o no. TODO</li> <li> Toma una parte de la cadena \"this\" para hacer una cadena m\u00e1s peque\u00f1a (subcadena). * Si una cadena tiene una parte que est\u00e1 copiada de otra cadena, se llama subcadena. Se puede crear una nueva cadena que s\u00f3lo contenga la palabra \"aqu\u00ed\" a partir de una cadena mayor que diga \"\u00a1Hola, estamos aqu\u00ed!\". Para ello, la subcadena se copia desde la posici\u00f3n de car\u00e1cter 15 en la primera cadena y se copian 4 caracteres. Se hace as\u00ed: . En el ejemplo se copian los sustantivos de la frase en dos cadenas m\u00e1s peque\u00f1as.</li> </ul> <p> <p> Extraer de cadena a subcadenas</p> <p></p> <p>Descargar el programa</p> <ul> <li> Se comparan dos cadenas de texto en funci\u00f3n de los caracteres que aparecen en primer lugar. Dos cadenas se comparan en funci\u00f3n del orden de sus caracteres. Si la cadena \"A\" vale \"111\" ser\u00e1 menor que una cadena con \"512\". Una cadena con \"Everything (Todo)\" es menor que \"Nothing (Nada)\" porque la 'N' viene despu\u00e9s de la 'E' en el alfabeto. La cadena \"abcdefg\" es mayor que \"abcdefa\". Son casi iguales, pero la \u00faltima letra de la segunda cadena es menor que la \u00faltima letra de la primera. Esto hace que toda la segunda cadena se compare como menor. En bloques, la comparaci\u00f3n de estas cadenas tiene el siguiente aspecto:</li> </ul> <p> <p> Comparar cadenas</p> <p></p> <ul> <li> Obtiene un car\u00e1cter (letra, n\u00famero o s\u00edmbolo) de un lugar de la cadena de texto. Podemos averiguar qu\u00e9 car\u00e1cter se encuentra en cualquier lugar de un texto. Puedes tener un texto que diga \"Hello there!\". El car\u00e1cter en la posici\u00f3n 6 es 't'. La palabra \"Hello\" m\u00e1s el espacio tienen las posiciones 0 - 5, as\u00ed que, 't' est\u00e1 en la posici\u00f3n 6. Para obtener el car\u00e1cter en esta posici\u00f3n, la letra 't', se podr\u00eda usar un bloque como este:</li> </ul> <p> <p> Extraer caracter de una cadena</p> <p></p> <ul> <li> Convierte el valor de cualquier tipo de dato a una cadena de texto. El siguiente ejemplo convierte un valor booleano y un valor num\u00e9rico en cadenas y las une en una cadena o frase.</li> </ul> <p> <p> Convertir valores booleanos y num\u00e9ricos en cadena</p> <p></p> <p>Descargar el programa</p> <ul> <li> Hacer que una cadena de un caracter sea representada a partir del c\u00f3digo num\u00e9rico que le asignemos. Al igual que el c\u00f3digo ASCII es un juego de caracteres que asigna un valor a cada uno de ellos, nosotros podemos crear nuestro propio c\u00f3digo asign\u00e1ndole un c\u00f3digo con este bloque. Por ejemplo, hacer que la letra B sea: </li> </ul>"},{"location":"programacion/mkcode/#bloques-de-entrada-para-los-botones","title":"Bloques de 'Entrada' para los botones","text":"<p>Cuando presionamos los botones A y/o B ocurre un evento (se ha presionado un bot\u00f3n). Este tipo de acci\u00f3n se considera una entrada a la microbit y tenemos bloques para manejarlo.</p> <ul> <li>al presionar el bot\u00f3n</li> </ul> <p>Presionar un bot\u00f3n inicia un manejador de eventos, que es una parte del programa que se ejecutar\u00e1 cuando ocurra algo, como por ejemplo,  cuando se pulsa un bot\u00f3n. Este manejador funciona cuando se pulsa el bot\u00f3n A o B, o A y B al mismo tiempo.Cuando estemos utilizando esta funci\u00f3n en un navegador, pulsaremos los botones de la pantalla en lugar de los del micro:bit.</p> <ul> <li>Para el bot\u00f3n A o B: Este manejador de evento funciona cuando el bot\u00f3n se pulsa y se suelta en menos de un segundo.</li> <li>Para A y B juntos: Este manejador funciona cuando A y B son presionados simultanemente. Disponemos de un segundo y medio desde que pulsamos el primer bot\u00f3n hasta que pulsamos el seg\u00fando para que se consideren ambos pulsados a la vez.</li> </ul> <p> <p> Bloque 'Al presionar el bot\u00f3n...'</p> <p></p> <p>En el siguiente ejemplo se cuenta cu\u00e1ntas veces se pulsa el bot\u00f3n A. Cada vez que se pulsa el bot\u00f3n, la pantalla LED muestra la variable de recuento que cada vez ser\u00e1 mayor.</p> <p> <p></p> <p>Contar pulsaciones de A</p> <p></p> <p>Descargar el programa</p> <p>En el ejemplo siguiente se simula un dado mostrando un n\u00famero del 1 al 6 cuando pulsamos el bot\u00f3n B. En el programa se utiliza el bloque de generaci\u00f3n de n\u00famero aleatorios entre dos valores dados que podemos encontrar en el men\u00fa 'Matem\u00e1ticas'.</p> <p> <p></p> <p>Dado</p> <p></p> <p>Descargar el programa</p> <ul> <li>bot\u00f3n A o B presionado</li> </ul> <p>El bloque siguiente comprueba si se est\u00e1 pulsando un bot\u00f3n en ese momento.</p> <p> <p></p> <p>Se ha presionado el bot\u00f3n</p> <p></p> <p>Un sencillo ejemplo nos aclara como funciona el bloque.</p> <p> <p></p> <p>Bot\u00f3n A presionado</p> <p></p> <p>Descargar el programa</p> <ul> <li>al pulsar el logotipo  (solo en versiones V2)</li> </ul> <p>El logo de micro:bit V2 act\u00faa como un bot\u00f3n t\u00e1ctil, por lo que es un actuador de entrada que cuando lo pulsamos (tocamos) se ejecuta su c\u00f3digo y cuando lo soltamos (no lo tocamos) deja de hacerlo.</p> <p> <p></p> <p>Bot\u00f3n t\u00e1ctil</p> <p></p> <p>El bloque funciona solamente con micro:bit V2 y si lo usamos con una placa V1 nos generar\u00e1 el c\u00f3digo de error 927 en la pantalla.</p> <ul> <li>el logotipo est\u00e1 pulsado  (solo en versiones V2)</li> </ul> <p>Comprueba si se est\u00e1 pulsando el logotipo de micro:bit. Utilizamos el valor booleano del estado de la pulsaci\u00f3n del logo para tomar una decisi\u00f3n l\u00f3gica en el programa.</p> <p>El ejemplo muestra una u otra imagen en funci\u00f3n de si se ha pulsado el logo o no.</p> <p> <p></p> <p>Logo presionado</p> <p></p> <p>Descargar el programa</p>"},{"location":"programacion/mkcode/#pines","title":"Pines","text":"<p>MakeCode dispone de bloques para controlar la corriente en los pines tanto para se\u00f1ales anal\u00f3gicas como digitales, servos, dispositivos i2c,...</p> <ul> <li>. Lee el valor de una se\u00f1al digital (0 o 1) desde el pin de la placa micro:bit. Los pines disponibles para el bloque son:</li> </ul> <p> <p></p> <p>Pines para lectura digital</p> <p></p> <ul> <li>. Escribe el valor de una se\u00f1al digital (0 o 1) en un pin de la placa micro:bit. Los pines disponibles para escritura digital son los mismos que para lectura digital.</li> <li>. Lee una se\u00f1al anal\u00f3gica (0 a 1023) desde el pin indicado. Los pines disponibles son:</li> </ul> <p> <p></p> <p>Pines para escritura digital</p> <p></p> <ul> <li>. Escribe una se\u00f1al anal\u00f3gica (0 a 1023) en el pin indicado. Los pines disponibles son los indicados para la lectura anal\u00f3gica.</li> <li>. Configura el periodo de la modulaci\u00f3n por anchura de pulso o PWM de la salida anal\u00f3gica en microsegundos. Antes de llamar a esta funci\u00f3n debemos configurar el pin indicado como anal\u00f3gico. Tenemos los mismo pines disponibles que para la lectura y escritura.</li> <li>El bloque siguiente es un bloque de lo que se conoce como mapeo. El mapeo consiste en reasignar un valor especificado dentro de un rango a otro rango diferente. Es com si hacemos un cambio de escala de los valores. La funci\u00f3n no limita los valores de los rangos, porque los valores fuera de rango a veces est\u00e1n previstos y son \u00fatiles. Si necesitamos limitar un rango, podemos utilizar la funci\u00f3n 'restringir' de 'Matem\u00e1ticas'.</li> </ul> <p> <p></p> <p></p> <p>Por ejemplo, el programa siguiente cambia los valores anal\u00f3gicos recibidos en el pin P0 de absolutos a porcentaje.</p> <p> <p></p> <p>Mapeo de valores</p> <p></p> <ul> <li>El bloque siguiente configura el pin indicado como una entrada digital y genera un evento cuando el pin es tocado, tanto alto como bajo. Este bloque no se puede simular y requiere hardware real para probarlo.</li> </ul> <p> <p></p> <p></p> <p>A continuaci\u00f3n vemos los pines que se pueden configurar en el bloque.</p> <p> <p></p> <p>Pines para el bloque cuando el pin nn es pulsado</p> <p></p> <ul> <li>. Obtiene la duraci\u00f3n del pulso en microsegundos.</li> <li>. Devuelve la duraci\u00f3n de un pulso en microsegundos.</li> <li>. Configura el pull del pin indicado. Hay muchos pines que se pueden configurar con pull-up. Por ejemplo, podemos establecer el valor de tensi\u00f3n de un pin a 3.3V o un \"1\" l\u00f3gico.</li> <li>. Emite una se\u00f1al PWM al pin actual.</li> <li>. Establece el pin que se utiliza para un tono musical anal\u00f3gico.</li> </ul>"},{"location":"programacion/mkcode/#programar-neopixels","title":"Programar Neopixels","text":"<p>Los diodos LED RGB WS2812, o NeoPixel en el lenguaje de Adafruit, integran en un solo chip los diodos LEDs rojo, verde y azul junto con un chip controlador en un \u00fanico encapsulado y son controlados a trav\u00e9s de un \u00fanico cable. Pueden utilizarse individualmente, encadenados en cadenas m\u00e1s largas o ensamblados en otros formatos.</p> <p>Existen multitud de formatos basados en Neopixels, algunos son: cosibles (weareables en genral), tiras, matrices, anillos, joyas, etc.</p> <p></p> <p>A\u00f1adir extensi\u00f3n NeoPixel Programar Neopixels Arcoiris Rotar LEDs Encender espec\u00edfico o aleatorio Trazar diagrama de barras Dentro de un rango Cambio sentido desplazamiento por posici\u00f3n Personalizar colores RGB</p> <p> A\u00f1adir extensi\u00f3n NeoPixel</p> <p>Estando situados en https://makecode.microbit.org/ hacemos clic en Extensiones y se nos mostrar\u00e1 en el navegador un listado de extensiones recomendadas con una barra de b\u00fasqueda y otras opciones para ver extensiones por temas. En cada una de ellas nos encontraremos con un enlace 'Learn More' para aprender mas sobre la extensi\u00f3n y acceder a ejemplos que la utilizan.</p> <p> <p> Extensiones para MakeCode</p> <p></p> <p>Si aparece en la pantalla (es mi caso) simplemente hacemos clic sobre la extensi\u00f3n y si no la escribimos en la barra de b\u00fasqueda y una vez localizada hacemos clic sobre la misma.</p> <p>Ahora deber\u00edamos tener un nuevo conjunto de bloques NeoPixel en la caja de herramientas de MakeCode. Estos bloques se guardan con el proyecto actual, pero hay que a\u00f1adirlos de nuevo para otros proyectos.</p> <p> <p> Extensi\u00f3n Neopixels a\u00f1adida</p> <p></p> <p>Ya estamos listos para comenzar a programar con los bloques de la extensi\u00f3n.</p> <p>Volver </p> <p>Programar Neopixels</p> <p>Una vez instalada la extensi\u00f3n NeoPixel, podemos empezar a programar con los bloques espec\u00edficamente dise\u00f1ados para controlar los LEDs. Lo primero que hay que hacer es informar a MakeCode sobre el NeoPixel conectado. Esto es lo que se conoce como inicializar o configurar el entorno de programaci\u00f3n y hay muchos componentes que lo requieren, los Neopixel son uno de ellos. Esta configuraci\u00f3n hay que hacerla en un bloque 'al iniciar'. Hay que indicar:</p> <ul> <li>N\u00famero de LEDs.</li> <li>El pin al que tenemos conectados los NeoPixels.</li> <li>Salvo que estemos usando LEDs blancos el formato ser\u00e1 RGB.</li> </ul> <p>El bloque de configuraci\u00f3n inicial es:</p> <p> <p> Bloque de configuraci\u00f3n inicial</p> <p></p> <p>Con este bloque configurado, MakeCode inicializar\u00e1 el dispositivo NeoPixel cada vez que se ejecute el programa. Si conectamos m\u00e1s de un NeoPixel, MakeCode generar\u00e1 autom\u00e1ticamente bloques de conjuntos como el anterior, y los nombrar\u00e1 strip2, strip3, etc... L\u00f3gicamente podemos renombrar las tiras como queramos.</p> <p>Vamos a describir brevemente unos bloques m\u00ednimos para comenzar a trabajar.</p> <ul> <li>. Establece el color indicado para la tira seleccionada. Por defecto el bloque est\u00e1 configurado con otro bloque que permite escoger entre una gama b\u00e1sica de colores.</li> </ul> <p> <p> Colores b\u00e1sicos en el bloque 'color'</p> <p></p> <ul> <li>. Bloque color con la gama b\u00e1sica de colores para seleccionar.</li> <li>. Bloque para configurar el color en formato HLS.</li> <li>. Establecer la luminosidad de los LEDs.</li> <li>. Mostrar la informaci\u00f3n programada en los Neopixels conectados.</li> </ul> <p>Veamos un primer ejemplo sencillo que nos aclare estos conceptos. Se trata de configuar y poner un anillo de 8 LEDs en diferentes colores a intervalos de 1s. El anillo se alimenta a 5V por lo que escogemos el esquema de montaje de baja potencia y dispositivo con alimentaci\u00f3n a 5V.</p> <p> <p> Conexionado para dispositivo 5V y bajo consumo</p> <p></p> <p>El programa puede ser similar al siguiente:</p> <p> <p> Ejemplo b\u00e1sico con cambio entre varios colores</p> <p></p> <p>Podemos observar como directamente el simulador se ha configurado y conectado seg\u00fan la definici\u00f3n realizada. Se conecta a una tira de 8 LEDs simulados. En la animaci\u00f3n observamos al simulador en funcionamiento seg\u00fan el programa anterior. Observamos que el color negro se representa en gris a efectos de la simulaci\u00f3n, en la realidad corresponde a todos los LEDs apagados.</p> <p>Descargar el programa</p> <p> <p> Funcionamiento del ejemplo b\u00e1sico con cambio entre varios colores</p> <p></p> <p>En el programa se observa el bloque de configuraci\u00f3n de la luminosidad como se establece al principio. Se insta al lector a realizar modificaciones del par\u00e1metro para ver su efecto en un circuito real.</p> <p>Vamos a ver otro ejemplo en el que vamos a ir cambiando los colores seg\u00fan el formato HSL, en concreto vamos a recorrer la rueda de colores seg\u00fan el matiz para una saturaci\u00f3n del 100% y una luminosidad del 50%. El programa es el siguiente.</p> <p>Descargar el programa</p> <p> <p> Ejemplo b\u00e1sico con cambio entre varios colores</p> <p></p> <p>Volver </p> <p>Arcoiris</p> <ul> <li>. Muestra los 7 colores del arcoiris recorriendo la rueda de color entre 1 y 360. Si cambiamos el rango restringimos la gama de colores.</li> <li>. Desplaza LEDs que se muestran en la cantidad indicada. Si la cantidad se hace negativa el desplazamiento se realiza en sentido contrario.</li> </ul> <p>Veamos un ejemplo en el que se muestran los colores del arcoiris y desaparece uno de ellos cada segundo.</p> <p>Descargar el programa</p> <p>El programa es:</p> <p> <p> Arcoiris b\u00e1sico</p> <p></p> <p>Se recomienda probar con el desplazamiento negativo y con valores diferentes de la unidad.</p> <p>Volver </p> <p>Rotar LEDs</p> <ul> <li>. Va rotando la posici\u00f3n de los LED en la cantidad especificada manteniendo todos los LEDs encendidos.</li> </ul> <p>En el ejemplo anterior vamos a cambiar el bloque desplazar por el de rotar y observar lo que ocurre. Se produce un desplazamiento de los colores de los LEDs seg\u00fan la cantidad indicada. Si esta cantidad se hace negativa el desplazamiento se realiza en sentido contrario.</p> <p>Muy \u00fatil para programar efectos de colores repetitivos.</p> <p>El programa ahora es:</p> <p> <p> Arcoiris rotando</p> <p></p> <p>Volver </p> <p>Encender espec\u00edfico o aleatorio</p> <ul> <li>. Este bloque permite especificar el color de un p\u00edxel concreto.</li> </ul> <p>Un programa como el siguiente parte de todos los LEDs apagados y los va encendiendo de color amarillo uno a uno con un retardo de medio segundo hasta encender los 8 LEDs.</p> <p> <p> Encender espec\u00edfico</p> <p></p> <p>Vamos a modificar el programa anterior para que cada vez que pulsamos el bot\u00f3n A se encienda un LED aleatorio de un determinado color. El programa es el siguiente:</p> <p> <p> Encender aleatorio</p> <p></p> <p>Volver </p> <p>Trazar diagrama de barras</p> <ul> <li>. El funcionamiento del bloque es b\u00e1sicamente como el de un v\u00fametro de sonido escribiendo en los LEDs el valor especificado en el rango.</li> <li>. Averigua cu\u00e1l es el nivel de sonido que escucha el micr\u00f3fono. Este bloque requiere de una micro:bit V2. Si se utiliza con una placa micro:bit v1, aparecer\u00e1 el c\u00f3digo de error 927 en la pantalla.</li> </ul> <p>Un programa como el siguiente registra la lectura del nivel de sonido y en funci\u00f3n del valor enciende un n\u00famero mayor o menor de LEDs.</p> <p> <p> Nivel de sonido con trazar diagrama de barras</p> <p></p> <p>Volver </p> <p>Dentro de un rango</p> <ul> <li>. Permite establecer como valor de una variable un rango de LEDs de la tira. El objetivo es poder cambiar todo el rango a la vez.</li> </ul> <p>Vamos a crear un programa con dos variables de rango, en una ponemos una configuraci\u00f3n de rango de LEDs y en la otra su complementario, es decir, el resto de LEDs. Ahora establecemos un color diferente para ambos rangos cuando pulsamos el bot\u00f3n A y mostramos el resultado. Para el bot\u00f3n B simplemente cambiamos los colores de cada rango. El efecto final es que un grupo de LEDs se encienden de un color y el otro grupo de otro color y al pulsar los botones esos grupos van alternandose.</p> <p>Descargar el programa</p> <p>El programa es:</p> <p> <p> Dentrro de un rango</p> <p></p> <p>Volver </p> <p>Cambio sentido desplazamiento por posici\u00f3n</p> <ul> <li>. Obtiene el valor de la aceleraci\u00f3n (miligramos-fuerza) en una de las tres dimensiones, o la fuerza combinada en todas las direcciones (x, y, y z). Es capaz de encontrar la aceleraci\u00f3n del micro:bit, es decir los r\u00e1pido que se est\u00e1 acelerando o ralentizando.</li> </ul> <p>La aceleraci\u00f3n se mide con el miligramos-g, que equivale a la mil\u00e9sima parte de la aceleraci\u00f3n de la gravedad \"g\". Un \"g\" es la aceleraci\u00f3n que produce la gravedad terrestre.</p> <p>El bloque permite seleccionar entre los siguientes par\u00e1metros:</p> <ul> <li>x: aceleraci\u00f3n en direcci\u00f3n izquierda y derecha.</li> <li>y: aceleraci\u00f3n hacia delante y hacia atr\u00e1s.</li> <li>z: aceleraci\u00f3n hacia arriba y hacia abajo.</li> <li>fuerza: la fuerza resultante de la aceleraci\u00f3n de las tres dimensiones (direcciones).</li> </ul> <p>Repasemos un poco las fuerzas en el espacio</p> <p>Todas las fuerzas que nos afectan se se producen en un espacio tridimensional. Si el movimiento de un objeto no es exactamente en la direcci\u00f3n de un eje, necesitamos una forma de calcular su aceleraci\u00f3n a partir de los valores medidos para todos los ejes.</p> <p>Se pueden realizar c\u00e1lculos de estas fuerzas en el Espacio eucl\u00eddeo (tambi\u00e9n llamado espacio euclidiano) que es un tipo de espacio geom\u00e9trico donde se satisfacen los axiomas de Euclides de la geometr\u00eda. En el gr\u00e1fico vemos como se sit\u00faa un punto en un espacio eucl\u00eddeo de tres dimensiones.</p> <p> <p> Punto en espacio eucl\u00eddeo 3D</p> <p></p> <p>Si ponemos la micro:bit en una mesa nivelada y la empujamos diagonalmente, obtendremos una aceleraci\u00f3n en dos dimensiones. Se puede calcular la aceleraci\u00f3n en esa direcci\u00f3n igual que se calcula la hipotenusa en un tri\u00e1ngulo rect\u00e1ngulo, es decir:</p> <p> F_{2D} = \\sqrt{a_{x}^{2}+a_{y}^{2}} </p> <p>Si se levanta la micro:bit de la mesa se a\u00f1ade otra dimensi\u00f3n, la Z, de manera que hay que inserta el valor de aceleraci\u00f3n para el eje Z en la ecuaci\u00f3n:</p> <p> F_{3D} = \\sqrt{a_{x}^{2}+a_{y}^{2}+a_{z}^{2}} </p> <p>Este c\u00e1lculo se denomina norma euclidiana de aceleraci\u00f3n.</p> <p>En el siguiente programa, utilizamos el valor de aceleraci\u00f3n (que se encuentra en las herramientas de entrada) para desplazar los p\u00edxeles en una direcci\u00f3n o en la contraria cuando la micro:bit se inclina hacia la izquierda o hacia la derecha.</p> <p>Descargar el programa</p> <p> <p> Control sentido rotaci\u00f3n con la aceleraci\u00f3n xy</p> <p></p> <p>El simulador es capaz de responder a los movimientos de inclinaci\u00f3n moviendo el rat\u00f3n sobre la micro:bit a un lado y al otro.</p> <p>Volver </p> <p>Personalizar colores RGB</p> <ul> <li>. Permite establecer los valores RGB para obtener un color determinado.</li> </ul> <p>En el programa siguiente vemos un ejemplo de aplicaci\u00f3n de este bloque.</p> <p> <p> Control sentido rotaci\u00f3n con la aceleraci\u00f3n xy</p> <p></p> <p>Descargar el programa</p>"},{"location":"programacion/mkcode/#bloques-de-musica","title":"Bloques de M\u00fasica","text":"<p>Los bloques que vamos a describir a continuaci\u00f3n requieren de una micro:bit V2. Si se utilizan con una placa micro:bit V1, se generar\u00e1 el c\u00f3digo de error 927 en la pantalla.</p> <p>Es posible cambiar el pin de salida utilizando en \"Inicializar\" el bloque </p> <ul> <li>. El bloque permite componer, a partir de las notas b\u00e1sicas y el tempo establecido, melodias sencillas o bien seleccionar las de la galer\u00eda.</li> <li>. Reproduce un tono en el pin0 durante el tiempo indicado. La frecuencia del tono se establece como un n\u00famero de ciclos por segundo y la duraci\u00f3n del tono se establece como un n\u00famero de milisegundos. Es habitual utilizar una fracci\u00f3n de tiempo para la duraci\u00f3n del tono.</li> <li>. Reproduce el tono indicado, que se puede seleccionar con el teclado que aparece al pulsar sobre el nombre del tono. Durante el cambio podemos ver un n\u00famero que es justo el tiempo en milisegundo que dura la nota.</li> <li>. Silencio durante el tiempo especificado.</li> <li>. Establecde el volumen de salida predeterminado entre 0 y 255.</li> <li>. Devuelve el nivel de volumen actual del sintetizador.</li> <li>. Detiene la reproducci\u00f3n del sonido actual y de cualquier otro en espera de reproducirse. </li> <li>. Cambia en tempo en la cantidad indicada. Los valores negativos hacen la melodia mas lenta. El n\u00famero bmp (beats per minute) indica el n\u00famero de pulsos en un minuto.</li> <li>. Establece el tempo a la cantidad indicada. </li> <li>. Devuelve la duraci\u00f3n de un pulso en milisegundos.</li> <li>. Devuelve el tempo en pbm</li> <li>. Reproduce una expresi\u00f3n sonora, que es un conjunto preformateado de tonos que crean un sonido determinado. Hay varios sonidos para elegir.</li> <li>. Detiene la melodia musical. Las melod\u00edas se reproducen en primer (foreground) o segundo (background) plano. Esto permite que haya m\u00e1s de una melod\u00eda activa a la vez. Si una melod\u00eda est\u00e1 configurada para reproducirse en segundo plano, puede interrumpirse o pausarse temporalmente mientras se reproduce una melod\u00eda configurada en primer plano. Si la melod\u00eda en primer plano no est\u00e1 configurada para reproducirse siempre (loop), la melod\u00eda en segundo plano se reanudar\u00e1 cuando finalice la melod\u00eda en primer plano.</li> <li>. Genera eventos para melod\u00edas o eventos musicales.</li> <li>. Reproduce una expresi\u00f3n de sonido.</li> <li>. Es un generador de se\u00f1ales de diferentes formas. Hay muchos ajustes diferentes y se puede reproducir la configuraci\u00f3n concreta antes de cerrar la ventana. En la animaci\u00f3n vemos brevemente como funciona y a continuaci\u00f3n se indican los par\u00e1metros que describen al sonido.</li> </ul> <p> <p></p> <p></p> <p>Los par\u00e1metros especifican una forma de onda base, el rango de frecuencia, el volumen del sonido y los efectos. Los datos de sonido se crean como un objeto Sonido y pueden reproducirse en el altavoz, los auriculares o en una clavija de salida.</p> <ul> <li> <p>waveShape: forma primaria de la onda:</p> <ul> <li>sinusoidal: forma de onda sinusoidal</li> <li>diente de sierra: forma de onda diente de sierra</li> <li>tri\u00e1ngulo: forma de onda triangular</li> <li>square: forma de onda cuadrada</li> <li>ruido: forma de onda generada por ruido aleatorio</li> </ul> </li> <li> <p>startFrequency: un n\u00famero que es la frecuencia de la forma de onda cuando comienza la expresi\u00f3n sonora.</p> </li> <li>endFrequency: un n\u00famero que es la frecuencia de la forma de onda cuando la expresi\u00f3n sonora se detiene.</li> <li>startVolume: un n\u00famero que es el volumen inicial de la expresi\u00f3n sonora.</li> <li>endVolume: un n\u00famero el volumen final de la expresi\u00f3n sonora.</li> <li>duration: un n\u00famero la duraci\u00f3n en milisegundos de la expresi\u00f3n sonora.</li> <li> <p>effect: un efecto para a\u00f1adir a la forma de onda. Estos efectos son:</p> <ul> <li>tr\u00e9molo: a\u00f1ade ligeros cambios de volumen a la expresi\u00f3n sonora.</li> <li>vibrato: a\u00f1ade ligeros cambios de frecuencia a la expresi\u00f3n sonora.</li> <li>warble: similar al vibrato pero con variaciones m\u00e1s r\u00e1pidas en los cambios de frecuencia.</li> </ul> </li> <li> <p>interpolation: controla la tasa de cambio de frecuencia en la expresi\u00f3n sonora.</p> <ul> <li>linear: el cambio de frecuencia es constante durante toda la duraci\u00f3n del sonido.</li> <li>curve: el cambio de frecuencia es m\u00e1s r\u00e1pido al principio del sonido y se ralentiza hacia el final.</li> <li>logarithmic: el cambio de frecuencia es r\u00e1pido durante la primera parte del sonido.</li> </ul> </li> <li> <p>. Crea una cadena que es una expresi\u00f3n sonora.</p> </li> <li>. Obtiene el nivel de volumen actual del sintetizador de sonido.</li> <li>. Activa/desactiva el altavoz de la micro:bit para reproducir m\u00fasica y sonidos.</li> </ul>"},{"location":"programacion/mkcode/#serial","title":"Serial","text":"<p>Su descripci\u00f3n b\u00e1sica y detallada las podemos encontrar en la entrada Serial de la documentaci\u00f3n de MakeCode, donde adem\u00e1s se desarrollan ejemplos de uso.</p> <ul> <li>Ejemplo de escribir un n\u00famero como gr\u00e1fico de barras con nivel de iluminaci\u00f3n. Utilizamos el bloque \"plot bar graph\" del men\u00fa LED. El ejemplo ser\u00eda:</li> </ul> <p> <p> Gr\u00e1fico de barras con nivel de iluminaci\u00f3n</p> <p></p> <p>El ejemplo nos va a permitir visualizar datos tanto en el simulador como en la placa utilizando los LEDs de la pantalla para dibujar un gr\u00e1fico de barras en funci\u00f3n del nivel de iluminaci\u00f3n que reciben ellos mismos. Pero adem\u00e1s nos permite ver el funcionamiento en el simulador e incluso en PuTTY.</p> <p> <p> Gr\u00e1fico de barras con nivel de iluminaci\u00f3n</p> <p></p> <ul> <li>Ejemplo de visualizaci\u00f3n de varios datos, como la temperatura y el nivel de iluminaci\u00f3n. El programa de ejemplo ser\u00eda:</li> </ul> <p> <p> Temperatura y nivel de iluminaci\u00f3n</p> <p></p> <p>En la gr\u00e1fica siguiente vemos graficados y en modo texto los datos simulados y la descripci\u00f3n de los tres iconos destacados. El icono de exportaci\u00f3n nos guarda una copia de los datos en formato CSV y el icono raw nos los guarda en formato txt.</p> <p> <p> Temperatura y nivel de iluminaci\u00f3n</p> <p></p>"},{"location":"programacion/mkcode/#magnetometro-y-acelerometro","title":"Magnet\u00f3metro y aceler\u00f3metro","text":"<p>Adem\u00e1s de los bloques visto en Conceptos t\u00e9cnicos vamos a citar brevemente otros bloques existentes relacionados con el tema.</p> <ul> <li>. Obtiene el valor de la aceleraci\u00f3n (miligramos-fuerza) en una de las tres dimensiones, o bien la fuerza combinada en todas las direcciones (x, y, y z). La aceleraci\u00f3n se mide con el mg, que es 1/1000 de un g, siendo un g la aceleraci\u00f3n de la gravedad terrestre. El valor de g es </li> </ul> <p> g = 9.81 \\space m/s^2 \\space = \\space m \\cdot s^{\u22122} \\space o \\space de \\space manera \\space equivalente \\space N/kg \\space = \\space N \\cdot kg^{\u22121}.</p> <p>Recordemos el c\u00e1lculo euclidiano de las fuerzas. Si estamos trabajando en un plano nivelado y movemos la micro:bit de manera diagonal obtenemos una aceleraci\u00f3n en dos dimensiones que se calcula asi:</p> <p> <p>f_{2D} = \\sqrt{a_{x}^{2}+a_{y}^{2}}</p> <p></p> <p>Si levantamos la micro:bit del plano a\u00f1adimos otra dimensi\u00f3n en la ecuaci\u00f3n:</p> <p> <p>f_{3D} = \\sqrt{a_{x}^{2}+a_{y}^{2}+a_{z}^{2}}</p> <p></p> <p>La funci\u00f3n retorna un n\u00famero que es la cantidad de aceleraci\u00f3n. Cuando la micro:bit est\u00e1 sobre una superficie plana con la pantalla hacia arriba, x = 0, y = 0, z = -1023, y la fuerza es 1023.</p> <p>Como ejemplo vamos a crear un indicador del grado movimiento de una superficie a modo de medida del grado de un terremoto. El programa es:</p> <p> <p> Grado de movimiento 3D de la micro:bit</p> <p></p> <ul> <li>. Fuerza magn\u00e9tica. Encuentra la cantidad de fuerza magn\u00e9tica (la fuerza de un im\u00e1n) en una de las tres direcciones. Recordemos siempre que es necesario calibrar la br\u00fajula para estar adaptados al lugar donde estemos trabajando con la micro:bit. Devuelve un n\u00famero de microteslas que es la intensidad de la fuerza magn\u00e9tica. Como ejemplo creamos un detector de metales que mida la intensidad de la fuerza magn\u00e9tica en la direcci\u00f3n X. Visualice un gr\u00e1fico de barras para mostrar el nivel actual de la fuerza magn\u00e9tica medida por el magnet\u00f3metro.</li> </ul> <p> <p> Detector de metales</p> <p></p> <ul> <li>. Averigua la inclinaci\u00f3n de la micro:bit en diferentes direcciones: Rotation.Pitch (arriba y abajo) o Rotation.Roll (izquierda y derecha). Los conceptos que vemos en la imagen siguiente se refieren a la rotaci\u00f3n del eje X (Roll) y la rotaci\u00f3n del eje Y (Pitch) y se ha prescindido del eje Z (Yaw). Para aprender mas sobre estos conceptos puedes visitar este enlace al blog de Luis Llamas. En la explicaci\u00f3n de los conceptos b\u00e1sicos de este tipo de dispositivos se muestra el gr\u00e1fico de la figura, donde se comparan los conceptos de movimientos angulares aplicados a una aeronave.</li> </ul> <p> <p> Movimientos angulares Pitch y Roll</p> <p></p> <p>En los bloques se ha traducido Pitch como Timbre aunque a mi modo de ver ser\u00eda mas correcto Cabeceo y Roll se ha traducido por Girar que ser\u00eda mejor Balanceo. Aunque no lo utilizamos Yaw se suele traducir por Viraje. El valor de retorno en un \u00e1ngulo en grados entre -180 y 180. Hagamos como ejemplo un sencillo nivel que muestre una carita sonriente si la micro:bit est\u00e1 nivelada.</p> <p> <p> Nivel con Pitch y Roll</p> <p></p> <ul> <li>. Establecer el rango del aceler\u00f3metro por si necesitamos medir aceleraciones altas o bajas. Los valores posibles son 1g, 2g, 4g u 8g. Veamos un ejemplo en el que se establece que la aceleraci\u00f3n m\u00e1s alta que la micro:bit medir\u00e1 es 4G. Movemos la micro:bit en la direcci\u00f3n elegida hasta detener el programa. El programa no se puede simular.</li> </ul> <p> <p> Rango de aceleraci\u00f3n</p> <p></p>"},{"location":"programacion/mkcode/#nivel-de-luz","title":"Nivel de luz","text":"<ul> <li>. Uno de los bloques del men\u00fa \"Entrada\". Averigua el nivel de luz (lo brillante u oscuro que es) en el lugar en el que se encuentre la micro:bit. El nivel de luz 0 significa oscuridad y 255 significa luz brillante. La micro:bit mide la luz a su alrededor utilizando algunos de los LED de la pantalla LED.</li> </ul> <p>La primera vez que se utiliza, la funci\u00f3n retornar\u00e1 0. Posteriormente, dir\u00e1 el nivel de luz real. Esto se debe a que el sensor de luz tiene que activarse antes de detectar. Trabajar con el bloque es muy sencillo, como vemos en el ejemplo siguiente, donde podemos observar un momento de la simulaci\u00f3n.</p> <p> <p> Ejemplo: gr\u00e1fico de barras con la luminosidad</p> <p></p>"},{"location":"programacion/mkcode/#i2c","title":"I2C","text":"<p>MakeCode incorpora dos bloques en el men\u00fa \"Pines\" que nos permiten leer y escribir un n\u00famero en una direcci\u00f3n I2C.</p> <ul> <li>Leer un n\u00famero de una direcci\u00f3n I2C utilizando un formato de n\u00famero especificado. No est\u00e1 soportado en el simulador.</li> </ul> <p> <p></p> <p></p> <ul> <li>Escribir un n\u00famero de una direcci\u00f3n I2C utilizando un formato de n\u00famero especificado. No est\u00e1 soportado en el simulador.</li> </ul> <p> <p></p> <p></p> <p>La condici\u00f3n repeated se establece para asegurarse de que cuando desee leer varios n\u00fameros del dispositivo a la vez, se pueda hacer sin interrupci\u00f3n. Con la condici\u00f3n en <code>True</code> se lee sin parada y cuando se lee el \u00faltimo n\u00famero es cuando se envia la condici\u00f3n a <code>False</code> y no se realizan mas lectuas. Para lecturas individuales debe estar en <code>False</code>.</p> <p>Algunos sensores de la micro:bit usan el mismo bus I2C que est\u00e1 conectado a los pines de programas. Esto significa que hay que tener cuidado de NO usar una direcci\u00f3n para nuestro dispositivo que sea la misma que cualquiera de las usadas por los sensores en la placa. Tenemos que revisar la lista de direcciones de sensores I2C antes de asignar una a nuestro dispositivo.</p> <p>Pero nosotros no vamos a trabajar con estos bloques sino a\u00f1adiendo la extensi\u00f3n I2C LCD1602. Los bloques son secillos de utilizar y su uso b\u00e1sico se explica en el enlace anterior.</p> <p> <p> Bloques de la extensi\u00f3n I2C LCD1602 </p> <p>En cuanto a la direcci\u00f3n f\u00edsica del dispositivo indicar que si en el bloque la dejamos a 0 se intentar\u00e1 reconocerla autom\u00e1ticamente. Pero si esto no funciona debemos indicarla nosotros. El n\u00famero que indica la direcci\u00f3n es decimal, pero en el bloque podemos introducir el hexadecimal que este lo convierte directamente a decimal. Por ejemplo, si no nos reconoce la direcci\u00f3n del dispositivo, pero sabemos que es 0x27 podemos proceder como en la animaci\u00f3n siguiente:</p> <p> <p> Especificar direcci\u00f3n f\u00edsica de </p> <p>El ejemplo Hola mundo ampliado nos muestra el uso b\u00e1sico de estos bloques.</p> <p> <p> Hola Mundo ampliado con I2C LCD1602 </p> <p>Descargar el programa</p>"},{"location":"programacion/mkcode/#temperatura","title":"Temperatura","text":"<p>En MakeCode es muy sencillo averiguar la temperatura del lugar donde nos encontremos. La temperatura se mide en grados Celsius (sistema m\u00e9trico). La micro:bit puede calcular la temperatura aproximada comprobando cuan calientes est\u00e1n sus chips inform\u00e1ticos. En el men\u00fa \"Entrada\" hay un bloque espec\u00edfico para ello.</p> <ul> <li> Devuelve un n\u00famero que es la temperatura en grados Celsius.</li> </ul> <p>La micro:bit comprueba la temperatura de su CPU (chip principal de la placa). Como la micro:bit no suele calentarse mucho, la temperatura de la CPU suele ser cercana a la temperatura del lugar donde se encuentra. Sin embargo, la micro:bit puede calentarse un poco si la hacemos trabajar duro.</p> <p>De una manera muy similar a la explicada en la entrada \"Detecci\u00f3n de luz con la micro:bit\" del apartado Componentes discretos de Conceptos t\u00e9cnicos, la uni\u00f3n PN puede variar la capacidad que se forma en la barrera de potencia en funci\u00f3n de la temperatura, a mayor temperatura mayor capacidad, y estas variaciones se puede utilizar para calcular la temperatura. En el video Behind the MakeCode Hardware - Temperature Sensor on micro:bit del canal de Youtube de MakeCode se explica en detalle.</p> <p>Pero la micro:bit no lleva ning\u00fan sensor de temperatura, sino que dicho sensor est\u00e1 dentro del procesador:</p> <p> <p> Ubicaci\u00f3n del procesador en una micro:bit V2 </p> <p>En el datasheet del nRF52833 en su p\u00e1gina 422 nos explica el sensor y el registro que lo acompa\u00f1a y en la p\u00e1gina 428 nos da las especificaciones el\u00e9ctricas del mismo. A continuaci\u00f3n se reproduce traducida la descripci\u00f3n:</p> <p>El sensor de temperatura mide matriz en el rango de temperatura del dispositivo. Si la aplicaci\u00f3n lo requiere, se puede implementar una compensaci\u00f3n de linealidad.</p> <p>A continuaci\u00f3n se enumeran las principales caracter\u00edsticas de TEMP:</p> <ul> <li>El rango de temperatura es mayor o igual a la temperatura de funcionamiento del dispositivo.</li> <li>La resoluci\u00f3n es de 0,25 grados</li> </ul> <p>TEMP se inicia activando la tarea START.</p> <p>Cuando se completa la medici\u00f3n de temperatura, se genera un evento DATARDY y el resultado de la medici\u00f3n se puede leer en el registro TEMP.</p> <p>Para alcanzar la precisi\u00f3n de medida indicada en la especificaci\u00f3n el\u00e9ctrica, debe seleccionarse el oscilador de cristal como fuente de HFCLK. Para obtener m\u00e1s informaci\u00f3n, consulte RELOJ - Control del reloj en la p\u00e1gina 80.</p> <p>Cuando finaliza la medici\u00f3n de temperatura, la electr\u00f3nica anal\u00f3gica TEMP se apaga para ahorrar energ\u00eda.</p> <p>TEMP s\u00f3lo admite el funcionamiento de una sola vez, lo que significa que cada medici\u00f3n TEMP debe iniciarse expl\u00edcitamente mediante la tarea START. </p> <p>Que el sensor de temperatura est\u00e9 dentro del procesador crea un peque\u00f1o problema, y es que estamos midiendo la temperatura dentro del procesador en lugar de en el aire que hay a su alrededor. Y claro, a medida que el procesador ejecuta el c\u00f3digo se va calentando, haciendo que el sensor de temperatura d\u00e9 una medida ligeramente m\u00e1s alta de lo que esperamos si hubi\u00e9semos medido en el aire exterior. A\u00fan as\u00ed la diferencia no es mucho mas grande que el error que tienen algunos sensores externos habituales en este tipo de proyectos, por lo que nos puede valer perfectamente como sensor.</p> <p>Si vamos a trabajar con un termistor hay que recurrir a c\u00e1lculos matem\u00e1ticos tras la lectura del valor anal\u00f3gico de medida devuelto por el termistor. En la entrada El termistor del apartado Compnentes discretos de la secci\u00f3n Concetos t\u00e9cnicos lo tenemos descrito.</p> <p>En cambio para MakeCode podemos encontrar una extensi\u00f3n denominada Makecode-Extension-Starter-Kit que podemos agregar y tendremos disponibles unos cuantos bloques y uno de ellos es justo la lectura de temperatura del termistor.</p> <p> <p> Bloque termistor para MakeCode</p> <p></p>"},{"location":"programacion/python/","title":"Python","text":"<p>De manera muy resumida lo que haremos en esta secci\u00f3n es:</p> <ul> <li>Introducir los conceptos de programaci\u00f3n para programar la micro:bit desde BBC micro:bit MicroPython.</li> <li>Tambi\u00e9n introduciremos conceptos de micro:bit Micropython API.</li> </ul>"},{"location":"programacion/python/#api-el-modulo-microbit","title":"API: El m\u00f3dulo microbit","text":"<p>Todo lo necesario para interactuar con el hardware de la micro:bit est\u00e1 en el m\u00f3dulo microbit y se recomienda su uso escribiendo al principio del programa:</p> <p> <pre><code>from microbit import *\n</code></pre> </p> <p>Las funciones disponibles directamente son:</p> <pre><code>sleep(ms) #1\nrunning_time() #2\ntemperature() #3\nscale(valor_a_convertir, from_=(min, max), to=(min, max)) #4\npanic(error_code) #5\nreset() #6\nset_volume(valor) #7 (V2)\n'''\n1 Esperar el n\u00famero de milisegundos indicado\n2 Devuelve el tiempo en ms desde la \u00faltima vez que se encendi\u00f3 la micro:bit\n3 Devuelve la temperatura en Celcius\n4 Convierte un n\u00famero de una escala de valores a otra\n5 La micro:bit entra en modo p\u00e1nico por falta de memoria y se dibuja una\ncara triste en la pantalla. El valor de error_code puede ser cualquier entero.\n6 Resetea la micro:bit\n7 Estable el volumen de salida con un *valor* entre 0 y 255\n'''\n</code></pre>"},{"location":"programacion/python/#api-display","title":"API: Display","text":"<p>Control de la matriz de 5x5 LEDs que en micro:bit se conoce como pantalla. Los m\u00e9todos de la clase son:</p> <pre><code>display.get_pixel(x, y) #1\ndisplay.set_pixel(x, y, val) #2\ndisplay.clear() #3\ndisplay.show(image, delay=0, wait=True, loop=False, clear=False) #4\ndisplay.scroll(string, delay=400) #5\n'''\n1 Obtiene el brillo [0 (apagado) a 9 (m\u00e1x))] del pixel (x,y)\n2 Establece el brillo [0 (apagado) a 9 (m\u00e1x))] del pixel (x,y)\n3 Borra (apaga) la pantalla\n4 Muestra la imagen\n5 Desplaza una cadena por la pantalla a la velocidad en ms del *delay*\n'''\n</code></pre> <p>En ambos casos de la API existen otras muchas opciones no incluidas. La funcionalidad de autocompletar nos ayudar\u00e1 para no tener que recordar la sintaxis y conocer las que no aparece aqu\u00ed. En la animaci\u00f3n siguiente vemos un ejemplo de ambos casos.</p> <p> <p> Autocompletar funciones y m\u00e9todos</p> <p></p>"},{"location":"programacion/python/#estructuras-de-datos-en-python","title":"Estructuras de datos en Python","text":""},{"location":"programacion/python/#las-listas-list","title":"Las listas (list)","text":"<p>Se trata de un tipo de dato que permite almacenar series de datos de cualquier tipo bajo su estructura. Se suelen asociar a las matrices o arrays de otros lenguajes de programaci\u00f3n.</p> <p>En Python las listas son muy versatiles permitiendo almacenar un conjunto arbitrario de datos. Es decir, podemos guardar en ellas lo que sea.</p> <p>Una lista se crea con <code>[]</code> y sus elementos se separan por comas. Una gran ventaja es que pueden tener datos de diferentes tipos.</p> <pre><code>lista = [1, \"Hola\", 3.141592, [1 , 2, 3], Image.HAPPY]\n</code></pre> <p>Las de principales propiedades de las listas:</p> <ul> <li>Son ordenadas, mantienen el orden en el que han sido definidas</li> <li>Pueden ser formadas por tipos arbitrarios de datos</li> <li>Pueden ser indexadas con [i]</li> <li>Se pueden anidar, es decir, meter una lista dentro de otra</li> <li>Son mutables, ya que sus elementos pueden ser modificados</li> <li>Son din\u00e1micas, ya que se pueden a\u00f1adir o eliminar elementos</li> </ul> <p>Hay dos m\u00e9todos aplicables:</p> <ul> <li><code>append</code>. Permite agregar elementos a la lista.</li> <li><code>remove</code>. Elimina elementos de la lista.</li> <li><code>insert(pos,elem)</code>. Inserta el elemento <code>elem</code> en la posici\u00f3n <code>pos</code> indicada.</li> </ul> <p>En el ejemplo vemos el funcionamiento.</p> <p> <p> Ejemplo de listas y sus m\u00e9todos</p> <p></p> <p>Con estos conocimientos tendremos suficiente para hacer lo que pretendemos, que no es otra cosa que animar im\u00e1genes.</p>"},{"location":"programacion/python/#las-tuplas-tuple","title":"Las tuplas (tuple)","text":"<p>Son muy similares a las listas con una diferencia principal con las mismas y es que las tuplas no pueden ser modificadas directamente, lo que implica que no dispone de los m\u00e9todos vistos para listas. Una tupla permite tener agrupados un n\u00famero inmutable de elementos.</p> <p>Una tupla se crea con <code>()</code> y sus elementos se separan por comas.</p> <pre><code>tupla = (1, 2, 3)\n</code></pre> <p>Principales propiedades:</p> <ul> <li>Se pueden declarar sin usar los par\u00e9ntesis, pero no se recomienda. No usarlos puede llevarnos a ambig\u00fcedades del tipo print(1, 2, 3) y print((1, 2, 3)).</li> <li>Si la tupla tiene un solo elemento esta debe finalizar con coma.</li> <li>Se pueden anidar tuplas, por ejemplo <code>tupla2 = tupla1, 4, 5, 6, 7</code>.</li> <li>Se pueden declarar tuplas vacias, por ejemplo <code>tupla3 = ()</code>.</li> <li>Las tuplas son iterables por lo que sus elementos pueden ser accesados mediante la notaci\u00f3n de \u00edndice del elemento entre corchetes. Si se quiere acceder a un rango de indices se separan por \":\" ambos \u00edndices.</li> <li>Es posible convertir listas en tuplas simplemente poniendo la lista dentro de los par\u00e9ntesis de la tupla, por ejemplo, <code>tupla_lista = ([1, \"Hola\", 3.141592, [1 , 2, 3], Image.HAPPY])</code></li> </ul> <p>A continuaci\u00f3n vemos un ejemplo.</p> <p> <p> Ejemplo de tuplas</p> <p></p>"},{"location":"programacion/python/#diccionarios-dict","title":"Diccionarios (dict)","text":"<p>Estas estructuras contienen la colecci\u00f3n de elementos con la forma <code>clave:valor</code> separados por comas y encerrados entre <code>{}</code>. Las claves son objetos inmutables y los valores pueden ser de cualquier tipo. Sus principales caracter\u00edsticas son:</p> <ul> <li>En lugar de por \u00edndice como en listas y tuplas, en diccionarios se acceder al valor por su clave.</li> <li>Permiten eliminar cualquier entrada.</li> <li>Al igual que las listas, el diccionario permite modificar los valores.</li> <li>El m\u00e9todo <code>dicc.get()</code> accede a un valor por la clave del mismo.</li> <li>El m\u00e9todo <code>dicc.items()</code> devuelve una lista de tuplas <code>clave:valor</code>.</li> <li>El m\u00e9todo <code>dicc.keys()</code> devuelve una lista de las claves.</li> <li>El m\u00e9todo <code>dicc.values()</code> devuelve una lista de los valores.</li> <li>El m\u00e9todo <code>dicc.update()</code> a\u00f1ade elemento <code>clave:valor</code> al diccionario.</li> <li>El m\u00e9todo <code>del dicc</code> borra el par <code>clave:valor</code>.</li> <li>El m\u00e9todo <code>dicc.pop()</code> borra el par <code>clave:valor</code>.</li> </ul> <p>A continuaci\u00f3n vemos un ejemplo.</p> <p> <p> Ejemplo de diccionario</p> <p></p>"},{"location":"programacion/python/#bucles","title":"Bucles","text":"<p>Los Bucles son un tipo de estructura de control muy \u00fatil cuando queremos repetir un bloque de c\u00f3digo varias veces. En Python existen dos tipos de bloques, el bucle for para contar la cantidad de veces que se ejecuta un bloque de c\u00f3digo, y el bucle while que realiza la acci\u00f3n hasta que la condici\u00f3n especificada no sea cierta.</p> <p></p> <p>While for Bucle for decontando Sentencias break y continue</p> <p> While La sintaxis de while es la siguiente:</p> <pre><code>while condicion:\n    bloque de codigo\n</code></pre> <p>donde \"condicion\", que se eval\u00faa en cada iteraci\u00f3n, puede ser cualquier expresi\u00f3n realizado con operadores condicionales que devuelva como resultado un valor True o False. Mientra que \"bloque de codigo\" es el conjunto de instrucciones que se estar\u00e1n ejecutando mientras la condici\u00f3n sea verdadera (True o '1'). Es lo mismo poner <code>while true:</code> que poner <code>while 1:</code>.</p> <p>Para recorrer los bucles se utilizan variables que forman parte de la condici\u00f3n, estableciendose en esta lo que deben cumplir.</p> <p>Un ejemplo sencillo podr\u00eda ser el siguiente, controlar el riego de una planta en funci\u00f3n del valor de la humedad de la tierra en la que est\u00e1.</p> <pre><code>from microbit import *\n\nwhile (humedad() &lt; 45):\n    display.scroll(Image.SAD)\n    sleep(1000)\n\ndisplay.show(Image.HAPPY)\n</code></pre> <p>que har\u00e1 que si la humedad baja por debajo de 45 se muestre una carita triste indicando que hay que regar y si es mayor mostrar\u00e1 una carita feliz. Evidentemente hay que resolver el tema de como obtener la humedad, pero esa es una historia que veremos mas adelante.</p> <p>El bucle <code>while</code> puede tener de manera opcional un bloque <code>else</code> cuyas sentencias se ejecutan cuando se han realizado todas las iteraciones del bucle. Un ejemplo lo vemos a continuaci\u00f3n:</p> <pre><code>cuenta = 0\nwhile cuenta &lt; 5:\n    print(\"Iteraci\u00f3n del bucle\")\n    cuenta = cuenta + 1\nelse:\n    print(\"bucle finalizado\")\n</code></pre> <p>Volver </p> <p>for</p> <p>Son tambi\u00e9n bucles pero su acci\u00f3n est\u00e1 dirigida a contar el n\u00famero de veces que ocurre algo o realizar una acci\u00f3n un determinado n\u00famero de veces. Es especialmente \u00fatil para recorrer los datos de una lista, tupla o diccionario.</p> <p>La sintaxis de este tipo de bucles en Python es:</p> <pre><code>for variable in secuencia:\n    declaracion\n</code></pre> <p>Siendo \"variable\" la variable que se va a recorrer en el bucle de forma que cuando se alcance el valor establecido se sale del bucle.</p> <p>La variable puede ser una cadena, un rango de valores que se expresa con <code>range(n)</code>, siendo n el n\u00famero de valores del rango que se inicia en 0 y que pueden ser iterados con una variable. Mas ampliamente, la sintaxis de <code>range()</code> es <code>range(start, stop, step)</code> siendo <code>start</code> y <code>stop</code> opcionales.</p> <p>Veamos un primer ejemplo en el que vamos a utilizar un bucle para encender uno a uno por filas los LEDs de la primera y \u00faltima columna.</p> <pre><code>from microbit import *\nfor var in range(5): # var puede tomar 5 valores, del 0 al 4\n    display.set_pixel(0, var, 9) # Se ilumina el LED de la fila 0 y el valor de var para columna\n    sleep(300)\n    display.set_pixel(4, var, 9) # Se ilumina el LED de la fila 4 y el valor de var para columna\n    sleep(300)\n</code></pre> <p>Los bucles se pueden anidar, es decir se puede crear un bucle dentro de otro del mismo o diferente tipo, de forma que por cada iteraci\u00f3n del bucle mas externo se tienen que producir todas las iteraciones del bucle mas interno. Veamos como ejemplo el de encender todos los LEDs de uno en uno, de izquierda a derecha, utilizando el valor de sus coordenadas x,y. El programa ser\u00eda:</p> <pre><code>from microbit import *\n\ndisplay.clear()\nfor y in range(0, 5): # Valor de columna\n    for x in range(0, 5): # Valor de fila\n        display.set_pixel(x, y, 9) # Encender LED x,y\n        sleep(100)\n</code></pre> <p>En la animaci\u00f3n siguiente vemos el programa en funcionamiento.</p> <p> <p> Uso de bucle for</p> <p></p> <p>El bucle <code>for</code> puede tener de manera opcional un bloque <code>else</code> cuyas sentencias se ejecutan cuando se han realizado todas las iteraciones del bucle. Un ejemplo lo vemos a continuaci\u00f3n:</p> <pre><code>for var in range(5):\n    print(var)\nelse:\n    print(\"bucle finalizado\")\n</code></pre> <p>Volver </p> <p>Bucle for decontando</p> <p>Se trata del mismo bucle <code>for</code> pero ahora la cuenta la realizamos hacia atr\u00e1s. Hay dos formas sencillas de hacerlo:</p> <ul> <li>Utilizando la funci\u00f3n <code>range()</code>. Si queremos darle un enfoque Pythonic simplemente configuramos los argumentos de la funci\u00f3n de manera que se indique el principio, el final y el incremento, que ser\u00e1 logicamente negativo.</li> </ul> <pre><code>for i in range(20, 0, -2): #imprimere 20, 18, 16, ... 0\n</code></pre> <ul> <li>Utilizando la funci\u00f3n <code>reversed()</code>. Es una funci\u00f3n incorporada en la que hay que indicar como primer argumento el final de la cuenta, como segundo el principio, teniendo en cuenta que se omite, y como tercero el decremento si es ditintos de 1, pero se especifica en m\u00f3dulo. Se utiliza as\u00ed:</li> </ul> <pre><code>for i in reversed(range(0,21,2)): #imprimere 20, 18, 16, ... 0\n</code></pre> <p>Volver </p> <p>Sentencias <code>break</code> y <code>continue</code></p> <p>La sentencia <code>break</code> se utiliza para terminar un bucle de forma inmediata al ser encontrada. En la imagen vemos la sintaxis de la sentencia <code>break</code> y su funcionamiento.</p> <p> <p> Sintaxis y funcionamiento de <code>break</code></p> <p></p> <p>La sentencia <code>continue</code> se utiliza para saltar la iteraci\u00f3n actual del bucle y el flujo de control del programa pasa a la siguiente iteraci\u00f3n. En la imagen vemos la sintaxis de la sentencia <code>continue</code> y su funcionamiento.</p> <p> <p> Sintaxis y funcionamiento de <code>continue</code></p> <p></p> <p>En la figura siguiente vemos dos ejemplos de esta sentencia.</p> <p> <p> Funcionamiento de <code>continue</code></p> <p></p>"},{"location":"programacion/python/#imagenes","title":"Im\u00e1genes","text":"<p>Im\u00e1genes DIY Animar im\u00e1genes</p> <p>MicroPython nos ofrece muchas im\u00e1genes integradas para mostrar por pantalla y podemos crear efectos interesantes. Mediante la caracter\u00edstica de autocompletar se nos van a mostrar todas las definidas que est\u00e1n listadas en la documentaci\u00f3n oficial. Ya hemos visto como cargar una imagen, lo que puedo aconsejar en este momento es realizar el ejercicio de mostrar cada una de las disponibles para familiarizarnos con ellas.</p> <p>Es perfectamente posible crar nuestras propias im\u00e1genes configurando cada Pixel o LED de la pantalla. Tambi\u00e9n es posible crear animaciones con im\u00e1genes.</p> <p>Volver </p> <p>Im\u00e1genes DIY</p> <p>Crear nuestras propias im\u00e1genes va a resultar una tarea sencilla cuando conozcamos la informaci\u00f3n para hacerlo. Cada pixel (LED) de la pantalla se puede configurar con diez valores que pueden tomar un valor entre 0 (cero) y 9 (nueve). Cuando le damos valor 0 (cero) es decirle literalmente que el brillo es nulo y sin embargo cuando le damos el valor 9 (nueve) lo ponemos al m\u00e1ximo de brillo posible. Podemos jugar con todos los valores intermedios para crear niveles de brillo.</p> <p>La forma mas sencilla de definir una imagen consiste en utilizar la clase microbit.Image para crearla a partir de una cadena o string que devuelva el pictograma. Es decir utilizando el comando Image(string) teniendo que constar de d\u00edgitos con los valores 0 a 9 indicados. Para verlo rapidamente hacemos el ejemplos de dibujar una X en relieve asign\u00e1ndola a una variable.</p> <pre><code>mi_imagen_X = Image(\"90009:\"\n                    \"06060:\"\n                    \"00300:\"\n                    \"06060:\"\n                    \"90009\")\n</code></pre> <p>Los dos puntos indican un salto de l\u00ednea por lo que se puede usar el ASCII no imprimible \"\\n\" que es precisamente eso, un salto de l\u00ednea.</p> <pre><code>mi_imagen_X = Image(\"90009\\n\"\n                    \"06060\\n\"\n                    \"00300\\n\"\n                    \"06060\\n\"\n                    \"90009\")\n</code></pre> <p>Los valores de brillo dan la sensaci\u00f3n de relieve de profundidas a la X.</p> <p>En cualquier caso esto no se escribe normalmente as\u00ed, salvo para hacer mas o menos un gr\u00e1fico del pixelado, sino en una sola l\u00ednea.</p> <pre><code>mi_imagen_X = Image(\"90009\\n06060\\n00300\\n06060\\n90009\")\n</code></pre> <p>Ahora parece mas elegante utilizar los dos puntos como indicador de salto de l\u00ednea.</p> <pre><code>mi_imagen_X = Image(\"90009:06060:00300:06060:90009\")\n</code></pre> <p>En la imagen vemos el resultado de lo explicado.</p> <p> <p> mi imagen de una X en relieve</p> <p></p> <p>Este es el c\u00f3digo creado:</p> <pre><code>from microbit import * \n\"\"\"mi_imagen_X = Image(\"90009\\n\"\n                       \"06060\\n\"\n                       \"00300\\n\"\n                       \"06060\\n\"\n                       \"90009\")\"\"\"\n#mi_imagen_X = Image(\"90009\\n06060\\n00300\\n06060\\n90009\")\nmi_imagen_X = Image(\"90009:06060:00300:06060:90009\")\ndisplay.show(mi_imagen_X)\n</code></pre> <p>Volver </p> <p>Animar im\u00e1genes</p> <p>En micro:bit Python ya disponemos de un par de listas de im\u00e1genes incorporadas que se llaman</p> <pre><code>Image.ALL_Clocks\nImage.ALL_ARROWS\n</code></pre> <p>Estas dos ordenes hacen que MicroPython entienda que necesita mostrar cada imagen de la lista, una tras otra.</p> <p>Cuando queremos mostrar en la pantalla una imagen se nos muestra la siguiente ayuda contextual:</p> <p> <p> Ayuda contextual para display.show()</p> <p></p> <p>donde nos indica claramente qie image puede ser una cadena, un n\u00famero, una imagen o una lista de im\u00e1genes. Adem\u00e1s aparecen las opciones que podemos configurar.</p> <p>Con esta informaci\u00f3n crear un \"reloj\" que est\u00e9 continuamente marcando cada hora es bastante sencillo, basta con poner el siguiente c\u00f3digo y darle a simular.</p> <pre><code># Imports go at the top\nfrom microbit import *\ndisplay.show(Image.ALL_CLOCKS, delay=400, loop=True)\n</code></pre> <p>En la animaci\u00f3n vemos el funcionamiento de este \"reloj\".</p> <p> <p> \"Reloj\" creado con display.show() y mostrar una lista</p> <p></p> <p>Si cambiamos el reloj por las flechas veremos como van rotando flechas en \u00e1ngulos de 45 grados.</p> <p> <p> Flechas creado con display.show() y mostrar una lista</p> <p></p> <p>Para animar nuestras propias im\u00e1genes tendremos que crear cada una sobre un lienzo de 5x5 pixeles y establecer las diferencias para crear la animaci\u00f3n. Podemos crear tantas im\u00e1genes como creamos oportuno. Creamos una lista con todas las im\u00e1genes en el orden que se tienen que reproducir y ya podemos mostrar nuestra lista en la pantalla.</p> <p>En la animaci\u00f3n siguiente vemos un efecto creado de esta forma.</p> <p> <p> Cortinilla animada</p> <p></p> <p>Este es el c\u00f3digo para crear la animaci\u00f3n.</p> <pre><code># Imports go at the top\nfrom microbit import *\ndisplay.clear()\ncor1=Image(\"90000:90000:90000:90000:90000\")\ncor2=Image(\"79000:79000:79000:79000:79000\")\ncor3=Image(\"57900:57900:57900:57900:57900\")\ncor4=Image(\"35790:35790:35790:35790:35790\")\ncor5=Image(\"13579:13579:13579:13579:13579\")\ncor6=Image(\"01357:01357:01357:01357:01357\")\ncor7=Image(\"00135:00135:00135:00135:00135\")\ncor8=Image(\"00013:00013:00013:00013:00013\")\ncor9=Image(\"00001:00001:00001:00001:00001\")\ncor10=Image(\"00000:00000:00000:00000:00000\")\ntodas_las_cortinas=[cor1,cor2,cor3,cor4,cor5,cor6,cor7,cor8,cor9,cor10]\ndisplay.show(todas_las_cortinas, delay=100, loop=True)\n</code></pre>"},{"location":"programacion/python/#sentencia-condicional-ifelse","title":"Sentencia condicional <code>if...else</code>","text":"<p>En Python hay tres formas de declaraci\u00f3n de <code>if...else</code></p> <ol> <li>Declaraci\u00f3n <code>if</code></li> <li>Declaraci\u00f3n <code>if...else</code></li> <li>Declaraci\u00f3n <code>if...elif...else</code></li> </ol> <ol> <li>Declaraci\u00f3n <code>if</code>. La sintaxix de esta declaraci\u00f3n en Python tiene la forma siguiente:</li> </ol> <pre><code>if condicion:\n    # Cuerpo de la sentencia if\n\n# C\u00f3digo despu\u00e9s del if\n</code></pre> <p>Si el resultado de evaluar la condici\u00f3n es cierto (True o 1), el c\u00f3digo en \"Cuerpo de la sentencia if\" y lo estar\u00e1 haciendo mientras se cumpla la condici\u00f3n.</p> <p>En el momento que la condici\u00f3n sea evaluada como falsa (False o 0) el c\u00f3digo en \"Cuerpo de la sentencia if\" se omite y  continua la ejecuci\u00f3n del programa por \"C\u00f3digo despu\u00e9s del if\". En la figura siguiente vemos la explicaci\u00f3n de forma gr\u00e1fica.</p> <p> <p> Funcionamiento de la sentencia <code>if</code></p> <p></p> <ol> <li>Declaraci\u00f3n <code>if...else</code>. Una sentencia <code>if</code> puede tener de manera opcional una clausula <code>else</code>. La sintaxix de esta declaraci\u00f3n en Python tiene la forma siguiente:</li> </ol> <pre><code>if condicion:\n    # Bloque de sentencias si condicion es True\n\n    else:\n    # Bloque de sentencias si condicion es False\n</code></pre> <p>La sentencia se eval\u00faa de la siguiente forma: Si <code>condici\u00f3n</code> es <code>True</code> se ejecuta el c\u00f3digo dentro del <code>if</code> y el c\u00f3digo dentro del <code>else</code> se omite. Si <code>condici\u00f3n</code> es <code>False</code> se ejecuta el c\u00f3digo dentro del <code>else</code> y el c\u00f3digo dentro del <code>if</code> se omite. Cuando finaliza bien la parte del <code>if</code> o bien la del <code>else</code> el programa continua con la siguiente sentencia.</p> <p>En la figura siguiente vemos la explicaci\u00f3n de forma gr\u00e1fica.</p> <p> <p> Funcionamiento de la sentencia <code>if...else</code></p> <p></p> <ol> <li>Declaraci\u00f3n <code>if...elif...else</code>. La sentencia <code>if...else</code> se utiliza para ejecutar un bloque de c\u00f3digo entre dos alternativas posibles. Sin embargo, si necesitamos elegir entre m\u00e1s de dos alternativas, entonces utilizamos la sentencia <code>if...elif...else</code>. La sintaxis de la sentencia <code>if...elif...else</code> es:</li> </ol> <pre><code>if condicion_1:\n    # Bloque 1\nelif condicion_2:\n    #Bloque 2\n\n    else:\n    # Bloque 3\n</code></pre> <p>Se eval\u00faa as\u00ed: Si <code>condicion_1</code> es <code>True</code>, se ejecuta Bloque 1. Si <code>condicion_1</code> es <code>False</code>, se eval\u00faa <code>condicion_2</code>. Si <code>condicion_2</code> es <code>True</code>, se ejecuta Bloque 2. Si <code>condicion_2</code> es <code>False</code>, se ejecuta Bloque 3.</p> <p>En la figura siguiente vemos la explicaci\u00f3n de forma gr\u00e1fica.</p> <p> <p> Funcionamiento de la sentencia <code>if...elif...else</code></p> <p></p>"},{"location":"programacion/python/#funciones-en-python","title":"Funciones en Python","text":"<p>En esta secci\u00f3n vamos a dar solamente una breve introducci\u00f3n a lo que son las funciones y los m\u00f3dulos en Python para estudiar dos funciones concretas definidas en MicroPhyton para micro:bit.</p> <p>Una funci\u00f3n es un bloque de c\u00f3digo que realiza una tarea espec\u00edfica.</p> <p>Supongamos que necesitas crear un programa para crear un c\u00edrculo y colorearlo. Puedes crear dos funciones para resolver este problema:</p> <ul> <li>crear una funci\u00f3n de c\u00edrculo</li> <li>crear una funci\u00f3n de color</li> </ul> <p>Dividir un problema complejo en trozos m\u00e1s peque\u00f1os hace que nuestro programa sea f\u00e1cil de entender y reutilizar.</p> <p>Existen dos tipos de funciones en Python:</p> <ul> <li>Standard library functions (Funciones de biblioteca est\u00e1ndar). Son funciones incorporadas en Python que est\u00e1n disponibles para su uso.</li> <li>User-defined functions (Funciones definidas por el usuario). Podemos crear nuestras propias funciones para que cumplan con nuestros requisitos.</li> </ul> <p>La sintaxis de una funci\u00f3n es la siguiente:</p> <pre><code>def nombre_funcion(argumentos):\n    #Cuerpo de la funci\u00f3n\n\n    return\n</code></pre> <p>Donde,</p> <ul> <li><code>def</code> es la palabra reservada para declarar una funci\u00f3n</li> <li><code>nombre_funcion</code> es el nombre que le damos a la funci\u00f3n</li> <li><code>argumentos</code> es el valor o valores pasados a la funci\u00f3n</li> <li><code>return</code> retorna un valor desde la funci\u00f3n. Es opcional</li> </ul> <p>Veamos un ejemplo sencillo que no manda parametros ni retorna nada.</p> <p><pre><code>def saludo():\n    print(\"Hola Mundo!\")\n\nsaludo() #Llama a la funci\u00f3n\nprint(\"Programa\")\nsaludo()\nprint(\"Otra vez programa\")\n</code></pre> Va a generar como salida la cadena \"Hola Mundo!\" seguida de la cadena \"Programa\" seguida otra vez de \"Hola Mundo!\" y finaliza con \"Otra vez programa\".</p> <p>Cuando se llama a la funci\u00f3n, el control del programa pasa a la definici\u00f3n de la funci\u00f3n, se ejecuta todo el c\u00f3digo dentro de la funci\u00f3n y desp\u00e9s el control del programa salta a la siguiente sentencia despu\u00e9s de la llamada a la funci\u00f3n.</p> <p>Como ya se ha mencionado, una funci\u00f3n tambi\u00e9n puede tener argumentos. Un argumento es un valor aceptado por una funci\u00f3n. Cuando creamos una funci\u00f3n con argumentos necesitamos pasar los correspondientes valores cuando la llamamos.</p> <p>De forma gen\u00e9rica una funci\u00f3n con argumentos tiene la siguiente sintaxis:</p> <pre><code>def funcion(arg1, arg2, ar3,...):\n    #C\u00f3digo\n\n#Llamada a la funci\u00f3n\nfuncion(valor1, valor2, valor3, ...)\n#C\u00f3digo\n</code></pre> <p>Cuando llamamos a la funci\u00f3n le pasamos los valores correspondiendo valor1 a arg1, valor2 a arg2 y as\u00ed sucesivamente.</p> <p>La llamada a la funci\u00f3n se puede hacer mencionando el nombre del argumento, que es lo que se conoce como 'argumentos con nombre', siendo el c\u00f3digo totalmente equivalente al anterior.</p> <pre><code>funcion(arg1=valor1, arg2=valor2, arg3=valor3, ...)\n</code></pre> <p>Una funci\u00f3n Python puede o no devolver un valor. Si queremos que nuestra funci\u00f3n devuelva alg\u00fan valor a una llamada realizada a funci\u00f3n, utilizamos la sentencia <code>return</code>.</p> <p>En el ejemplo siguiente se llama a la funci\u00f3n cuatro veces con valores diferentes.</p> <pre><code>def cal_potencia(base, exponente):\n    resultado = base ** exponente\n    return resultado\n\n#Llamadas a la funci\u00f3n\nprint('Potencia =', cal_potencia(2,8))\nprint('Potencia =', cal_potencia(3,3))\nprint('Potencia =', cal_potencia(4,5))\nprint('Potencia =', cal_potencia(9,6))\n</code></pre> <p>El resultado es:</p> <pre><code>Potencia = 256\nPotencia = 27\nPotencia = 1024\nPotencia = 531441\n</code></pre> <p>En Python, las funciones de la biblioteca est\u00e1ndar son las funciones incorporadas que se pueden utilizar directamente en nuestro programa. Por ejemplo,</p> <ul> <li><code>print()</code>, imprime la cadena entre comillas</li> <li><code>sqrt()</code>, devuelve la ra\u00edz cuadrada de un n\u00famero</li> <li><code>pow()</code>, devuelve la potencia de un n\u00famero</li> </ul> <p>Estas funciones est\u00e1n definidas dentro de un m\u00f3dulo. Y, para utilizarlas debemos incluir dicho m\u00f3dulo en nuestro programa. Por ejemplo, <code>sqrt()</code> y <code>pow()</code> est\u00e1n definidos en el m\u00f3dulo <code>math</code>. Para usar las funciones podemos hacer como en el ejemplo siguiente:</p> <pre><code>import math #Carga el m\u00f3dulo math\n\nraiz = math.sqrt(25)\nprint(\"La raiz cuadrada de 25 es \", raiz)\n\npotencia = pow(2, 8)\nprint(\"2^8 =\", potencia)\n</code></pre> <p>En el ejemplo la variable raiz contendr\u00e1 el c\u00e1lculo de la raiz cuadrada y se define por defecto como variable real o decimal y potencia contendr\u00e1 el resultado de elevar a 8 el n\u00famero 2. Los resultados obtenidos son:</p> <pre><code>La raiz cuadrada de 25 es 5.0\n2^8 = 256\n</code></pre> <p>Las principales ventajas de utilizar funciones son:</p> <ul> <li>C\u00f3digo reutilizable. Podemos llamar a la misma funci\u00f3n tantas veces en nuestro programa como necesitemos, lo que hace que nuestro c\u00f3digo sea reutilizable.</li> <li>C\u00f3digo legible. Las funciones nos ayudan a dividir nuestro c\u00f3digo en trozos para que nuestro programa sea mas legible y f\u00e1cil de entender.</li> </ul>"},{"location":"programacion/python/#modulos-en-python","title":"M\u00f3dulos en Python","text":"<p>A medida que nuestro programa crece, puede contener muchas l\u00edneas de c\u00f3digo. En lugar de poner todo en un solo archivo, podemos utilizar m\u00f3dulos para separar por funcionalidad los c\u00f3digos en varios archivos. Esto hace que nuestro c\u00f3digo quede organizado y sea m\u00e1s f\u00e1cil de mantener.</p> <p>Un m\u00f3dulo es un archivo que contiene c\u00f3digo para realizar una tarea espec\u00edfica. Un m\u00f3dulo puede contener variables, funciones, clases, etc. Veamos un ejemplo, vamos a crear un m\u00f3dulo escribiendo algo como lo siguiente:</p> <pre><code>#Definici\u00f3n del m\u00f3dulo suma\n\ndef sumar(a, b):\n\n    resultado = a + b\n    return resultado\n</code></pre> <p>Guardamos este programa en un archivo, por ejemplo <code>modulo_sumar.py</code> y tendremos definida una funci\u00f3n de nombre <code>sumar</code> en ese m\u00f3dulo. La funci\u00f3n recibe dos valores y devuelve la suma.</p> <p>Cuando, en un programa diferente, queramos sumar dos n\u00fameros podemos importar la definici\u00f3n creada utilizando la palabra reservada <code>import</code>. Para acceder a la funci\u00f3n definida en el m\u00f3dulo tenemos que utilizar el operador <code>.</code> (punto). Se parece mucho a que el m\u00f3dulo es una clase y la funci\u00f3n una instancia de esa clase.</p> <pre><code># Programa de sumas\nimport modulo_sumar\n\nmodulo_sumar.sumar(4, 5) #devolver\u00e1 9\n</code></pre> <p>Python tiene mas de 200 m\u00f3dulos est\u00e1ndar que pueden ser importados de la misma manera que importamos los m\u00f3dulos definidos por nosotros. En la documentaci\u00f3n de Python en espa\u00f1ol encontramos la referencia a La biblioteca est\u00e1ndar de Python.</p>"},{"location":"programacion/python/#eventos-para-los-botones","title":"Eventos para los botones","text":"<p>Si trabajamos con versiones anteriores a V2 solamente disponemos de los botones A, B y A+B, pero si tenemos una versi\u00f3n V2 tambi\u00e9n disponemos del bot\u00f3n t\u00e1ctil incorporado en el logo, aunque a todos los efectos este se considera un pin de entrada.</p> <p>El logo no es tratado exactamente como un bot\u00f3n, sino como un pin de nombre logo. En el borde existen otros tres pines, los 0, 1 y 2. Por ello la forma de trabajar con el logo va a ser un poco diferente, como veremos en la actividad A04.</p> <p>La diferencia fundamental, ademas de la forma, es que el logo es un sensor capacitivo y los pines son sensores resistivos. En la pr\u00e1ctica esto significa que el logo funciona simplemente tocandolo y los pines necesitan cerrar el circuito con GND, por lo que para que funcionen como pulsador debemos tocar tanto el pinto como GND.</p> <p>Si queremos que MicroPython reaccione a los eventos de pulsaci\u00f3n de los botones, debemos ponerlo en un bucle infinito y comprobar si el bot\u00f3n <code>is_pressed</code>.</p> <ul> <li>Funci\u00f3n <code>is_pressed()</code></li> </ul> <p>Para trabajar con los botones de la micro:bit tenemos disponibles funciones que se han cargado al importar el m\u00f3dulo <code>microbit</code>. Estas funciones est\u00e1n basadas en la funci\u00f3n gen\u00e9rica <code>is_pressed()</code> pensada para saber que tecla de un teclado se ha pulsado. Sin embargo, en el caso de MicroPython a para micro:bit a estos botones se les ha asignado un nombre a cada uno, <code>button_a</code> para el A y  <code>button_b</code> para el B, de manera que para usarlos se llama al bot\u00f3n y con el operador <code>.</code> a la funci\u00f3n <code>is_pressed()</code>. Por ejemplo, <code>button_a.is_pressed()</code> es el c\u00f3digo encargado de saber si estamos pulsando el bot\u00f3n A y <code>button_b.is_pressed()</code> si lo es el B.</p> <ul> <li>Funci\u00f3n <code>get_pressed()</code></li> </ul> <p>Esta funci\u00f3n retorna el total acumulado de pulsaciones de botones y restablece este total a cero antes de volver. Es decir, podemos capturar el n\u00famero de veces que hemos pulsado un bot\u00f3n. El valor de retorno es un n\u00famero, por lo que, para mostrarlo en la pantalla de LEDs hay que convertirlo en cadena con la funci\u00f3n <code>str()</code>.</p> <ul> <li>Funci\u00f3n <code>was_pressed()</code></li> </ul> <p>Devuelve <code>True</code> o <code>False</code> para indicar si se ha presionado el bot\u00f3n desde la \u00faltima vez que se inicio el dispositivo o se llam\u00f3 a este m\u00e9todo. Llamar a este m\u00e9todo borra el estado de que ha sido pulsado, de modo que el bot\u00f3n debe pulsarse de nuevo antes de que este m\u00e9todo vuelva a retornar <code>True</code>.</p> <p>Vamos a hacer un ejemplo que aclarar\u00e1 mejor lo explicado. Se trata de crear un programa (le podremos de nombre Caritas_X) en el que mientras mantegamos pulsado el bot\u00f3n A se muestra una cara sonriente, si no se pulsa ning\u00fan bot\u00f3n se muestra una cara triste y si se pulsa el bot\u00f3n B la cara desaparece (se apagan todos los LEDs) y tras 2 segundos aparece una X que se va haciendo cada vez mas grande partiendo del punto central. Finalmente pasados otros 2 segundos el programa vuelve a empezar. El c\u00f3digo es:</p> <pre><code>from microbit import *\nwhile True:\n    while True:\n        if button_a.is_pressed():\n            display.show(Image.HAPPY)\n        elif button_b.is_pressed():\n            break\n        else:\n            display.show(Image.SAD)\n\n    display.clear()\n    sleep(2000)\n    mi_X_peque = Image(\"00000:00000:00900:00000:0000\")\n    display.show(mi_X_peque)\n    sleep(200)\n    mi_X_media = Image(\"00000:09090:00900:09090:0000\")\n    display.show(mi_X_media)\n    sleep(200)\n    mi_X_grande = Image(\"90009:09090:00900:09090:90009\")\n    display.show(mi_X_grande)\n    sleep(2000)\n</code></pre> <p>En la animaci\u00f3n siguiente vemos como funciona</p> <p> <p> Funcionamiento de Caritas_X</p> <p></p> <p>Si observamos con cuidado apreciaremos que en alg\u00fan momento se accionan los botones A y B pero los que aparecen en la parte inferior, debajo de la pantalla de simulaci\u00f3n. Est\u00e1n al lado de un logotipo que indica que se pulsen con una flechita. Justo debajo de estos aparecen los citados del borde de placa y el logo junto a ellos, pues es tratado asi, como un pin, y adem\u00e1s a su izquierda hay un candado cerrado indicativo de que no se est\u00e1 usando ninguno de ellos. En la imagen siguiente se ve mejor lo indicado.</p> <p> <p> Control de acciones del simulador</p> <p></p> <p>Vamos a crear otro ejemplo en el que se cuenten las veces que pulsamos el bot\u00f3n A o el bot\u00f3n B durante un tiempo de 3 segundo. El programa es el siguiente:</p> <pre><code>from microbit import *\n\nsleep(3000) #Espera de 3 segundos\n\n#Convertimos n\u00famero a cadena con str()\npulsado = str(button_b.get_presses())\n\ndisplay.show(pulsado)\n\n# Por si hemos pulsado mas de 9 veces\ndisplay.scroll(pulsado)\n</code></pre> <p>En la 'Referencia' del compilador, dentro de Botones tenemos un ejemplo que nos indica el bot\u00f3n que hemos pulsado con cuatro opciones posibles, el A, el B, A o B y finalmente A y B. Animamos a cargarlos y probarlos para familiarizarnos todo lo posible con ellos.</p>"},{"location":"programacion/python/#pines-de-entradasalida","title":"Pines de Entrada/salida","text":""},{"location":"programacion/python/#digital","title":"Digital","text":"<p>Podemos utilizar los pines 0, 1 y 2 del borde de placa en modo digital tanto para leer su valor como para escribir o establecer su valor. Esto se representa con un \"1\" l\u00f3gico (sin las comillas) si est\u00e1n activados o los queremos activar y un \"0\" l\u00f3gico si est\u00e1n desactivados o los queremos desactivar.</p> <p>Si queremos escribir en ellos los pines estar\u00e1n actuando como salidas y tenemos que invocar al m\u00e9todo <code>write</code> para hacerlo. Las sentencias, para un pin gen\u00e9rico \"N\" son:</p> <pre><code>pinN.write_digital(1) #Salida en estado alto\npinN.write_digital(0) #Salida en estado bajo\n</code></pre> <p>Tambi\u00e9n podemos conectar, por ejemplo un interruptor o bot\u00f3n pulsador al pin (veremos como hacerlo en la siguiente actividad) y comprobar si el interruptor est\u00e1 abierto (0) o cerrado (1). En este caso los pines estar\u00e1n configurados como entradas y la lectura de su estado se obtiene invocando el m\u00e9todo <code>read</code>.  Las sentencias, para un pin gen\u00e9rico \"N\" son:</p> <pre><code>pinN.read_digital() #Devuelve el estado 0 o 1 del pin N\n</code></pre> <p>Nunca se conecta nada a los pines con un voltaje superior a 3v porque se puede da\u00f1ar la micro:bit.</p>"},{"location":"programacion/python/#analogica","title":"Anal\u00f3gica","text":"<p>Podemos utilizar los pines 0, 1 y 2 del borde de placa en modo anal\u00f3gico tanto para leer su valor como para escribir o establecer su valor. Esto significa que en lugar de estar activos o inactivos (0 o 1), var\u00edan su valor entre 0 y 1023.</p> <p>Si queremos escribir en ellos los pines estar\u00e1n actuando como salidas y tenemos que invocar al m\u00e9todo <code>write</code> para hacerlo. La sentencia, para un pin gen\u00e9rico \"N\" es:</p> <pre><code>pinN.write_analog(valor) #valor puede estar entre 0 y 1023\n</code></pre> <p>Si conectamos sensores o actuadores anal\u00f3gicos a los pines podemos leer su valor invocando a <code>read</code>. La sentencia, para un pin gen\u00e9rico \"N\" es:</p> <pre><code>pinN.read_analog(valor) #valor puede estar entre 0 y 1023\n</code></pre>"},{"location":"programacion/python/#numeros-aleatorios","title":"N\u00fameros aleatorios","text":"<p>Este m\u00f3dulo est\u00e1 basado en el m\u00f3dulo <code>random</code> de la librer\u00eda est\u00e1ndar de Python. Contiene funciones para generar comportamientos aleatorios.</p> <p>Para acceder a este m\u00f3dulo es necesario:</p> <pre><code>import random\n</code></pre> <p>Vamos a ver sus funciones a continuaci\u00f3n.</p> <ul> <li><code>.getrandbits(n)</code>. Retorna un entero con \"n\" bits aleatorios. La funci\u00f3n generadora devuelve como m\u00e1ximo 30 bits, por lo tanto \"n\" tiene que estar comprendido entre 1 y 30.</li> </ul> <p><pre><code>random.getrandbits(n)\n</code></pre> * <code>.seed(n)</code>. Inicializa el generador de n\u00fameros aleatorios con un n\u00famero entero conocido \"n\". Esto le proporcionar\u00e1 una aleatoriedad determinista reproducible a partir de un estado inicial dado (n).</p> <pre><code>random.seed(n)\n</code></pre> <ul> <li><code>.randint(a, b)</code>. Devuelve un entero aleatorio N tal que a \\space \\leq N \\leq \\space b.</li> </ul> <pre><code>random.randint(a, b)\n</code></pre> <ul> <li><code>.randrange(stop)</code>. Devuelve un n\u00famero entero seleccionado aleatoriamente entre cero y stop, que no est\u00e1 incluido.</li> </ul> <pre><code>random.randrange(stop)\n</code></pre> <ul> <li><code>.randrange(start, stop)</code>. Devuelve un n\u00famero entero seleccionado aleatoriamente comprendido entre start y stop. El l\u00edmite stop no est\u00e1 incluido.</li> </ul> <pre><code>random.randrange(start, stop)\n</code></pre> <ul> <li><code>.randrange(start, stop, step)</code>. Devuelve un n\u00famero entero aleatorio entre start y stop separando los valores posibles entre si la distancia establecida por step. Por ejemplo <code>randrange(3, 30, 5)</code> devolver\u00e1 un valor aleatorio de los siguientes posibles: 3, 8, 13, 18, 23, 28.</li> </ul> <pre><code>random.randrange(start, stop, step)\n</code></pre> <ul> <li><code>.choice(secuencia)</code>. Devuelve un elemento aleatorio de 'secuencia' que no puede estar vac\u00eda. Si 'secuencia' est\u00e1 vac\u00eda, genera in <code>IndexError</code>.</li> </ul> <pre><code>random.choice(secuencia)\n</code></pre> <ul> <li><code>.random()</code>. Devuelve un n\u00famero aleatorio en coma flotante en el rango [0.0, 1.0).</li> </ul> <pre><code>random.random()\n</code></pre> <ul> <li><code>.uniform(a, b)</code>. Devuelve un n\u00famero aleatorio de coma flotante N tal que a  \\leq N \\leq  b para a  \\leq  b y b  \\leq N \\leq  a para b  &lt;  a.</li> </ul> <pre><code>random.uniform(a, b)\n</code></pre> <p>En la imagen vemos ejemplos ejecutados en la shell.</p> <p> <p> Ejemplos de funciones de random</p> <p></p>"},{"location":"programacion/python/#modulo-neopixel","title":"M\u00f3dulo NeoPixel","text":"<p>Clases Operaciones Uso del m\u00f3dulo NeoPixel Ejemplo</p> <p>El m\u00f3dulo neopixel permite programar de forma sencilla tiras de LEDs NeoPixel (WS2812) RGB y RGBW direccionables individualmente con la micro:bit. Para utilizar el m\u00f3dulo neopixel, es necesario importarlo con:</p> <pre><code>import neopixel\n</code></pre> <p> <p>Nota:  Seg\u00fan las pruebas realizadas por el equipo t\u00e9cnico de micro:bit, el m\u00f3dulo NeoPixel de Microbit puede controlar hasta 256 NeoPixels. Por encima de esa cantidad, es posible que se produzcan errores y problemas extra\u00f1os. La micro:bit por si misma tan s\u00f3lo puede suministrar 90mA a dispositivos externos, un mayor n\u00famero de NeoPixels requiere una fuente de alimentaci\u00f3n externa que debe tener la masa com\u00fan con la micro:bit.</p> <p>Los NeoPixels est\u00e1n dise\u00f1ados para trabajar a 5V, pero funcionan usando la alimentaci\u00f3n de 3V de la BBC micro:bit. Debemos tener muy presente que el conector de borde de la micro:bit no debe conectarse a nada que suministre 5V.</p> <p>Este m\u00f3dulo contiene todo lo necesario para conectarlas a una micro:bit y crear divertidas pantallas, arte y juegos como esta demo.</p> <p> <p>Attibuci\u00f3n: adafruit flexible Neopixel matrix</p> <p></p> <p>La forma de conectar una tira de neop\u00edxeles a la micro:bit es como se muestra a continuaci\u00f3n, suponiendo que vamos a controlar los p\u00edxeles desde el pin0. Tambi\u00e9n podemos conectar neop\u00edxeles a los pines 1 y 2.</p> <p> <p> Conexi\u00f3n de neopixeles a micro:bit</p> <p>Imagen obtenida de: Enlace</p> <p></p> <p>La etiqueta de la pinza de cocodrilo indica d\u00f3nde hay que conectar el otro extremo en la tira de neopixels. En algunas variantes de neop\u00edxeles, el pin VDD puede tener otro nombre, por ejemplo \"V+\" o \"+5V\" y s\u00f3lo es seguro utilizarlo si no hay otros dispositivos de 5V conectados.</p> <p> <p>Aviso:  El conector de 3v de la micro:bit no se puede utilizar para alimentar a m\u00e1s de 8 Neopixels a la vez. Si estsamos utilizando m\u00e1s de 8 Neopixels, es necesaria una fuente de alimentaci\u00f3n externa de 3v a 5v para el pin de alimentaci\u00f3n de los Neopixeles.</p> <p>Volver </p> <p>Clases</p> <pre><code>class neopixel.NeoPixel(pin, n, bpp=3)\n</code></pre> <p>Inicializa una nueva tira con un n\u00famero <code>n</code> de LEDs neopixel controlados a trav\u00e9s de la patilla indicada en <code>pin</code>. El tercer argumento sirve para especificar el tipo de neopixel indicando el n\u00famero de bytes por pixel (<code>bpp</code>). Este par\u00e1metro vale 4 para neopixels RGBW (LED blanco) y 3 para RGB y GRB. Las siglas RGB y GRB, adem\u00e1s de hacer referencia a los colores se refieren al orden en el que est\u00e1n dispuestos los LEDs internamente, siendo RGB el mas normal en productos WS2812.</p> <p>A cada p\u00edxel se le asigna una posici\u00f3n (empezando por 0). Los neop\u00edxeles reciben valores RGB (rojo, verde, azul) o RGBW (rojo, verde, azul, blanco) entre 0 y 255 como una tupla. Por ejemplo, en RGB, <code>(255,255,255)</code> es blanco. En RGBW, <code>(255,255,255,0)</code> o <code>(0,0,0,255)</code> es blanco.</p> <ul> <li><code>clear()</code>. Borra todos los pixeles</li> <li><code>show()</code>. Muestra los p\u00edxeles. Debe invocarse para que las actualizaciones sean visibles.</li> </ul> <p>Volver </p> <p>Operaciones</p> <p>Escribir el color no actualiza la pantalla, debemos utilizar <code>show()</code> para hacerlo.</p> <pre><code>from microbit import *\nimport neopixel\nneo = neopixel.NeoPixel(pin0,8,3)\nneo[0] = (255,0,128) # primer LED\nneo[-1] = (0,255,0) #ultimo LED\nneo.show() # solo ahora se muestran los valores actualizados\n</code></pre> <p>Para leer el color de un pixel concreto basta con hacer referencia a \u00e9l.</p> <pre><code>print(neo[0])\n</code></pre> <p>Volver </p> <p>Uso del m\u00f3dulo NeoPixel</p> <p>Una forma sencilla de interactuar con los Neopixels es considerarlos como una lista de tuplas. Cada tupla representa la mezcla de colores RGB o RGBW de un p\u00edxel espec\u00edfico.</p> <p>Por ejemplo, inicializamos una tira o anillo de 8 neopixels RGB como conectados al pin0 de la siguiente manera:</p> <pre><code>neo = neopixel.NeoPixel(pin0,8)\n</code></pre> <p>Establecemos los p\u00edxeles index\u00e1ndolos, como con una lista de Python. Por ejemplo, para establecer el primer p\u00edxel en rojo a brillo m\u00e1ximo, se utilizar\u00eda:</p> <pre><code>neo[0] = (255,0,0)\n</code></pre> <p>O el \u00faltimo pixel a magenta:</p> <pre><code>neo[-1] = (255,0,255)\n</code></pre> <p>Para obtener el valor de la tupla del color actual de un p\u00edxel lo indexamos. Por ejemplo, para imprimir el valor RGB del primer p\u00edxel usamos:</p> <pre><code>print(neo[0])\n</code></pre> <p>Finalmente para poner los datos de colores en los neopixeles usamos la funci\u00f3n <code>neo.show()</code>:</p> <pre><code>neo.show()\n</code></pre> <p>Si no vemos los cambios posiblemente se deba al olvido de este paso final.</p> <p>Volver </p> <p>Ejemplo</p> <pre><code>from microbit import *\nimport neopixel\n\"\"\"\n    Muestra de manera continuada colores aleatorios en los LEDs\n    El ejemplo se realiza para un anillo o tira de 8 LEDs WS2812 conectados a pin0\n\"\"\"\nfrom random import randint\n\n# Configuramos los Neopixel en pin0 y tira de 8 pixeles\nneo = neopixel.NeoPixel(pin0, 8)\nnum_pixel = 0\n\nwhile True:\n    # Iteramos sobre cada LED de la tira\n\n    if num_pixel &lt; 7:\n        for num_pixel in range(0, len(neo)):\n            rojo = randint(0, 60)\n            verde = randint(0, 60)\n            azul = randint(0, 60)\n\n            # Asigna al LED actual un valor aleatorio de rojo, verde y azul entre 0 y 60\n            neo[num_pixel] = (rojo, verde, azul)\n\n            # Muestra los datos actuales en la tira\n            neo.show()\n            sleep(100)\n        else:\n            neo.clear()\n            sleep(100)\n            num_pixel = 0\n</code></pre> <p>Descargar el programa</p>"},{"location":"programacion/python/#musica","title":"M\u00fasica","text":"<p>MicroPython de BBC micro:bit viene acompa\u00f1ado de un potente m\u00f3dulo de m\u00fasica y sonido. Es muy f\u00e1cil generar pitidos y zumbidos desde el dispositivo conectando un altavoz o unos auriculares con cable, o utilizando el altavoz integrado si estamos con una versi\u00f3n V2.</p> <p>La forma de conectar unos auriculares est\u00e1 descrita en el apartado de MakeCode. Tambi\u00e9n se puede conectar un zumbador piezoel\u00e9ctrico pasivo o un altavoz con pinzas de cocodrilo.  Estos elementos pueden estar polarizados por lo que tendremos que comprobar si existe un terminal \"+\", y si es as\u00ed conectar al pin0.</p> <p> <p> Conexi\u00f3n de zumbador pasivo</p> <p></p> <p> <p>Nota:  Debemos asegurarnos de que el zumbador es pasivo y no activo, que tan solo puede reproducir un tono. En el apartado 'Componentes discretos' de Conceptos t\u00e9cnicos podemos encontrar como distinguirlos.</p> <p>Para trabajar con m\u00fasica hacemos:</p> <pre><code>import music\nmusic.play(music.NYAN)\n</code></pre> <p>Tenemos que importar m\u00f3dulo <code>music</code> que contiene los m\u00e9todos para crear y controlar el sonido.</p> <p>La funci\u00f3n de autocompletado de MicroPython nos muestra las melodias incorporadas.</p> <p> <p> Melodias que acompa\u00f1an a MicroPython</p> <p></p> <p>En la referencia de la API podemos encontrar mas inforamci\u00f3n en ingl\u00e9s sobre Music</p> <p>Cada nota tiene un nombre como Do# (C#) o Fa (F), una octava, que indica lo alta o baja que debe tocarse y una duraci\u00f3n. Las octavas se indican con un n\u00famero, siendo 0 la octava m\u00e1s baja, 4 la del Do central y 8 es la m\u00e1s alta. Las duraciones tambi\u00e9n se expresan con n\u00fameros. Estos valores est\u00e1n relacionados entre s\u00ed: por ejemplo, una duraci\u00f3n de 4 es el doble que una duraci\u00f3n de 2 (y as\u00ed sucesivamente). Si utilizamos como nombre de nota <code>R</code>, MicroPython reproducir\u00e1 un silencio de la duraci\u00f3n especificada.</p> <p>Cada nota se expresa como una cadena de caracteres como \u00e9sta:</p> <pre><code>Nombre_nota[octave][:duration] #La1:4 (A1:4) es un La en la octava 1 con una duraci\u00f3n de 4\n</code></pre> <p>Crear listas de notas para hacer una melodia es similar a crear una animaci\u00f3n con una lista de im\u00e1genes. En el ejemplo vemos como ser\u00eda la apertura de \"Frere Jaques\":</p> <pre><code>import music\n\nfrere_jaques_o = [\"C4:4\", \"D4:4\", \"E4:4\", \"C4:4\", \"C4:4\", \"D4:4\", \"E4:4\", \"C4:4\",\n        \"E4:4\", \"F4:4\", \"G4:8\", \"E4:4\", \"F4:4\", \"G4:8\"]\nmusic.play(frere_jaques_o)\n</code></pre> <p>El ejemplo se puede re-escribir como vemos a continuaci\u00f3n ya que los valores de octava y duraci\u00f3n se rpiten hasta que se indique un cambio.</p> <pre><code>import music\n\nfrere_jaques_o = [\"C4:4\", \"D\", \"E\", \"C\", \"C\", \"D\", \"E\", \"C\", \"E\", \"F\", \"G:8\",\n        \"E:4\", \"F\", \"G:8\"]\nmusic.play(frere_jaques_o)\n</code></pre> <p>MicroPython nos permite crear tonos que no son notas musicales. Por ejemplo, este c\u00f3digo crea un efecto de sirena de polic\u00eda:</p> <pre><code>import music\n\nwhile True:\n    for frecuencia in range(880, 1760, 16):\n        music.pitch(frecuencia, 6)\n    for frecuencia in range(1760, 880, -16):\n        music.pitch(frecuencia, 6)\n</code></pre> <p>El m\u00e9todo <code>music.pitch</code> utiliza una frecuencia que puede ser la de una nota musical. En los rangos de <code>frecuencia</code> se especifican los tonos de los sonidos de una sirena como \"valor inicial, valor final y paso\". Cuando el paso en positivo sube el tono y cuando es negativo lo baja.</p> <p>El ejemplo tambi\u00e9n nos muestra como anidar distintos tipos de bucle.</p>"},{"location":"programacion/python/#funciones-de-la-uart","title":"Funciones de la UART","text":"<ul> <li><code>uart.any()</code>. Devuelve <code>True</code> si hay datos en espera, en caso contrario <code>False</code>.</li> <li><code>uart.read([nbytes])</code>. Leer bytes. Si se especifica <code>nbytes</code>, se leen como m\u00e1ximo esa cantidad de bytes; de lo contrario, se leen tantos bytes como sea posible. El valor de retorno es un objeto bytes o <code>None</code> si se agota el tiempo de espera. Llamamos objeto bytes a una secuencia de bytes. Dado que los caracteres ASCII caben en un \u00fanico byte, este tipo de objeto se utiliza a menudo para representar texto simple y ofrece m\u00e9todos para manipularlo como tal, por ejemplo, puede mostrar el texto utilizando la funci\u00f3n print().</li> </ul> <pre><code>msg_bytes = uart.read()\nmsg_str = str(msg, 'UTF-8')\n</code></pre> <ul> <li><code>uart.readinto(buf[, nbytes])</code>. Lee bytes en el buffer. Si se especifica nbytes, se leen como m\u00e1ximo esa cantidad de bytes. Si no, lee como m\u00e1ximo len(buf) bytes. Valor de retorno: n\u00famero de bytes le\u00eddos y almacenados en buf o <code>None</code> si se agota el tiempo de espera.</li> <li><code>uart.readline()</code>. Leer una l\u00ednea, terminando en un car\u00e1cter de nueva l\u00ednea, que se incluye en los bytes devueltos. Valor de retorno: la l\u00ednea le\u00edda o ``None```.</li> <li><code>uart.write(buf)</code>. Escribe el buffer en el . Valor de retorno: n\u00famero de bytes escritos o <code>None</code> si se agota el tiempo de espera. Puede ser un objeto bytes o una cadena:</li> </ul> <pre><code>uart.write('hello world')\nuart.write(b'hello world')\nuart.write(bytes([1, 2, 3]))\n</code></pre>"},{"location":"programacion/python/#magnetometro-y-acelerometro","title":"Magnet\u00f3metro y aceler\u00f3metro","text":""},{"location":"programacion/python/#acelerometro","title":"Aceler\u00f3metro","text":"<p>Este objeto permite acceder al aceler\u00f3metro de la placa.</p> <p>Por defecto MicroPython establece el rango del aceler\u00f3metro en \u00b1 2000 mg (siendo g una unidad de aceleraci\u00f3n basada en la gravedad est\u00e1ndar), que configura los valores m\u00e1ximo y m\u00ednimo devueltos por las funciones del aceler\u00f3metro. El rango puede cambiarse mediante microbit.accelerometer.set_range().</p> <p>El aceler\u00f3metro tambi\u00e9n proporciona funciones de conveniencia para detectar gestos. Los gestos reconocidos se representan como cadenas: arriba (up), abajo (down), izquierda (left), derecha (right), boca arriba (face up), boca abajo (face down), ca\u00edda libre (freefall), 3g, 6g, 8g, sacudida (shake).</p> <p>Nota: Los gestos no se actualizan en segundo plano por lo que es necesario realizar llamadas constantes a alg\u00fan m\u00e9todo del aceler\u00f3metro para realizar la detecci\u00f3n de gestos. Normalmente los gestos pueden ser detectados usando un bucle con un peque\u00f1o retardo <code>microbit.sleep()</code>.</p> <p>Sus funciones son:</p> <ul> <li><code>microbit.accelerometer.get_x()</code></li> <li><code>microbit.accelerometer.get_y()</code></li> <li> <p><code>microbit.accelerometer.get_z()</code></p> <p>Retorna como un entero positivo o negativo la aceleraci\u00f3n medida en el eje correspondiente en mili-g.</p> </li> <li> <p><code>microbit.accelerometer.get_values()</code></p> <p>Devuelve las medidas de aceleraci\u00f3n en todos los ejes a la vez, como una tupla de tres elementos de enteros ordenados como X, Y, Z.</p> </li> <li> <p><code>microbit.accelerometer.get_strength()</code></p> <p>Obtiene la medida de la aceleraci\u00f3n de todos los ejes combinados, como un entero positivo. Es la suma pitag\u00f3rica de los ejes X, Y y Z. Devuelve la fuerza de aceleraci\u00f3n combinada de todos los ejes, en mili-g.</p> </li> <li> <p><code>microbit.accelerometer.current_gesture()</code></p> <p>Devuelve una cadena con el nombre del gesto actual.</p> </li> <li> <p><code>microbit.accelerometer.is_gesture(name)</code></p> <p>El par\u00e1metro <code>name</code> es una cadena con el nombre del gesto a comprobar. Devuelve un valor booleano que indica si el gesto nombrado est\u00e1 activo actualmente.</p> </li> <li> <p><code>microbit.accelerometer.was_gesture(name)</code></p> <p>El par\u00e1metro <code>name</code> es una cadena con el nombre del gesto a comprobar. Devuelve un valor booleano que indica si el gesto nombrado ha estado activo desde la \u00faltima vez.</p> </li> <li> <p><code>microbit.accelerometer.get_gestures()</code></p> <p>Se usa para obtener una lista hist\u00f3rica de los gestos registrados. Al llamar a esta funci\u00f3n se borra el hist\u00f3rico de gestos antes de devolver el valor. Devuelve una tupla del historial de gestos, el m\u00e1s reciente aparece en \u00faltimo lugar.</p> </li> <li> <p><code>microbit.accelerometer.set_range(value)</code></p> <p>Ajusta el rango de sensibilidad del aceler\u00f3metro, en g (gravedad est\u00e1ndar), a los valores m\u00e1s cercanos soportados por el hardware, de forma que redondee a 2, 4 u 8 g. El par\u00e1metro <code>value</code> establece el nuevo rango para el aceler\u00f3metro, un entero en g.</p> </li> </ul> <p>A continuaci\u00f3n vamos a ver los ejemplos que aparecen en la documentaci\u00f3n oficial traducidos.</p> <p>Ejemplo 1. Una bola 8 m\u00e1gica que adivina el futuro. Haz una pregunta y agita el dispositivo para obtener una respuesta.</p> <pre><code># Magic 8 ball by Nicholas Tollervey. February 2016.\n# Bola m\u00e1gica 8 por Nicholas Tollervey. Febrero 2016.\n# Ask a question then shake.\n# Haz una pregunta y agita la micro:bit\n# This program has been placed into the public domain.\n# Este programa es de dominio p\u00fablico.\n\nfrom microbit import *\nimport random\n\nrespuestas = [\n    \"Es cierto\",\n    \"Es decididamente as\u00ed\",\n    \"Sin duda alguna\",\n    \"S\u00ed, definitivamente.\",\n    \"Puedes confiar en ello\",\n    \"Como yo lo veo, s\u00ed\",\n    \"Lo m\u00e1s probable\",\n    \"Buenas perspectivas\",\n    \"Si\",\n    \"Los indicios apuntan a que s\u00ed\",\n    \"Respuesta dudosa int\u00e9ntalo de nuevo\",\n    \"Vuelve a preguntar m\u00e1s tarde\",\n    \"Mejor no te lo digo ahora\",\n    \"No se puede predecir ahora\",\n    \"Conc\u00e9ntrate y vuelve a preguntar\",\n    \"No cuentes con ello\",\n    \"Mi respuesta es no\",\n    \"Mis fuentes dicen que no\",\n    \"Perspectivas no tan buenas\",\n    \"Muy dudoso\",\n]\n\nwhile True:\n    display.show('8')\n    if accelerometer.was_gesture('shake'):\n        display.clear()\n        sleep(1000)\n        display.scroll(random.choice(respuestas))\n    sleep(10)\n</code></pre> <p>Descargar el programa .hex</p> <p>Descargar el programa .py</p> <p>Ejemplo 2. Un juego consistentente en evitar obst\u00e1culos moviendo la micro:bit.</p> <pre><code># Simple Slalom by Larry Hastings, September 2015\n# Eslalon simple de Larry Hastings, septiembre de 2015.\n# This program has been placed into the public domain.\n# Este programa es de dominio p\u00fablico.\nimport microbit as m\nimport random\n\np = m.display.show\nmin_x = -1024\nmax_x = 1024\nrange_x = max_x - min_x\nwall_min_speed = 400\nplayer_min_speed = 200\nwall_max_speed = 100\nplayer_max_speed = 50\nspeed_max = 12\n\nwhile True:\n\n    i = m.Image('00000:'*5)\n    s = i.set_pixel\n    player_x = 2\n    wall_y = -1\n    hole = 0\n    score = 0\n    handled_this_wall = False\n    wall_speed = wall_min_speed\n    player_speed = player_min_speed\n    wall_next = 0\n    player_next = 0\n\n    while True:\n        t = m.running_time()\n        player_update = t &gt;= player_next\n        wall_update = t &gt;= wall_next\n        if not (player_update or wall_update):\n            next_event = min(wall_next, player_next)\n            delta = next_event - t\n            m.sleep(delta)\n            continue\n\n        if wall_update:\n            # calculate new speeds\n            speed = min(score, speed_max)\n            wall_speed = wall_min_speed + int((wall_max_speed - wall_min_speed) * speed / speed_max)\n            player_speed = player_min_speed + int((player_max_speed - player_min_speed) * speed / speed_max)\n            wall_next = t + wall_speed\n            if wall_y &lt; 5:\n                # erase old wall\n                use_wall_y = max(wall_y, 0)\n                for wall_x in range(5):\n                    if wall_x != hole:\n                        s(wall_x, use_wall_y, 0)\n        wall_reached_player = (wall_y == 4)\n        if player_update:\n            player_next = t + player_speed\n            # find new x coord\n            x = m.accelerometer.get_x()\n            x = min(max(min_x, x), max_x)\n            # print(\"x accel\", x)\n            s(player_x, 4, 0) # turn off old pixel\n            x = ((x - min_x) / range_x) * 5\n            x = min(max(0, x), 4)\n            x = int(x + 0.5)\n            # print(\"have\", position, \"want\", x)\n            if not handled_this_wall:\n                if player_x &lt; x:\n                    player_x += 1\n                elif player_x &gt; x:\n                    player_x -= 1\n            # print(\"new\", position)\n            # print()\n        if wall_update:\n            # update wall position\n            wall_y += 1\n            if wall_y == 7:\n                wall_y = -1\n                hole = random.randrange(5)\n                handled_this_wall = False\n            if wall_y &lt; 5:\n                # draw new wall\n                use_wall_y = max(wall_y, 0)\n                for wall_x in range(5):\n                    if wall_x != hole:\n                        s(wall_x, use_wall_y, 6)\n        if wall_reached_player and not handled_this_wall:\n            handled_this_wall = True\n            if (player_x != hole):\n                # collision! game over!\n                break\n            score += 1\n        if player_update:\n            s(player_x, 4, 9) # turn on new pixel\n        p(i)\n    p(i.SAD)\n    m.sleep(1000)\n    m.display.scroll(\"Score:\" + str(score))\n    while True:\n        if (m.button_a.is_pressed() and m.button_a.is_pressed()):\n            break\n        m.sleep(100)\n</code></pre> <p>Descargar el programa .hex</p> <p>Descargar el programa .py</p>"},{"location":"programacion/python/#magnetometro","title":"Magnet\u00f3metro","text":"<p>Este m\u00f3dulo permite acceder a la br\u00fajula electr\u00f3nica incorporada. Antes de utilizarla, la br\u00fajula debe estar calibrada; de lo contrario, las lecturas pueden ser err\u00f3neas.</p> <p>Advertencia. Calibrar la br\u00fajula har\u00e1 que su programa se detenga hasta que se complete la calibraci\u00f3n. La calibraci\u00f3n consiste en un peque\u00f1o juego para dibujar un c\u00edrculo en la pantalla LED girando el dispositivo.</p> <p>Las funciones son:</p> <ul> <li> <p><code>microbit.compass.calibrate()</code></p> <p>Inicia el proceso de calibraci\u00f3n. El mensaje Tilt to Fill Screen (Inclinar para llenar la pantalla) se desplazar\u00e1 en la pantalla que el usuario debe rellenar completamente moviendo el dispositivo.</p> </li> <li> <p><code>microbit.compass.is_calibrated()</code></p> <p>Devuelve <code>True</code> si la br\u00fajula se ha calibrado correctamente, y devuelve <code>False</code> en caso contrario.</p> </li> <li> <p><code>microbit.compass.clear_calibration()</code></p> <p>Deshace la calibraci\u00f3n, haciendo que la br\u00fajula vuelva a estar descalibrada.</p> </li> <li> <p><code>microbit.compass.get_x()</code></p> </li> <li><code>microbit.compass.get_y()</code></li> <li> <p><code>microbit.compass.get_z()</code></p> <p>Da la lectura, como un n\u00famero entero positivo o negativo, de la intensidad del campo magn\u00e9tico en el eje especificado dependiendo de la direcci\u00f3n del campo. La medida se da en nano teslas.</p> </li> <li> <p><code>microbit.compass.heading()</code></p> <p>Da el rumbo de la br\u00fajula, calculado a partir de las lecturas anteriores, como un n\u00famero entero en el rango de 0 a 360, representando el \u00e1ngulo en grados, en el sentido de las agujas del reloj, con el norte como 0.</p> </li> <li> <p><code>microbit.compass.get_field_strength()</code></p> <p>Devuelve un valor entero de la magnitud del campo magn\u00e9tico alrededor del dispositivo expresada en nano tesla.</p> </li> </ul> <p>El ejemplo de creaci\u00f3n de una br\u00fajula nos servir\u00e1 para finalizar estas explicaciones. Antes de nada debemos calibrar la br\u00fajula para despu\u00e9s mostrar la posici\u00f3n de la micro:bit utilizando las flechas predefinidas.</p> <pre><code>from microbit import *\n\n# Antes de nada calibtrar\ncompass.calibrate()\n\n# Mantener la aguja apuntando aproximadamente en la direcci\u00f3n correcta.\nwhile True:\n    sleep(100)\n    aguja = ((15 - compass.heading()) // 30) % 12\n    display.show(Image.ALL_CLOCKS[aguja])\n</code></pre> <p>Descargar el programa .hex</p> <p>Descargar el programa .py</p>"},{"location":"programacion/python/#funciones-para-la-pantalla","title":"Funciones para la pantalla","text":"<ul> <li><code>microbit.display.get_pixel(x, y)</code>. Devuelve el brillo del LED en la columna x y la fila y como un n\u00famero entero entre 0 (apagado) y 9 (brillante).</li> <li><code>microbit.display.set_pixel(x, y, value)</code>. Establece el brillo del LED en la columna x y la fila y como un n\u00famero entero entre 0 y 9.</li> <li><code>microbit.display.clear()</code>. Apaga (pone el brillo a 0) todos los LEDs.</li> <li><code>microbit.display.show(image)</code>. Muestra la imagen.</li> <li><code>microbit.display.show(image, delay=400, *, wait=True, loop=False, clear=False)</code>. Si <code>image</code> es una cadena, un real o un entero, muestra las letras/d\u00edgitos en secuencia. De lo contrario, si <code>image</code> es una secuencia iterable de im\u00e1genes, muestra estas im\u00e1genes en secuencia. Cada letra, d\u00edgito o imagen se muestra con un <code>delay</code> de milisegundos entre ellos.</li> </ul> <p>Si <code>wait</code> es <code>True</code>, esta funci\u00f3n se bloquear\u00e1 hasta que la animaci\u00f3n termine, de lo contrario la animaci\u00f3n ocurrir\u00e1 en segundo plano.</p> <p>Si <code>loop</code> es <code>True</code>, la animaci\u00f3n se repetir\u00e1 para siempre.</p> <p>Si <code>clear</code> es <code>True</code>, la pantalla se borrar\u00e1 despu\u00e9s de que las iteraciones hayan terminado.</p> <p>Los argumentos <code>wait</code>, <code>loop</code> y <code>clear</code> deben especificarse utilizando su palabra clave.</p> <ul> <li><code>microbit.display.scroll(text, delay=150, *, wait=True, loop=False, monospace=False)</code>. Desplaza el texto horizontalmente en la pantalla. Si el texto es un n\u00famero entero o flotante, se convierte primero en una cadena mediante str(). El par\u00e1metro delay controla la velocidad de desplazamiento del texto.</li> </ul> <p>Si <code>wait</code> es <code>True</code>, esta funci\u00f3n se bloquear\u00e1 hasta que la animaci\u00f3n termine, de lo contrario la animaci\u00f3n ocurrir\u00e1 en segundo plano.</p> <p>Si <code>loop</code> es <code>True</code>, la animaci\u00f3n se repetir\u00e1 para siempre.</p> <p>Si <code>monospace</code> es <code>True</code>, todos los caracteres ocupar\u00e1n 5 columnas de p\u00edxeles de ancho, de lo contrario habr\u00e1 exactamente 1 columna de p\u00edxeles en blanco entre cada car\u00e1cter mientras se desplazan.</p> <p>Los argumentos <code>wait</code>, <code>loop</code> y <code>monospace</code> deben especificarse utilizando su palabra clave.</p> <ul> <li><code>microbit.display.on()</code>. Enciende la pantalla.</li> <li><code>microbit.display.off()</code>. Apaga la pantalla. Esto permitir\u00e1 reutilizar los pines GPIO asociados a la pantalla para otros fines.</li> <li><code>microbit.display.is_on()</code>. Devuelve <code>True</code> si la pantalla est\u00e1 encendida, en caso contrario devuelve <code>False</code>.</li> <li><code>microbit.display.read_light_level()</code>. Utiliza los LEDs de la pantalla en modo de polarizaci\u00f3n inversa para detectar la cantidad de luz que incide sobre la pantalla. Devuelve un n\u00famero entero entre 0 (oscuridad) y 255 (m\u00e1ximo brillo) que representa el nivel de luz.</li> </ul>"},{"location":"programacion/python/#i2c","title":"I2C","text":"<p>El m\u00f3dulo I\u00b2C permite comunicarse con dispositivos conectados a la placa utilizando el protocolo de bus I\u00b2C. Puede haber m\u00faltiples dispositivos esclavos conectados al mismo tiempo, y cada uno tiene su propia direcci\u00f3n \u00fanica, que es fija para el dispositivo o configurada en \u00e9l. La placa act\u00faa como maestro I\u00b2C.</p> <p>Veamos las funciones disponibles:</p> <ul> <li><code>microbit.i2c.init(freq=100000, sda=pin20, scl=pin19)</code>. Reinicializa el perif\u00e9rico con la frecuencia de reloj freq especificada en los pines sda y scl especificados.</li> </ul> <p>Advertencia: En una placa micro:bit V1, cambiar los pines I\u00b2C de los predeterminados har\u00e1 que el aceler\u00f3metro y la br\u00fajula dejen de funcionar, ya que est\u00e1n conectados internamente a esos pines. Esta advertencia no se aplica a la revisi\u00f3n V2 del micro:bit ya que esta tiene l\u00edneas I\u00b2C separadas para los sensores de movimiento y el conector de borde.</p> <ul> <li><code>microbit.i2c.scan()</code>. Escanea el bus en busca de dispositivos. Devuelve una lista de direcciones de 7 bits correspondientes a los dispositivos que respondieron al escaneo.</li> <li><code>microbit.i2c.read(addr, n, repeat=False)</code>. Lee n bytes del dispositivo con direcci\u00f3n addr. Si la repetici\u00f3n es <code>True</code>, no se enviar\u00e1 ning\u00fan bit de parada.</li> <li><code>microbit.i2c.write(addr, buf, repeat=False)</code>. Escribe bytes desde buf al dispositivo con direcci\u00f3n addr. Si repeat es <code>True</code>, no se enviar\u00e1 ning\u00fan bit de parada.</li> </ul>"},{"location":"programacion/python/#temperatura","title":"Temperatura","text":"<p>Existe una \u00fanica funci\u00f3n para leer la temperatura interna de la micro:bit:</p> <ul> <li><code>microbit.temperature()</code>. Retorna un entero con la temperatura de la micro:bit en grados Celcius.</li> </ul>"},{"location":"programacion/ublocks/","title":"MicroBlocks","text":"<p>De manera muy resumida lo que haremos en esta secci\u00f3n es:</p> <ul> <li>Describir los bloques y conceptos relacionados.</li> <li>Incluiremos esquemas si resultan necesarios.</li> </ul>"},{"location":"programacion/ublocks/#comentarios","title":"Comentarios","text":"<p>En MicroBlocks los comentarios son tratados desde un \u00fanico bloque que podemos encontrar en el men\u00fa 'Control'. Es un bloque no hace nada. Se utiliza para a\u00f1adir notas y documentaci\u00f3n a los scripts.</p> <p> <p> Comentarios</p> <p></p> <p>La ventana de entrada de texto se autodimensiona seg\u00fan introducimos texto y se pueden a\u00f1adir l\u00edneas pulsando la tecla enter.</p>"},{"location":"programacion/ublocks/#control","title":"Control","text":"<p>En este grupo tenemos acceso a los bloques de control de la micro:bit.</p> <ul> <li>al empezar. Los bloques debajo de este se ejecutan cuando se enciende la placa o cuando se hace clic en el icono verde EJECUTAR que tiene forma de flecha. Es uno de los bloques denominados sombrero.</li> </ul> <p> <p> Bloque 'al empezar'</p> <p></p> <ul> <li>por siempre. Se trata del bloque de la imagen y es un bloque que se ejecuta de manera indefinida.</li> </ul> <p> <p> Bloque 'por siempre'</p> <p></p> <ul> <li>espera xx milisegundos. Espera el n\u00famero de milisegundos indicado antes de continuar.</li> </ul> <p> <p> Bloque 'espera xx milisegundos'</p> <p></p>"},{"location":"programacion/ublocks/#pantalla-led","title":"Pantalla LED","text":"<p>Libreria con los bloques de control de la pantalla LED.</p> <ul> <li>limpia pantalla. Apaga todos los LEDs.</li> </ul> <p> <p> Bloque 'limpia pantalla'</p> <p></p> <ul> <li>pantalla. Muestra una imagen de la pantalla que permite cambiar el estado de cada LED haciendo clic sobre el mismo.</li> </ul> <p> <p> Bloque 'pantalla'</p> <p></p> <ul> <li>anima el texto. Muestra el texto introducido mediante desplazamiento caracter a caracter con el retardo en milisegundos que establezcamos.</li> </ul> <p> <p> Bloque 'anima el texto'</p> <p></p> <ul> <li>enciende x,y. Enciende el LED indicado en la coordenada x,y. La coordenadas x es la horizontal y la y es la vertical. La coordenada 1,1 es la esquina superior ezquierda, la 1,5 es la derecha, la 5,1 es la inferior izquierda y la 5,5 la inferior derecha.</li> </ul> <p> <p> Bloque 'enciende x,y'</p> <p></p>"},{"location":"programacion/ublocks/#operadores","title":"Operadores","text":"<p>Esta entrada se crea porque en MicroBlocks, en el men\u00fa espec\u00edfico, aparecen algunos operadores especiales. Las descripciones siguiente son las obtenidas de MicroBlocks Wiki.</p> <p>Dentro del grupo de bloques est\u00e1ndar tenemos los que se ven en la imagen.</p> <p> <p> Bloques est\u00e1ndar</p> <p></p> <ul> <li>  Devuelve el resto de la divisi\u00f3n entre los dos n\u00fameros introducidos, ambos inclusive.</li> <li> Devuelve un n\u00famero aleatorio (al azar) entre el primer y el segundo valor indicado.</li> </ul> <p>En la imagen vemos un ejemplo donde se averigua si un n\u00famero generado al azar es par o impar.</p> <p>A la variable <code>num_aleatorio</code> se le asigna un n\u00famero aleatorio del 1 al 15. La operaci\u00f3n <code>m\u00f3dulo</code> se utiliza para comprobar si el resto es 0 y as\u00ed saber si el n\u00famero es par. Si el resto de la operaci\u00f3n <code>num_aleatorio</code> dividido por 2 da como resultado 0, el n\u00famero es par, en caso contrario es impar.</p> <p> <p> Par o impar</p> <p></p> <p>Con este ejemplo comprobamos que una vez conectada la micro:bit (si no el programa nos indica que no lo est\u00e1 y no funcionar\u00e1), el bloque <code>di</code> muestra como retorno un mensaje que aparece asociado al bloque <code>al empezar</code> en la pantalla del ordenador. Esta es la forma de trabajar de MicroBlocks y hace que el c\u00f3digo se compruebe de manera instant\u00e1nea siempre que los bloques est\u00e9n acoplados a <code>al empezar</code>.</p> <p>Descargar el programa</p> <ul> <li>  Devuelve <code>True</code> si la expesi\u00f3n de entrada del lado izquierdo coincide con la selecci\u00f3n del men\u00fa de tipos de datos realizada en el lado derecho. Los tipos de datos son importantes a la hora de programar. Aunque un entorno como MicroBlocks facilita las cosas a los usuarios principiantes al encargarse de las conversiones de tipos de datos, todav\u00eda es posible enga\u00f1arse visualmente al comparar variables cuyos valores parecen iguales. Este bloque pertenece al grupo de condicionales, pero se describe ahora porque se utiliza en el ejemplo siguiente.</li> </ul> <p> <p> N\u00famero o cadena</p> <p></p> <p>Descargar el programa</p> <p>Desplegando la secci\u00f3n 'Avanzados' vemos algunos bloques que representan operaciones bit a bit. Los operadores bit a bit (bitwise) trabajan sobre representaciones binarias de datos y su utilidad est\u00e1 en cambiar bits individuales en un operando. Los dos operandos asociados al operador bit a bit deben ser enteros. En la imagen vemos los bloques que aparecen en avanzados.</p> <p> <p> Bloques de operadores avanzados</p> <p></p> <ul> <li> Permite modificar el rango de un valor o variable desde un rango origen a un rango destino. Esta funci\u00f3n es especialmente \u00fatil para adaptar los valores le\u00eddos de sensores o para adaptar valores a aplicar en un actuador.</li> <li> Convierte una cadena Hexadecimal en un n\u00famero decimal. Por ejemplo, 5A hex. = 90 dec.</li> <li>  El operador AND compara dos bits y genera un resultado igual a 1 si ambos bits son 1; en caso contrario, devuelve 0. N\u00fameros de mas de un bit son comparados bit a bit. Un ejemplo de aplicaci\u00f3n lo vemos en la imagen siguiente.</li> </ul> <p> <p> bitwise AND</p> <p></p> <p>La tabla siguiente muestra la forma de obtener el resultado de forma te\u00f3rica.</p> <p> <p> </p> <p></p> <ul> <li>  El operador OR compara dos bits y devuelve 1 si uno o ambos bits son 1 y da 0 si ambos bits son 0. Bitwise OR compara todas las posiciones de bits de ambos n\u00fameros e informa de aquellas en las que cualquiera de los dos est\u00e1 a 1.</li> </ul> <p>Un ejemplo de aplicaci\u00f3n lo vemos en la imagen siguiente.</p> <p> <p> bitwise OR</p> <p></p> <p>La tabla siguiente muestra la forma de obtener el resultado de forma te\u00f3rica.</p> <p> <p> </p> <p></p> <ul> <li>  El operador EXCLUSIVE-OR compara dos bits y genera un resultado de 1 si los bits son complementarios (el bit se establece en un operando pero no en ambos); en caso contrario, devuelve 0. Otra forma de pensar en la operaci\u00f3n XOR es que invertir\u00e1 las posiciones de los bits en las que el segundo operando tenga un 1. Todas las dem\u00e1s se copiar\u00e1n igual.</li> </ul> <p>Un ejemplo de aplicaci\u00f3n lo vemos en la imagen siguiente.</p> <p> <p> bitwise XOR</p> <p></p> <p>La tabla siguiente muestra la forma de obtener el resultado de forma te\u00f3rica.</p> <p> <p> </p> <p></p> <ul> <li>  El operador NOT se utiliza para invertir (BIT FLIP) todos los bits del operando Cuando el bit de posici\u00f3n m\u00e1s alta de un n\u00famero se convierte en 1, ese n\u00famero se considera un n\u00famero negativo. La representaci\u00f3n inform\u00e1tica real de un n\u00famero entero con signo en MicroBlocks es de 31 bits. El bit de mayor peso es un bit de signo. Esto permite n\u00fameros en el rango de -1073741824 a 1073741823. Cuando el bit de signo es 0, el n\u00famero es positivo; y cuando es 1, el n\u00famero es negativo.</li> </ul> <p>Un ejemplo de aplicaci\u00f3n lo vemos en la imagen siguiente.</p> <p> <p> bitwise NOT</p> <p></p> <p>La explicaci\u00f3n es sencilla, el n\u00famero 3 (0011) se convierte al binario 1100 y como el bit de mayor peso es 1 indica que es negativo y el n\u00famero es 4, por lo tanto el resultado es -4.</p> <ul> <li> El valor del operando izquierdo se desplaza hacia la izquierda el n\u00famero de bits especificado por el operando derecho. Los bits se desplazan hacia la izquierda, el bit situado m\u00e1s a la izquierda se descarta y al bit situado m\u00e1s a la derecha se le asigna el valor 0. Cada posici\u00f3n de bit desplazada a la izquierda equivale en binario a multiplicar por 2. En la imagen siguiente vemos el funcionamiento del desplazamiento a la izquierda a nivel de bit.</li> </ul> <p> <p> bitwise desplazamiento izquierda</p> <p></p> <ul> <li> El valor del operando izquierdo se desplaza hacia la derecha el n\u00famero de bits especificado por el operando derecho. Los bits se desplazan hacia la derecha, el bit situado m\u00e1s a la derecha se descarta y al bit situado m\u00e1s a la izquierda se le asigna una copia del bit de signo. Esto se denomina desplazamiento aritm\u00e9tico. Por cada posici\u00f3n de bit desplazada a la derecha, esta operaci\u00f3n es el equivalente binario de dividir por 2. En la imagen siguiente vemos el funcionamiento del desplazamiento a la derecha a nivel de bit.</li> </ul> <p> <p> bitwise desplazamiento izquierda</p> <p></p>"},{"location":"programacion/ublocks/#variables","title":"Variables","text":"<p>En MicroBlocks se contemplan dos tipos de variables, las globales y las locales. Cuando hablamos en estos t\u00e9rminos hablamos de \u00e1mbito (scope) de las variables y determina la zona donde se define la variable, que son global y local.</p> <p>Las variables locales son las definidas dentro de una funci\u00f3n y solamente est\u00e1 disponible para el c\u00f3digo que se ejecuta dentro de la funci\u00f3n.</p> <p>Las variables globales se definen en cualquier punto del programa, normalmente al principio, y pueden ser llamadas desde cualquier sitio del programa, incluso desde las funciones.</p> <ul> <li> Este bloque es en realidad un bot\u00f3n que crea una nueva variable global. Si existe una variable con el mismo nombre, se crear\u00e1 una nueva con el mismo nombre y el n\u00famero 2 a\u00f1adido. Cuando creamos una variable se nos pide el nombre de la misma en una ventana emergente y una vez creada aparecer\u00e1 un nuevo bloque para acceder al valor de la variable creada. Adem\u00e1s esta nueva variable estar\u00e1 disponible para su selecci\u00f3n en dos de los bloques que explicaremos despu\u00e9s.</li> <li>  Este bloque es en realidad un bot\u00f3n que sirve para eliminar una variable previamente creada.</li> </ul> <p>En la animaci\u00f3n siguiente vemos el proceso de creaci\u00f3n y eliminaci\u00f3n de variables.</p> <p> <p> Creaci\u00f3n y eliminaci\u00f3n de variables</p> <p></p> <p>La opci\u00f3n de mostrar el nombre de las variables mostrada desde el bloque se puede utilizar para a\u00f1adir variables mientras se edita el c\u00f3digo del programa, sin pasar a las opciones de la categor\u00eda variables.</p> <ul> <li>  Este bloque asigna el valor a cualquier variable, global o local, en la cantidad especificada en el \u00e1rea de entrada. La cantidad que se asigna puede ser un n\u00famero positivo o negativo. Para mostrar los nombres de las variables locales en el men\u00fa de selecci\u00f3n, este bloque debe estar f\u00edsicamente unido a la secuencia de bloques en la que se utiliza el bloque 'Inicializar local' que veremos a continuaci\u00f3n.</li> <li>  Este bloque suma algebraicamente (cambia) el valor de cualquier variable, global o local, en la cantidad especificada en el \u00e1rea de entrada. La cantidad de cambio puede ser un n\u00famero positivo o negativo.</li> <li>  Este bloque se utiliza para crear e inicializar variables locales. El nombre predeterminado de la variable 'var' puede cambiarse por cualquier otro haciendo clic en el nombre y escribiendo un nuevo nombre en el cuadro de di\u00e1logo que se abre. Desp\u00e9s, si es necesario cambiar el valor de la variable local, se puede utilizar el bloque 'asigna valor a' de la categor\u00eda variables. En la animaci\u00f3n siguiente vemos este proceso y la disponibilidad o no de la variable local.</li> </ul> <p> <p> Inicializa variable local</p> <p></p> <p>Una variable global tiene:</p> <ul> <li>Alcance global: Una variable global puede utilizarse en cualquier script que no tenga una variable local del mismo nombre que la anule.</li> <li>Tiempo de vida largo: Una variable global es creada expl\u00edcitamente y vive hasta que es expl\u00edcitamente borrada. Conserva su valor cuando los scripts se inician y detienen e incluso cuando no hay scripts en ejecuci\u00f3n. Sin embargo, al hacer clic en el bot\u00f3n \"Detener\", todas las variables globales se borran e inicializan con el valor cero. Las variables globales tambi\u00e9n se inicializan a cero cuando se crean por primera vez y cuando se carga un proyecto.</li> </ul> <p>Por el contrario, una variable local tiene:</p> <ul> <li>\u00c1mbito local: Una variable local s\u00f3lo puede utilizarse en el script en el que aparece. Si varios scripts utilizan variables locales con el mismo nombre, esas variables son independientes entre s\u00ed. Aunque esta pr\u00e1ctica se desaconseja porque puede inducir a errores.</li> <li>Tiempo de vida limitado: Una variable local de un script se crea cuando se inicia el script y se elimina cuando \u00e9ste finaliza. Se crea una nueva variable local cada vez que se inicia un script (incluyendo un script de funci\u00f3n), y las variables locales de cada invocaci\u00f3n de script son independientes entre s\u00ed.</li> <li>Precedencia sobre las globales: Si una variable local tiene el mismo nombre que una variable global, la variable local prevalece sobre la global en el script en el que aparece la variable local. Una variable es local en todo el script sin importar en qu\u00e9 parte del script aparezca \"inicializar var local a\", aunque es una buena pr\u00e1ctica de codificaci\u00f3n que \"inicializar var local a\" preceda a cualquier otra referencia a esa variable.</li> </ul> <p>Un ejemplo comentado de aplicaci\u00f3n lo vemos en la imagen siguiente.</p> <p> <p> Variables</p> <p></p> <p>Descargar el programa</p>"},{"location":"programacion/ublocks/#bucles","title":"Bucles","text":"<p>En el caso de MicroBlocks los bucles, condicionales y funciones est\u00e1n todos englobados en la categor\u00eda 'Control'. Vamos a ver algunos de ellos en esta ocasi\u00f3n y los que no veamos en esta actividad se ir\u00e1n viendo cuando los necesitemos.</p> <ul> <li>  Los bloques con forma de sombrero forman parte de un grupo de bloques de control que comienzan a ejecutarse cuando se pulsa el icono verde <code>Inicia</code>. Este bloque se activa cuando se cumple la condici\u00f3n de inicio del programa.</li> <li>  Los bloques con forma de \"C\" son un grupo de bloques de control que ejecutan el c\u00f3digo colocado en su interior siempre que se cumplan las condiciones descritas en sus subt\u00edtulos. Estos son los bloques de tipo bucle. Este en particular ejecutar\u00e1 los bloques en su interior indefinidamente.</li> <li>  Este bloque C ejecuta el c\u00f3digo colocado en su interior el n\u00famero especificado de veces. En el ejemplo siguiente veremos tanto en el programa como en la pantalla la suma de los 10 primero n\u00fameros naturales.</li> </ul> <p> <p> Suma de los 10 primeros n\u00fameros</p> <p></p> <p>Descargar el programa</p> <ul> <li> <p>  Este bloque estambi\u00e9n de tipo C y pertenece al grupo de los bucles. Funciona de dos formas distintas en funci\u00f3n del tipo de entrada especificado.</p> </li> <li> <p>Si la entrada es un n\u00famero, los bloques interiores se ejecutar\u00e1n tantas veces como el n\u00famero. En cada iteraci\u00f3n del bucle, empezando por uno, el par\u00e1metro o variable de control es 'i' por defecto y se incrementar\u00e1 en uno. Este valor se puede utilizar en el c\u00f3digo del programa como se crea conveniente.</p> </li> <li>El nombre del par\u00e1metro de control puede cambiarse por otro haciendo clic en la 'i' y escribiendo un nuevo nombre.</li> <li>Si la entrada es una lista, los bloques colocados dentro se ejecutar\u00e1n tantas veces como elementos tenga la lista. En cada iteraci\u00f3n, el par\u00e1metro de control 'i' tomar\u00e1 el valor de cada elemento de la lista de manera secuencia. En el ejemplo siguiente vemos una animaci\u00f3n de un sencillo programa de como hacer un contador con los 5 primeros n\u00fameros y hacer que se muestre en el ordenador y en la pantalla de la micro:bit.</li> </ul> <p> <p> Mostrar los 5 primeros n\u00fameros</p> <p></p> <p>Descargar el programa</p> <ul> <li>  Este bloque pausa el flujo de ejecuci\u00f3n del programa por el tiempo especificado en milisegundos. Se utiliza para pausar y reanudar la ejecuci\u00f3n de c\u00f3digo de forma controlada.</li> <li>  Este bloque pausa el flujo de ejecuci\u00f3n del programa por el tiempo especificado en microsegundos. Se utiliza para pausar y reanudar la ejecuci\u00f3n de c\u00f3digo de forma controlada.</li> <li>  Emite el mensaje especificado. V\u00e9ase en conjunto a . Este bloque env\u00eda el contenido del mensaje especificado. Todos los bloques de mensajes <code>al recibir</code> con el mismo mensaje en su contenido recibir\u00e1n el mensaje y actuar\u00e1n ejecutando su contenido.</li> <li>  Ejecuta cuando se emita el mensaje especificado. Este bloque y su par funcional  se suelen utilizar juntos para conseguir un medio de comunicaci\u00f3n dentro del programa. Cualquier mensaje enviado con el comando <code>env\u00eda</code> es detectado y recibido por este bloque. As\u00ed, los bloques colocados bajo este bloque se ejecutar\u00e1n al recibir el mensaje correspondiente. Los mensajes pueden ser cadenas o n\u00fameros. Adem\u00e1s, el bloque  contiene el \u00faltimo mensaje emitido y recibido.</li> <li>  Devuelve el \u00faltimo mensaje enviado en todo el programa, cronol\u00f3gicamente hablando. N\u00f3tese que NO es el \u00faltimo mensaje recibido por una secuencia de bloques concreta del programa, y es independiente de la ejecuci\u00f3n del bloque <code>al recibir</code>. No hay colas de mensajes en el sistema. Si no hay ning\u00fan <code>al recibir</code> en espera cuando se env\u00eda un mensaje, se perder\u00e1 y ser\u00e1 sobrescrito por el siguiente mensaje.</li> </ul> <p>En el ejemplo siguiente vemos de forma sencilla el funcionamiento de estos tres \u00faltimos bloques.</p> <p> <p> Di el \u00faltimo mensaje</p> <p></p> <p>Descargar el programa</p>"},{"location":"programacion/ublocks/#listas","title":"Listas","text":"<p>Los bloques para trabajar con listas est\u00e1n en el men\u00fa 'Datos' y sus bloques los vemos en la imagen siguiente.</p> <p> <p> Bloques para Listas. Datos</p> <p></p> <ul> <li> Devuelve una lista corta que contiene algunos elementos en ingl\u00e9s. Con las flechas podemos a\u00f1adir o eliminar elementos a la lista aunquw a partir del cuarto se repite siempre el mismo. Para crear una lista vac\u00eda () basta con eliminar el \u00fanico elemento existente cuando se crea una nueva.</li> <li> Une (concatena) cadenas, listas o matrices de bytes y devuelve el resultado.</li> <li> Devuelve el car\u00e1cter Unicode del n\u00famero dado.</li> <li> Devuelve el en\u00e9simo elemento de una lista, cadena o matriz de bytes.</li> <li>  Combina los elementos de una lista en una cadena, opcionalmente se puede usar un car\u00e1cter delimitador.</li> <li>  A\u00f1ade un elemento al final de una lista.</li> </ul> <p>En el ejemplo siguiente vemos el uso de estos bloques. Comenzamos por crear una cadena de caracteres de la que vamos a extraer la palabra un mediante la uni\u00f3n de los elementos 9 y 10 de la cadena. Se crea una lista con cuatros animales y finalmente se muestra la palabra 'un' seguida de la posici\u00f3n 3 de la lista creada.</p> <p> <p> Un pajaro</p> <p></p> <p>Descargar el programa</p> <p>En este otro ejemplo vemos como se generan los caracteres de lat\u00edn b\u00e1sico comenzando por el espacio en blanco (32), diferentes s\u00edmbolos, n\u00fameros, letras may\u00fasculas y letras min\u00fasculas.</p> <p> <p> Caracteres Unicode de Lat\u00edn b\u00e1sico</p> <p></p> <p>Descargar el programa</p> <ul> <li> Devuelve el n\u00famero de elementos de una lista, cadena o matriz de bytes.</li> <li> Sustituye el en\u00e9simo elemento de una lista por el valor dado. Tambi\u00e9n puede sustituir todos los elementos por un valor.</li> <li> Elimina el elemento N de una lista. La lista resultante se reduce de tama\u00f1o. Tambi\u00e9n puede eliminar todos los elementos.</li> </ul> <p>A continuaci\u00f3n vemos un ejemplo en el que se demuestra la funcionalidad de estos tres bloques.</p> <p> <p> Sustituir, eliminar y tama\u00f1o</p> <p></p> <p>Descargar el programa</p> <ul> <li> Devuelve la posici\u00f3n de la primera coincidencia de una subcadena dentro de una cadena o un elemento de una lista. Devuelve -1 si no encuentra coincidencias.</li> </ul> <p>En el ejemplo las variables locales <code>cadena</code> y <code>animales</code> se inicializan como de tipo string y list respectivamente. El primer conjunto de resultados opera sobre la cadena, buscando la posici\u00f3n de la primera apariciones de \"es\". La primera coincidencia se encuentra en el car\u00e1cter n\u00famero uno. La segunda b\u00fasqueda se inicia en el car\u00e1cter n\u00famero tres, y localiza el objetivo de la b\u00fasqueda en el car\u00e1cter n\u00famero seis. La b\u00fasqueda de \"perro\" en la lista 'animales' la encuentra en el elemento n\u00famero dos de la lista. La segunda b\u00fasqueda de \"perro\" en la lista 'animales' comienza en el elemento n\u00famero tres y devuelve -1 porque no lo encuentra. No hay ning\u00fan \"raton\" en la lista, por lo que la b\u00fasqueda devuelve -1.</p> <p> <p> Buscar</p> <p></p> <p>Descargar el programa</p> <ul> <li> Copia una cadena desde/hasta el caracter especificado, o una desde/hasta el elemento indicado. Como ya sabemos para mostrar el par\u00e1metro hasta hay que hacer clic en el tri\u00e1ngulo negro.</li> </ul> <p> <p> Copiar</p> <p></p> <p>Descargar el programa</p> <ul> <li> Devuelve una lista separando la cadena especificada por el delimitador opcional. Si no se especifica ning\u00fan delimitador, la cadena se divide por cada car\u00e1cter.</li> </ul> <p>En la imagen vemos una cadena delimitada por comas que separa los caracteres mediante el delimitador coma en una lista de tres elementos.</p> <p> <p></p> <p></p> <p>A continuaci\u00f3n vemos una cadena que incluye un car\u00e1cter retorno de l\u00ednea despu\u00e9s del ABC y DEF que se separa mediante el caracter unicode de nueva l\u00ednea (return) en una lista de tres elementos.</p> <p> <p></p> <p></p> <p>En este otro caso separamos la URL de la descarga de MicroBlocks en partes mediante el delimitador /.</p> <p> <p></p> <p></p> <ul> <li>  Devuelve el valor Unicode del car\u00e1cter en\u00e9simo de la cadena introducida. El n\u00famero de caracteres introducido debe estar comprendido entre uno y la longitud de la cadena. Este bloque es el opuesto de .</li> </ul> <p> <p></p> <p></p> <ul> <li> Crea una nueva lista del n\u00famero de elementos especificado. Hay que controlar la disponibilidad de memoria. Los elementos de la lista creada se pueden inicializar a cualquier valor utilizando la opci\u00f3n de bloque con todos.</li> <li> Crea una matriz del n\u00famero de elementos especificado en funci\u00f3n de la disponibilidad de memoria. Cada elemento es de tama\u00f1o byte y se le pueden asignar valores en el rango de 0-255 (0-FF).</li> <li> Devuelve una cadena que indica el n\u00famero de palabras de 32 bits de memoria din\u00e1mica disponibles para asignar nuevos objetos (cadenas, listas o matrices de bytes). Al pulsar el bot\u00f3n de parada se libera toda la memoria. Justo despu\u00e9s de pulsar el bot\u00f3n de parada, este bloque informa del total de memoria din\u00e1mica disponible en un dispositivo determinado. Los dispositivos tienen diferentes cantidades de memoria din\u00e1mica, basadas en la cantidad de RAM proporcionada por el hardware. Por ejemplo, la micro:bit v2 tiene mucha m\u00e1s RAM que la micro:bit original.</li> </ul> <p>Un ejemplo de uso.</p> <p> <p> Copiar</p> <p></p> <p>Descargar el programa</p> <ul> <li>  Convierte un byte, una lista o una cadena especificada en una matriz de bytes. Cada elemento es el valor unicode de las letras de la cadena en el rango de 0-255 (0-FF).</li> </ul>"},{"location":"programacion/ublocks/#operadores_1","title":"Operadores","text":"<p>Los operadores a\u00fan no vistos son:</p> <p> <p></p> <p>Operadores aritm\u00e9ticos, de comparaci\u00f3n y booleanos</p> <p></p> <p>Los operadores aritm\u00e9ticos y de comparaci\u00f3n no requieren de mayor explicaci\u00f3n por lo que nos vamos a centrar en los booleanos.</p> <ul> <li> Operador booleano <code>True</code> o <code>False</code>. Devuelve verdadero o falso en funci\u00f3n de la posici\u00f3n del selector, o de la evaluaci\u00f3n binaria de la expresi\u00f3n utilizada como entrada. Este bloque se usa dentro de muchos otros bloques, donde se utiliza para controlar el flujo de las ejecuciones y eventos.</li> </ul> <p>El bloque <code>if</code> es un buen ejemplo para demostrar el uso del bloque verdadero/falso.</p> <p> <p></p> <p>Uso sencillo del operador <code>True/False</code></p> <p></p> <p>Descargar el programa</p> <p>El c\u00f3digo del ejemplo se ejecuta de dos maneras diferentes siempre dentro de un bucle infinito en el que se genera un n\u00famero aleatorio que puede valer 1, 2 o 3:</p> <ul> <li>La primera es la condici\u00f3n de la rama <code>IF</code> que ser\u00e1 verdadera si el n\u00famero generado es 1.</li> <li>La segunda es la rama <code>ELSE IF</code> que se eval\u00faa si la condici\u00f3n del <code>IF</code> no es verdadera y se pone a verdadero, ejecutando su c\u00f3digo.</li> <li> <p>La tercera es la condici\u00f3n <code>ELSE</code> a la que nunca se llega porque si el n\u00famero vale 1 se ejecuta el <code>IF</code> y si no se ejecuta el <code>ELSE IF</code> que siempre es cierto. Es decir, aunque se genere <code>variable = 3</code> la condici\u00f3n <code>ELSE</code> no se ejecuta.</p> </li> <li> <p> Invierte el valor l\u00f3gico asociado a la expresi\u00f3n sobre la que opera. Tal y como se muestra, <code>NOT</code> devolver\u00e1 <code>FALSE</code> si el deslizador se establece en <code>TRUE</code>, y <code>TRUE</code> si se establece en <code>FALSE</code>.</p> </li> </ul> <p>En el ejemplo siguiente, una variable llamada <code>cadena</code> se inicializa como \"MicroBlocks es genial\", y una variable llamada <code>expresion</code> se inicializa en <code>TRUE</code> de una forma peculiar, diciendo que algo es igual a si mismo. Cuando se aplica <code>NOT</code> al resultado de la expresi\u00f3n de igualdad, se cambia a <code>FALSE</code>.</p> <p> <p></p> <p>Uso sencillo del operador <code>NOT</code></p> <p></p> <p>Descargar el programa</p> <ul> <li>  Devuelve verdadero s\u00f3lo si todas sus entradas son verdadero y devuelve falso en caso contrario. Como ambas condiciones tienen que ser verdaderas para obtener un resultado verdadero, si se detecta un falso en la primera condici\u00f3n, no es necesario evaluar la segunda; se devuelve falso inmediatamente.</li> </ul> <p>En el ejemplo tenemos dos variables <code>salir</code> y <code>llueve</code> que se inicializan a verdadero. Se muestran una serie de mensajes y al final se eval\u00faa si \"necesito un paraguas\" comprobando si es voy a salir y si llueve. Ambas condiciones tienen que ser verdaderas para que necesitemos un paraguas. Podemos cambiar el estado de las variables y comprobar lo que ocurre.</p> <p> <p></p> <p>Uso sencillo del operador <code>AND</code></p> <p></p> <p>Descargar el programa</p> <ul> <li>  Devuelve verdadero si uno o ambos operandos son verdaderos y devuelve falso en caso contrario. Similar a <code>AND</code> pero opuesto a \u00e9l, aqu\u00ed s\u00f3lo una de las dos condiciones tiene que ser verdadera para un resultado verdadero. Por lo tanto, si la primera condici\u00f3n es verdadera, no es necesario comprobar la segunda.</li> </ul> <p>En el ejemplo estamos generando aleatoriamente dos n\u00fameros en el rango de 1 a 5. A continuaci\u00f3n, comprobamos si alguno de los dos n\u00fameros es igual al n\u00famero que estamos buscando (3). El bloque <code>OR</code> se utiliza para verificar el resultado de la comparaci\u00f3n.</p> <p> <p></p> <p>Uso sencillo del operador <code>OR</code></p> <p></p> <p>Descargar el programa</p> <p>Cada vez que pulsemos en 'Iniciar' se genera un nuevo resultado.</p>"},{"location":"programacion/ublocks/#bloques-de-control","title":"Bloques de control","text":"<ul> <li>  Los bloques en este bloque de sombrero se ejecutan cuando se pulsan los botones A, B, o A+B. Se dispara una vez por cada pulsaci\u00f3n de bot\u00f3n. Si se mantiene pulsado el bot\u00f3n, no se vuelve a disparar hasta que se suelta el bot\u00f3n y se vuelve a pulsar. Por ejemplo, cuando se pulsa el bot\u00f3n A aparece en pantalla una A.</li> </ul> <p> <p></p> <p>cuando se pulsa el bot\u00f3n</p> <p></p> <ul> <li>  El bloque <code>IF</code> comprueba la condici\u00f3n booleana y ejecuta los bloques de una sola vez si la condici\u00f3n booleana se eval\u00faa como verdadera. El tri\u00e1ngulo negro permite la expansi\u00f3n del bloque <code>IF</code> con m\u00faltiples condiciones <code>ELSE IF</code> a\u00f1adidas. En caso de que las ramas <code>IF</code> o <code>ELSE IF</code> anteriores no sean verdaderas, entonces se eval\u00faan y ejecutan sucesivamente cada una de las siguientes <code>ELSE IF</code>.</li> </ul> <p>En el ejemplo, a la variable <code>aleatorio</code> se le asigna un n\u00famero al azar entre el 1 y el 10. La operaci\u00f3n MOD se utiliza para sondear el estado par/impar del n\u00famero. Si el resto de la operaci\u00f3n num dividido por 2 da como resultado 0, el n\u00famero es par, en caso contrario es impar.</p> <p> <p></p> <p>Sentencia <code>IF</code></p> <p></p> <p>Descargar el programa</p> <p>Cada vez que pulsemos en 'Iniciar' se genera un nuevo resultado.</p> <ul> <li>  El bloque 'cuando' comprueba repetidamente una condici\u00f3n booleana. Cuando la condici\u00f3n se convierte en verdadera, se ejecutan los bloques bajo el sombrero. Si la condici\u00f3n sigue siendo verdadera al final de la ejecuci\u00f3n, entonces los bloques se ejecutar\u00e1n de nuevo, y ese proceso se repite hasta que la condici\u00f3n se convierte en falsa.</li> </ul> <p>Nota: El sombrero 'cuando' incluye una espera de 10 milisegundos entre ciclos. Esto es \u00fatil para eliminar ruido en las entradas, por ejemplo rebotes en los botones, pero limita el rendimiento a un m\u00e1ximo de 100 iteraciones/segundo.</p> <p>Vamos a ver el mismo ejemplo que en el bloque <code>IF</code> pero utilizando este bloque. Los tres bloques del tipo <code>WHEN</code> empiezan a funcionar simult\u00e1neamente cuando se pulsa el icono <code>START</code>. El bloque 'por siempre' debajo de 'al empezar' genera un n\u00famero aleatorio cada segundo. Y de forma simultanea los otros dos bloques evaluan continuamente sus condiciones mostrando el resultado que corresponde a cada uno.</p> <p> <p></p> <p>Bloque 'cuando'</p> <p></p> <p>Descargar el programa</p> <ul> <li>  Este bloque de control pausa la ejecuci\u00f3n del programa y espera hasta que la condici\u00f3n booleana especificada se convierta en verdadera. Se puede utilizar para sincronizar bloques de c\u00f3digo que se ejecutan en paralelo, bas\u00e1ndose en los eventos monitorizados.</li> </ul> <p>En este ejemplo, el nivel de luz ambiental se controla mediante el sensor de luz integrado. El sensor de luz tiene un rango de 0-255, siendo 0 oscuridad total y 255 claridad m\u00e1xima. Cuando se inicia el programa, ambos bloques 'cuando se pulse el boton' comienzan a ejecutarse y a comprobar el estado del bot\u00f3n.</p> <p>Al pulsar el bot\u00f3n A, se inicia la monitorizaci\u00f3n de la luz y el programa espera hasta que los sensores de la micro:bit informen de un nivel de luz &lt; 75. Cuando esa condici\u00f3n se cumple, se emite una alerta para avisar de que hay que encender las luces.</p> <p>El bot\u00f3n B est\u00e1 programado para detener el proceso de monitorizaci\u00f3n. Al pulsarlo, detiene la ejecuci\u00f3n de esa rama del programa.</p> <p> <p></p> <p>Bloque 'cuando se pulsa el boton'</p> <p></p> <p>Descargar el programa</p> <p>El bloque 'nivel de luz' se encuentra en la libreria 'Sensores b\u00e1sicos' y el bloque 'deten las otras tareas' se explica un poco mas abajo.</p> <ul> <li> <p>  El bloque <code>RETURN</code> se utiliza para devolver el valor especificado en su \u00e1rea de entrada. El valor retornado puede ser cualquier tipo de dato. Aunque es posible utilizar el bloque <code>RETURN</code> en cualquier parte de un programa para mostrar un valor, de forma similar al bloque <code>di</code>, su uso correcto y m\u00e1s com\u00fan es en una funci\u00f3n (o bloque personalizado) para devolver un valor como resultado del proceso realizado. Hay que tener en cuenta que los bloques colocados despu\u00e9s del bloque <code>RETURN</code> no se ejecutar\u00e1n.</p> </li> <li> <p>  Este bloque tipo C es un bucle que se utiliza para ejecutar los bloques colocados dentro de \u00e9l, hasta que la condici\u00f3n booleana especificada se convierte en verdadera. En ese momento, se ejecutar\u00e1 el siguiente bloque despu\u00e9s del bloque en forma de C.</p> </li> </ul> <p>En el ejemplo vemos como se monitoriza si se ha pulsado el bot\u00f3n A enviando un mensaje</p> <p> <p></p> <p>Bloque 'repetir hasta que'</p> <p></p> <ul> <li>  Este bloque, y su par relacionado , se utilizan para controlar el hilo de ejecuci\u00f3n del programa. Este bloque detiene la ejecuci\u00f3n de todos los bloques de los que forma parte, o que est\u00e1n bajo el mismo bloque sombrero. Una vez ejecutado este bloque en un grupo de bloques, no se ejecutar\u00e1 nada m\u00e1s en ese grupo.</li> </ul> <p>En el ejemplo, el grupo de bloques de la derecha est\u00e1 en un bucle continuo que cuenta hacia atr\u00e1s y decrementa su variable local <code>numero</code>. El grupo de bloques de la izquierda tambi\u00e9n est\u00e1 en un bucle continuo, contando hacia abajo y decrementando su variable local <code>numero</code>. Cuando la cuenta atr\u00e1s alcanza el valor 7 se cumple la condici\u00f3n del <code>else if</code> y se detiene la cuenta del bloque derecho, mientras que la secuencia del bloque izquierdo continua su ejecuci\u00f3n hasta que se cumpla la condici\u00f3n del <code>if</code> que ser\u00e1 cuando se alcance el n\u00famero 2, momento en que se detiene esta tarea.</p> <p>Podemos comprobar como el \u00faltimo bloque <code>di</code> de la secuencia de la izquierda NUNCA se ejecuta porque una vez que el bloque 'deten esta tarea' se ejecuta, todas las actividades de este bloque izquierdo terminan.</p> <p> <p></p> <p>Bloques 'deten esta tarea' y 'deten las otras tareas'</p> <p></p> <p>Podemos observar como desaparece el marco verde de cada bloque cuando su tarea finaliza indicando precisamente eso, que el bloque no se est\u00e1 ejecutando.</p> <p>Descargar el programa</p>"},{"location":"programacion/ublocks/#bloques-de-entrada-para-los-botones","title":"Bloques de 'Entrada' para los botones","text":"<ul> <li> y   Devuelve el estado del bot\u00f3n A o B. <code>true</code> = pulsado y <code>false</code> = no pulsado.</li> <li> equivalente al bloque  cuando lo configuramos con el pin 26, que es el correspondiente al logotipo .  Devuelve el estado del logo. <code>true</code> si lo tocamos (equivale a pulsador A o B pulsado) y <code>false</code> cuando no lo tocamos. Estos bloques est\u00e1n disponibles dentro la 'Libreria' 'Sensores[ ]' y aparece como 'Touch (microbit)'. El bloque para configurar el n\u00famero de pin tiene su sentido en la existencia de sensores t\u00e1ctiles en el borde de placa, como veremos mas adelante.</li> </ul> <p>En el ejemplo vemos como chequear el estado de los botones mediante la sentencia <code>IF</code>.</p> <p> <p></p> <p>Bloques para chequear el estado de los botones</p> <p></p> <p>Descargar el programa</p>"},{"location":"programacion/ublocks/#graficado-de-datos","title":"Graficado de datos","text":"<p>En MicroBlocks es relativamente sencillo trabajar los datos de forma gr\u00e1fica y para ello disponemos de un bloque para indicar el dato que queremos ver de manera gr\u00e1fica y un icono en el men\u00fa que abre la ventana flotante 'Gr\u00e1fico de datos'.</p> <p> <p> Bloque e icono para mostrar 'Gr\u00e1fico de datos'</p> <p></p> <p></p> <p>Bloque Panel gr\u00e1fico Opciones del panel gr\u00e1fico</p> <p></p> <p>Bloque</p> <p>Est\u00e1 disponible en el men\u00fa 'Salida'.</p> <ul> <li>. Graficar\u00e1 el valor introducido, en el panel de visualizaci\u00f3n de gr\u00e1ficos de datos. Se puede graficar cualquier tipo de dato: n\u00fameros, valores de pines digitales y anal\u00f3gicos, salidas de sensores, etc. Si tenemos que representar gr\u00e1ficamente m\u00e1s de un dato, hacemos clic en el tri\u00e1ngulo negro para mostrar campos de datos adicionales. Se pueden graficar hasta seis valores simult\u00e1neos con diferentes colores.</li> </ul> <p>La representaci\u00f3n gr\u00e1fica s\u00f3lo es posible en el IDE. Por lo tanto, s\u00f3lo es posible realizar gr\u00e1ficos mientras el microdispositivo est\u00e1 conectado al ordenador. Si intentamos realizar un gr\u00e1fico mientras no est\u00e1 conectado al ordenador, aparecer\u00e1 el mensaje \"Placa no conectada\".</p> <p>Volver </p> <p>Panel gr\u00e1fico</p> <p>Se activa desde el icono y tiene el siguiente aspecto:</p> <p> <p> Panel 'Gr\u00e1fico de datos'</p> <p></p> <p>El panel Gr\u00e1ficos de datos muestra los valores utilizados con el bloque de gr\u00e1ficos. El eje y del panel puede escalarse utilizando los controles de zoom del propio panel, y el eje x se desplazar\u00e1 lateralmente a medida que se grafiquen m\u00e1s datos.</p> <p>La ventana de visualizaci\u00f3n del gr\u00e1fico se puede redimensionar con el control situado en la esquina inferior derecha y puede colocarse en cualquier lugar de la ventana del IDE.</p> <p>Tras el registro de cualquier dato, la ventana de visualizaci\u00f3n de gr\u00e1ficos puede cerrarse y abrirse, si es necesario, sin que se pierda ning\u00fan dato ni la imagen visualizada, aunque si pierde la reconfiguraci\u00f3n realizada en la misma, como la posici\u00f3n del cero, el tama\u00f1o, etc. Adem\u00e1s, es posible desconectar y volver a conectar el dispositivo en uso, sin perder los datos del gr\u00e1fico.</p> <p>En la animaci\u00f3n vemos como funciona lo indicado. El escalado con la lupa del menos amplia el rango de valores del eje y, con la lupa del mas lo disminuye y la lupa del igual restaura la situaci\u00f3n inicial tras el redimensionado de la ventana.</p> <p> <p> Funcionamiento de 'Gr\u00e1fico de datos'</p> <p></p> <p>Volver </p> <p>Opciones del panel gr\u00e1fico</p> <p>Se accede haciendo clic con el bot\u00f3n derecho del rat\u00f3n en cualquier zona del panel. Si tenemos el cursor del rat\u00f3n sobre la zona de las lupas no funcionar\u00e1.</p> <p> <p> Opciones de 'Gr\u00e1fico de datos'</p> <p></p> <p>El men\u00fa de opciones del gr\u00e1fico permite controlar la visualizaci\u00f3n de los ejes, as\u00ed como la importaci\u00f3n/exportaci\u00f3n de datos y el ajuste de la frecuencia de muestreo de datos.</p> <ul> <li>limpiar gr\u00e1fico. Borra cualquier gr\u00e1fico de la ventana de visualizaci\u00f3n de datos.</li> <li>cero abajo. Sit\u00faa el punto de origen del eje y en la parte inferior del \u00e1rea de visualizaci\u00f3n del gr\u00e1fico.</li> <li>exportar datos a archivo CSV. Permite guardar los datos del gr\u00e1fico en formato CSV. Se exportan los \u00faltimos diez mil (10000) valores.</li> <li>importar datos desde archivo CSV. Permite cargar datos CSV desde el ordenador en el que se est\u00e1 ejecutando MicroBlocks. Los datos importados se grafican y se muestran en el 'Gr\u00e1fico de datos'. Es posible importar 10000 valores. Si tenemos mas de un dato para graficar, estos no se exportan individualmente sino todos juntos eparados por comas.</li> <li>copiar datos del gr\u00e1fico al portapapeles. Se trata de una funci\u00f3n avanzada que permite copiar en el portapapeles los \u00faltimos 10000 valores utilizados con el bloque gr\u00e1fico.</li> <li>ajustar latencia del puerto serie. Se trata de otro funci\u00f3n avanzada que permite establecer la frecuencia de muestreo de datos o latencia entre 1 y 20ms. Los n\u00fameros m\u00e1s bajos dan como resultado frecuencias de muestreo m\u00e1s altas.</li> </ul> <p>Los archivos CSV (del ingl\u00e9s comma-separated values) son un tipo de documento no estandarizado que tiene la idea b\u00e1sica de separar los campos de datos por una coma, de ah\u00ed su nombre Valores separados por comas</p> <p>Vamos a ver un ejemplo de uso en el que se muestran de forma gr\u00e1fica una serie de n\u00fameros aleatorio entre 1 y 100. El programa y el gr\u00e1fico son:</p> <p> <p> Ejemplo de 'Gr\u00e1fico de datos'</p> <p></p> <p>Descargar el programa</p>"},{"location":"programacion/ublocks/#pines","title":"Pines","text":"<p>En el men\u00fa 'Pines' disponemos de seis bloques que vamos a describir a continuaci\u00f3n.</p> <ul> <li>. Devuelve el valor (verdadero o falso) del pin digital indicado. Podemos acceder a la configuraci\u00f3n pullup 'true/false' haciendo clic en el tri\u00e1ngulo negro del extremo derecho, que se expande a  sin pullup o bien  con pullup. La configuraci\u00f3n pullup a <code>true</code> fuerza la se\u00f1al alta en caso de fluctuaciones de tensi\u00f3n en el pin.</li> </ul> <p>Vamos a ver un ejemplo de uso del bloque. El pin digital P0 lo leemos continuamente y los resultados se muestran y grafican mientras se va mostrando si el pin est\u00e1 en estado cero (false) o uno (true). El pullup est\u00e1 activado por lo que el estado normal de la l\u00ednea es true o alto. El programa es:</p> <p> <p> Ejemplo de uso del bloque 'lectura digital'</p> <p></p> <p>Descargar el programa</p> <p>En la animaci\u00f3n vemos el programa en funcionamiento y podemos observar los cambios de estado tanto en modo texto como en modo gr\u00e1fico.</p> <p> <p> Ejemplo de uso del bloque 'lectura digital'</p> <p></p> <ul> <li>. Devuelve el valor (0 - 1023) del pin anal\u00f3gico indicado. Devuelve el valor del pin anal\u00f3gico especificado como un n\u00famero en el rango 0-1023. Se puede acceder a la configuraci\u00f3n pullup true/false haciendo clic en el tri\u00e1ngulo negro del extremo derecho. El ajuste pullup fuerza la se\u00f1al a alto en caso de fluctuaciones de voltaje en el pin.</li> </ul> <p>Reutilizamos el ejemplo anterior cambiando el bloque por el de lectura anal\u00f3gica. El pin anal\u00f3gico 0 se lee continuamente y los resultados se muestran y se representan gr\u00e1ficamente. El pin 0 no est\u00e1 conectado a nada durante la prueba actuando como antena de la entrada anal\u00f3gica. El Pullup NO est\u00e1 habilitado, lo que significa que el estado de la se\u00f1al de la l\u00ednea fluct\u00faa constantemente.</p> <p> <p> Ejemplo de uso del bloque 'lectura anal\u00f3gica'</p> <p></p> <p>Descargar el programa</p> <p>En la animaci\u00f3n vemos el programa en funcionamiento y podemos observar los cambios de estado tanto en modo texto como en modo gr\u00e1fico.</p> <p> <p> Ejemplo de uso del bloque 'lectura anal\u00f3gica'</p> <p></p> <ul> <li>. Establece el valor (verdadero o falso) del pin digital indicado. Establece el estado del pin digital especificado como verdadero o falso. En un dispositivo de 3.3V, un valor alto pondr\u00e1 3.3V, y un valor bajo pondr\u00e1 0V en el pin.</li> </ul> <p>Se programan dos bucles, uno que se repite cinco veces para cambiar P0 entre 0 y 1 y el otro que se repite indefinidamente leyendo el estado del pin 1 y se representa graficamente. La lectura se hace en P1 porque se hacemos la lectura en P0 mientras est\u00e1 cambiando, podr\u00eda afectar a su estado. El circuito a montar es simplemente conectar con un cable P0 y P1.</p> <p> <p> Circuito para probar 'pon pin digital'</p> <p></p> <p>El programa es el siguiente:</p> <p> <p> Ejemplo de uso del bloque 'pon pin digital'</p> <p></p> <p>Descargar el programa</p> <p>En la animaci\u00f3n vemos el programa en funcionamiento y podemos observar los cambios de estado tanto en modo texto como en modo gr\u00e1fico.</p> <p> <p> Ejemplo de uso del bloque 'lectura anal\u00f3gica'</p> <p></p> <ul> <li>. Establece el valor (0 - 1023) del pin anal\u00f3gico indicado. Genera PWM en el pin indicado con valores de 0 a 1023. El PWM funciona encendiendo y apagando el pin r\u00e1pidamente. La potencia se controla variando el ciclo de trabajo o duty cycle, que es el porcentaje de tiempo durante cada ciclo que el pin est\u00e1 en alto. Un valor de 0 significa que el pin est\u00e1 apagado, mientras que un valor de 1023 significa que est\u00e1 a plena potencia (es decir, el pin est\u00e1 encendido el 100% del tiempo). Un valor de 512 da como resultado un ciclo de trabajo del 50%; que indica que el pin est\u00e1 encendido la mitad del tiempo y apagado la otra mitad.</li> </ul> <p>Cuando veamos alg\u00fan dispositivo anal\u00f3gico ser\u00e1 el momento de ver alg\u00fan ejemplo de uso de este bloque. Por ahora podemos ver este video de la documentaci\u00f3n oficial en el que se aprecia como se controla con PWM la velocidad de giro de un ventilador a partir de las variaciones que hagamos en un potenci\u00f3metro.</p> <ul> <li>. Devuelve el n\u00famero total de pines anal\u00f3gicos soportados por el dispositivo.</li> <li>. Devuelve el n\u00famero total de pines digitales soportados por el dispositivo.</li> </ul> <p>El programa siguiente muestra el tipo de dispositivo conectado y el tipo y n\u00famero de pines de que dispone.</p> <p> <p> Ejemplo de uso de los bloques 'pines anal\u00f3gicos y pines digitales'</p> <p></p>"},{"location":"programacion/ublocks/#libreria-neopixeles","title":"Libreria NeoPixeles","text":"<p>Los NeoPixels son peque\u00f1os m\u00f3dulos LED que combinan LEDs rojos, verdes y azules montados en un solo encapsulado con un chip controlador. Los NeoPixels pueden ser controlados individualmente por una sola l\u00ednea de datos desde un dispositivo microcontrolado para crear diferentes colores y patrones. Un solo pin del microcontrolador puede controlar docenas (o incluso cientos) de NeoPixels. Los NeoPixels se encuentran en muchas configuraciones diferentes, como son anillos, barras, matrices y tiras flexibles.</p> <ul> <li>. Configura el pin de conexi\u00f3n de los Neopixels. Este bloque configura un dispositivo NeoPixel especificando cu\u00e1ntos LEDs hay en el dispositivo y qu\u00e9 pin se utilizar\u00e1 para controlarlos. El bloque debe ejecutarse antes de hacer nada con cualquiera de los otros bloques NeoPixel.</li> </ul> <p>El bloque se expande a  para el trabajo con Neopixels blancos.</p> <ul> <li>. Establece los colores de los diez primeros NeoPixels. Es especialmente \u00fatil cuando se utiliza con placas o tiras con este n\u00famero de LEDs. La secuencia de numeraci\u00f3n (1-10) es de izquierda a derecha y de arriba a abajo. La configuraci\u00f3n del color se hace desde la paleta que se muestra sin poder establecer mayor precisi\u00f3n. La paleta muestra los valores RGB en decimal.</li> </ul> <p> <p></p> <p></p> <ul> <li>. Apaga todos los LEDs. Los pone a color negro.</li> <li>. Pone todos los LEDs con el color indicado.</li> <li>. Pone el n\u00famero de LED especificado del color indicado. Los LEDs se numeran secuencialmente comenzando por uno.</li> <li>. Desplaza la secuencia de colores NeoPixel el n\u00famero de NeoPixels indicado. Los colores al final de la secuencia se desplazan y se insertan al principio de la secuencia. Si los NeoPixels forman un c\u00edrculo, los colores giran alrededor del c\u00edrculo. El argumento determina el n\u00famero de posiciones que se desplazan los colores. Un valor negativo har\u00e1 que los NeoPixels roten en la direcci\u00f3n opuesta.</li> <li>. Devuelve un color definido especificando los valores de rojo (R), verde (G) y azul (B) entre 0 y255. El bloque puede utilizarse en cualquier bloque que reciba una entrada de color. Los valores inferiores a 40 pueden provocar que el LED no se encienda nada.</li> <li>. Devuelve un color aleatorio. El bloque puede utilizarse en cualquier bloque que reciba una entrada de color.</li> </ul>"},{"location":"programacion/ublocks/#sonidos","title":"Sonidos","text":"<p>Tonos Politonos</p> <p>En MicroBlocks tenemos tres opciones de reproducci\u00f3n de sonidos o m\u00fasica, un conjunto de librer\u00edas englobadas bajo el seud\u00f3nimo \"Sonido\", una librer\u00eda de \"Politonos\" y otra librer\u00eda de \"Tonos\". En \"Sonido\" nos encontraremos bloques \"MultiTone\", opciones para reproducir mp3 o WAV, radio AM, etc. No veremos estas librer\u00edas por el momento y nos centraremos en \"Tonos\" y \"Politonos\".</p> <p>Volver </p> <p>Tonos</p> <p>A\u00f1adimos la libreria \"Tonos\" a nuestro entorno y nos encontramos con los siguientes bloques:</p> <ul> <li>. Reproduce la nota y la octava y por el tiempo indicados.</li> <li>. Reproduce la nota indicada por el n\u00famero de tecla en el teclado del piano (0-127) donde el Do central es 60. Este bloque es \u00fatil cuando se realizan transformaciones matem\u00e1ticas de la m\u00fasica. MIDI es la abreviatura de \"Musical Instrument Digital Interface\", que se traduce como \"Interfaz digital de instrumentos musicales\", y es un est\u00e1ndar de la industria para controlar sintetizadores, cajas de ritmos y otros dispositivos musicales electr\u00f3nicos.</li> <li>. Reproduce la nota especificada en Hertz (Hz) durante el tiempo indicado.</li> <li>. Reproduce el tono indicado en Hz.</li> <li>. Detiene la reproducci\u00f3n del tono actual.</li> <li>. Especifica el pin al que est\u00e1 conectado un zumbador piezoel\u00e9ctrico o unos auriculares. En placas con altavoces integrados, se utilizar\u00e1 el altavoz integrado si se omite este bloque.</li> </ul> <p>Volver </p> <p>Politonos</p> <p>El formato RTTTL (del ingl\u00e9s, Ring Tone Text Transfer Language) fue desarrollado por Nokia para codificar tonos de llamada a tel\u00e9fonos m\u00f3viles. El formato RTTTL es una cadena dividida en tres secciones: encabezado (nombre o t\u00edtulo), valor predeterminado y datos. Por ejemplo, la siguiente cadena de texto se corresponde con la Intro de Donkey Kong:</p> <p>d=4,o=5,b=140:8a#,8p,8d6,16p,16f.6,16g.6,16f.6,8a#,8p,8d6,16p,16f.6,16g.6,16f.6,8a#,8p,8d6,16p,16f.6,16g.6,16f.6,8a#,8p,8d6,16p,16f.6,16g.6,16f.6</p> <p>A\u00f1adimos la libreria \"Politonos\" a nuestro entorno y nos encontramos con los siguientes bloques:</p> <ul> <li>. Reproduzca la cadena de tono de llamada indicada.</li> <li>. Devuelve el nombre del tono de llamada que se est\u00e1 reproduciendo actualmente.</li> </ul> <p>Para reproducir una melodia simplemente la copiamos en el bloque <code>toca el politono</code>.</p> <p>Existen p\u00e1ginas de donde se pueden descargar tonos, o incluso podemos hacerlo nosotros mismos. A continuaci\u00f3n ponemos algunos enlaces:</p> <ul> <li>RTTTL Ringtone Downloads de Picaxe.</li> <li>Colecciones de ArcadeTones clasificados por temas.</li> <li>Archivo NokringTunes.txt que contiene m\u00e1s de once mil melod\u00edas en formato Nokring. </li> </ul> <p>Una vez descargado lo abrimos y buscamos la melodia para copiar y pegar en el bloque.</p>"},{"location":"programacion/ublocks/#comunicaciones","title":"Comunicaciones","text":"<ul> <li>. Abre el puerto serie a la velocidad en baudios especificada. Esto es necesario antes de empezar a utilizar la comunicaci\u00f3n por puerto serie. El soporte de puerto serie NO est\u00e1 disponible para dispositivos micro:bit v1 debido a la falta de soporte de hardware.</li> <li>. Cierra el puerto y finaliza las comunicaciones serie.</li> <li>. Devuelve una matriz de bytes de datos le\u00eddos desde el puerto serie. En los casos en que estos puedan representar valores de caracteres, es necesario convertirlos utilizando la cadena del bloque unicode en letras reales.</li> </ul> <p> <p></p> <p></p> <p>Las matrices de bytes contienen bytes con valores de 0 a 255.</p> <ul> <li>. Escribe un byte, una cadena o una matriz de bytes en el puerto serie. Los datos a escribir deben ser 128 bytes o menos. En caso de que querer escribir una matriz de bytes en el puerto serie, podemos crearla f\u00e1cilmente con el bloque  del men\u00fa Datos. A continuaci\u00f3n se muestra una imagen de la salida de ese bloque:</li> </ul> <p> <p></p> <p></p> <ul> <li>. Escribe una matriz de bytes en el puerto serie comenzando en el bytes dado y devuelve el n\u00famero de bytes escritos. Utilizando este bloque, un bucle de MicroBlocks puede escribir eficientemente una matriz de bytes larga en el puerto serie.</li> </ul>"},{"location":"programacion/ublocks/#magnetometro-y-acelerometro","title":"Magnet\u00f3metro y aceler\u00f3metro","text":"<p>En MicroBlocks solamente disponemos de unos cuanto bloques relacionados con el tema y los encontramos dentro de la Librer\u00eda \"Sensores b\u00e1sicos\". Estos son:</p> <ul> <li> . Estos tres bloques informan de los valores de inclinaci\u00f3n en los tres ejes. El rango normal de valores es de -100 a +100, pero los valores pueden alcanzar valores entre -200 y 200 cuando se sacude. (100 equivale a 1G de aceleraci\u00f3n).</li> </ul> <p> <p></p> <p></p> <p>Podemos hacer un sencillo nivel con alguna referencia al eje Z. El nivel funciona igual que en el caso de MakeCode pero si ponemos la micro:bit vertical veremos un cero como valor de Yaw y como se alterna una V con una X en la pantalla.</p> <p> <p></p> <p></p> <p>Descargar el programa</p> <ul> <li>. Devuelve la aceleraci\u00f3n total (o \"fuerza G\") experimentada por la micro:bit independientemente de la direcci\u00f3n. Siempre es positiva, con un rango de 0 a 346. En el ejemplo vemos el resultado de mover la micro:bit tanto en forma de texto como en forma de gr\u00e1fico.</li> </ul> <p> <p></p> <p></p> <p> <p></p> <p></p> <p>Descargar el programa</p> <ul> <li> <p>. Por defecto, el rango completo del aceler\u00f3metro es \u00b1 200, siendo 100 = 1G, que es la aceleraci\u00f3n de la gravedad en la Tierra. Esta es la aceleraci\u00f3n que experimenta la micro:bit cuando permanece inm\u00f3vil sobre una mesa. El rango por defecto es suficiente para medir la inclinaci\u00f3n o detectar sacudidas suaves. Pero tambi\u00e9n puede ser interesante medir aceleraciones mayores, como la r\u00e1pida deceleraci\u00f3n... que se produce cuando chocan objetos. Este bloque avanzado permite cambiar el rango de aceleraci\u00f3n m\u00e1xima para medir esas aceleraciones mayores. Establecer su valor, por ejemplo en 4G hace que se divida por 4 el resultado final. Lo podemos probar facilmente introduciendo el bloque en el ejemplo anterior.</p> </li> <li> <p>. Informa de la intensidad del campo magn\u00e9tico detectado por el aceler\u00f3metro. El rango es aproximadamente 0-100000 y el sensor es lo suficientemente sensible como para detectar el campo magn\u00e9tico de la Tierra o el campo magn\u00e9tico de la corriente el\u00e9ctrica que fluye en un cable, si el cable est\u00e1 cerca del chip. A continuaci\u00f3n vemos un ejemplo.</p> </li> </ul> <p> <p></p> <p></p> <p>Descargar el programa</p>"},{"location":"programacion/ublocks/#sensores-basicos","title":"Sensores b\u00e1sicos","text":"<p>El bloque est\u00e1 en una librer\u00eda que acompa\u00f1a al programa que tiene por nombre \"Sensores b\u00e1sicos\" y que tenedremos que a\u00f1adir a las librerias del proyecto para tenerlos disponibles. La mayor\u00eda de ellos ya se han explicado en otros apartados y ahora vamos a ver este en concreto.</p> <ul> <li>. El nivel de luz tiene un rango de 0 a 1023. Los sensores de luz var\u00edan en sensibilidad, incluso entre placas micro:bits de la misma versi\u00f3n, por lo que tendremos que experimentar para descubrir el rango de trabajo del sensor de luz de nuestra placa. Este bloque trabaja con las lecturas de los LEDs de la pantalla.</li> <li>. La temperatura se indica en grados Celsius. El rango del sensor de temperatura suele ser como m\u00ednimo de 0 a 50 \u00b0C. Estos sensores de temperatura integrados no est\u00e1n calibrados y suelen variar de una placa a otra. Podemos comparar la medida obtenida con nuestra placa con la de un term\u00f3metro externo y fiable para poder obtener la temperatura real. Una vez calibrado no ser\u00e1 peor que muchos sensores de temperatura integrados, que tienen una precisi\u00f3n de hasta uno o dos grados cent\u00edgrados.</li> </ul>"},{"location":"programacion/ublocks/#libreria-de-graficos-y-pantallas","title":"Libreria de Gr\u00e1ficos y pantallas","text":"<p>Si accedemos a agregar libreria nos aparece una ventana donde se ofrecen todas las librerias disponibles, y entre ellas el grupo de \"Gr\u00e1ficos y pantallas\" que vemos:</p> <p> <p> Grupo de librerias de Gr\u00e1ficos y Pantallas</p> <p></p> <p>Accediendo al grupo indicado vemos las librerias disponibles y entre las mismas est\u00e1 la que buscamos para la LCD:</p> <p> <p> Libreria LCD Display</p> <p></p> <p>Una vez a\u00f1adida la librer\u00eda se muestran los bloques que tenemos disponibles para trabajar con la LCD:</p> <p> <p> Bloques LCD Display</p> <p></p> <p>En MicroBlocks la l\u00ednea superior es la 1 y la inferior la 2 y las columnas se numeran desde la 1 hasta la 16. Si ponemos como columna inicial la 0 no veremos nada en la pantalla. Curiosamente cuando damos a una fila el valor 0, esta pasa a sustituir a la l\u00ednea 2.</p> <p>El ejemplo siguiente nos pone todo esto en claro.</p> <p> <p> Ejemplo hola mundo con LCD</p> <p></p> <p>Descargar el programa</p>"},{"location":"programas/lista/","title":"Listado de programas","text":"<p>En las tablas siguientes se establecen todos los enlaces de manera individual y al final de cada una aparece un archivo zip con todos los programas de cada categoria para esa parte.</p> <p>Todos los programas han sido probados de forma pr\u00e1ctica.</p>"},{"location":"programas/lista/#actividades-1-a-10","title":"Actividades 1 a 10","text":"<p>  MakeCodemicrobit*.hex  MicroBlocks (.ubp)Mu (.py)  Python .hex*.hex   Python .py*.py Primer proyecto Primer proyecto Primer proyecto Primer proyecto microbit-A01-Hola_Mundo A01-Hola_Mundo.ubp A01-Hola_Mundo-main A01-Hola_Mundo-main A02-Coraz\u00f3n_latiendo A02-Corazon_latiendo.ubp A02-Corazon_latiendo A02-Corazon_latiendo A03-boton_pulsado A03-boton-pulsado.ubp A03-Boton_pulsado en hexadecimal A03-Boton_pulsado en Python A04-parpadeoA04-parpadeo PWM A04-parpadeoA04-parpadeo PWM A04-parpadeo .hexA04-Encendido y apagado por PWM .hex A04-parpadeo .pyA04-Encendido y apagado por PWM .py A05-pulsador_LED A05-pulsador_LED A05-pulsador_LED A05-pulsador_LED A06-barra_10_LEDs A06-barra_10_LEDs A06-barra_10_LEDs A06-barra_10_LEDs A07-parpadeo_aleatorio_RGB A07-parpadeo_aleatorio_RGB A07-parpadeo_aleatorio_RGB A07-parpadeo_aleatorio_RGB A08-Neopixels A08-Neopixels A08-Neopixels_python A08-Neopixels_python microbit-A09-1_Buzzer_activo A09-1_Buzzer_activo A09-1_Buzzer_activo A09-1_Buzzer_activo A09-2_Buzzer pasivo_Notas A09-2_Buzzer-pasivo_Notas A09-2_Buzzer-pasivo_Notas A09-2_Buzzer-pasivo_Notas A09-3_Buzzer_pasivo_Melodia A09-3_Buzzer_pasivo_Melodia A09-3_Buzzer_pasivo_Melodia A09-3_Buzzer_pasivo_Melodia Avisador_nivel_iluminacion Avisador_nivel_iluminacion Avisador_nivel_iluminacion Avisador_nivel_iluminacion A10-Contador_puerto_serie A10-Contador_puerto_serie-Mu A10-Contador_puerto_serie A10-Contador_puerto_serie A1_10_MakeCode A1_10_MicroBlocks A1_10_Python (.hex) A1_10_Python (.py)"},{"location":"programas/lista/#actividades-11-a-20","title":"Actividades 11 a 20","text":"MakeCodemicrobit*.hex  MicroBlocks (.ubp)Mu (.py)  Python .hex*.hex   Python .py*.py A11-Br\u00fajula-NSEO A11-Br\u00fajula-NSEO A11-Br\u00fajula-NSEO A11-Br\u00fajula-NSEO A11_brujula45 A11-Br\u00fajula a 45\u00ba A11-Br\u00fajula a 45\u00ba A11-Br\u00fajula a 45\u00ba A11_aceleraciones A11_aceleraciones  --- A11_aceleraciones A11_gradiometro A11_gradiometro A11-A11_gradiometro A11-A11_gradiometro A12-potenci\u00f3metro A12-potenci\u00f3metro A12-potenci\u00f3metro A12-potenci\u00f3metro A13-1_control_LED_pot A13-1_control_LED_pot A13-1_control_LED_pot A13-1_control_LED_pot A13-2_control_RGB_pot A13-2_control_RGB_pot A13-2_control_RGB_pot A13-2_control_RGB_pot A13-3_control_Neo_pot A13-3_Neo_y_pot A13-3_control_Neo_pot A13-3_control_Neo_pot A14-1-Midiendo el nivel de luz A14-1-Midiendo el nivel de luz A14-1-Midiendo el nivel de luz A14-1-Midiendo el nivel de luz A14-2-Interruptor crepuscular A14-2-Interruptor crepuscular A14-2-Interruptor crepuscular A14-2-Interruptor crepuscular A15-Nivel_luz_LCD A15-Nivel_luz_LCD A15-Nivel de luz con LCD A15-Nivel de luz con LCD A16-Med_temp_sensor_int_MC A16-Med_temp_sensor_int_uB A16-Med_temp_sensor_int_uP A16-Med_temp_sensor_int_uP A16-Med_temp_sensor_int_term_MC A16-Med_temp_sensor_int_term_Mu A16-Med_temp_sensor_int_term_uP A16-Med_temp_sensor_int_term_uP A11_20_MakeCode A11_20_MicroBlocks A11_20_Python (.hex) A11_20_Python (.py)  MakeCodemicrobit*.hex  MicroBlocks (.ubp)Mu (.py)  Python .hex*.hex   Python .py*.py  MakeCodemicrobit*.hex  MicroBlocks (.ubp)Mu (.py)  Python .hex*.hex   Python .py*.py Comprimido de MakeCode Comprimido de MicroBlocks Comprimido de Python"},{"location":"programas/lista/#t","title":"t","text":""}]}